{"ast":null,"code":"\"use strict\";\n\nconst deprecate = require('depd')('tedious');\n\nconst crypto = require('crypto');\n\nconst os = require('os'); // $FlowFixMe\n\n\nconst constants = require('constants');\n\nconst _require = require('tls'),\n      createSecureContext = _require.createSecureContext;\n\nconst _require2 = require('adal-node'),\n      AuthenticationContext = _require2.AuthenticationContext;\n\nconst BulkLoad = require('./bulk-load');\n\nconst Debug = require('./debug');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst InstanceLookup = require('./instance-lookup').InstanceLookup;\n\nconst TransientErrorLookup = require('./transient-error-lookup.js').TransientErrorLookup;\n\nconst TYPE = require('./packet').TYPE;\n\nconst PreloginPayload = require('./prelogin-payload');\n\nconst Login7Payload = require('./login7-payload');\n\nconst NTLMResponsePayload = require('./ntlm-payload');\n\nconst Request = require('./request');\n\nconst RpcRequestPayload = require('./rpcrequest-payload');\n\nconst SqlBatchPayload = require('./sqlbatch-payload');\n\nconst MessageIO = require('./message-io');\n\nconst TokenStreamParser = require('./token/token-stream-parser').Parser;\n\nconst Transaction = require('./transaction').Transaction;\n\nconst ISOLATION_LEVEL = require('./transaction').ISOLATION_LEVEL;\n\nconst ConnectionError = require('./errors').ConnectionError;\n\nconst RequestError = require('./errors').RequestError;\n\nconst Connector = require('./connector').Connector;\n\nconst libraryName = require('./library').name;\n\nconst versions = require('./tds-versions').versions;\n\nconst _require3 = require('./ntlm'),\n      createNTLMRequest = _require3.createNTLMRequest; // A rather basic state machine for managing a connection.\n// Implements something approximating s3.2.1.\n\n\nconst KEEP_ALIVE_INITIAL_DELAY = 30 * 1000;\nconst DEFAULT_CONNECT_TIMEOUT = 15 * 1000;\nconst DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1000;\nconst DEFAULT_CANCEL_TIMEOUT = 5 * 1000;\nconst DEFAULT_CONNECT_RETRY_INTERVAL = 500;\nconst DEFAULT_PACKET_SIZE = 4 * 1024;\nconst DEFAULT_TEXTSIZE = '2147483647';\nconst DEFAULT_DATEFIRST = 7;\nconst DEFAULT_PORT = 1433;\nconst DEFAULT_TDS_VERSION = '7_4';\nconst DEFAULT_LANGUAGE = 'us_english';\nconst DEFAULT_DATEFORMAT = 'mdy';\n\nclass Connection extends EventEmitter {\n  constructor(config) {\n    super();\n\n    if (typeof config !== 'object' || config === null) {\n      throw new TypeError('The \"config\" argument is required and must be of type Object.');\n    }\n\n    if (typeof config.server !== 'string') {\n      throw new TypeError('The \"config.server\" property is required and must be of type string.');\n    }\n\n    this.fedAuthRequired = false;\n    this.fedAuthInfoToken = undefined;\n    let authentication;\n\n    if (config.authentication !== undefined) {\n      if (typeof config.authentication !== 'object' || config.authentication === null) {\n        throw new TypeError('The \"config.authentication\" property must be of type Object.');\n      }\n\n      if (typeof config.authentication.type !== 'string') {\n        throw new TypeError('The \"config.authentication.type\" property must be of type string.');\n      }\n\n      if (config.authentication.type !== 'default' && config.authentication.type !== 'ntlm' && config.authentication.type !== 'azure-active-directory-password') {\n        throw new TypeError('The \"config.authentication.type\" property must one of \"default\", \"ntlm\" or \"azure-active-directory-password\".');\n      }\n\n      if (config.authentication.options !== undefined) {\n        if (typeof config.authentication.options !== 'object' || config.authentication.options === null) {\n          throw new TypeError('The \"config.authentication.options\" property must be of type object.');\n        }\n\n        if (config.authentication.type === 'ntlm') {\n          if (typeof config.authentication.options.domain !== 'string') {\n            throw new TypeError('The \"config.authentication.options.domain\" property must be of type string.');\n          }\n        }\n\n        if (config.authentication.options.userName !== undefined && typeof config.authentication.options.userName !== 'string') {\n          throw new TypeError('The \"config.authentication.options.userName\" property must be of type string.');\n        }\n\n        if (config.authentication.options.password !== undefined && typeof config.authentication.options.password !== 'string') {\n          throw new TypeError('The \"config.authentication.options.password\" property must be of type string.');\n        }\n      }\n\n      authentication = {\n        type: config.authentication.type,\n        options: config.authentication.type === 'ntlm' ? {\n          userName: config.authentication.options.userName,\n          password: config.authentication.options.password,\n          domain: config.authentication.options.domain && config.authentication.options.domain.toUpperCase()\n        } : {\n          userName: config.authentication.options.userName,\n          password: config.authentication.options.password\n        }\n      };\n    } else {\n      if (config.domain !== undefined) {\n        if (typeof config.domain !== 'string') {\n          throw new TypeError('The \"config.domain\" property must be of type string.');\n        }\n\n        deprecate('The \"config.domain\" property is deprecated and future tedious versions will no longer support it. Please switch to using the new \"config.authentication\" property instead.');\n      }\n\n      if (config.userName !== undefined) {\n        if (typeof config.userName !== 'string') {\n          throw new TypeError('The \"config.userName\" property must be of type string.');\n        }\n\n        deprecate('The \"config.userName\" property is deprecated and future tedious versions will no longer support it. Please switch to using the new \"config.authentication\" property instead.');\n      }\n\n      if (config.password !== undefined) {\n        if (typeof config.password !== 'string') {\n          throw new TypeError('The \"config.password\" property must be of type string.');\n        }\n\n        deprecate('The \"config.password\" property is deprecated and future tedious versions will no longer support it. Please switch to using the new \"config.authentication\" property instead.');\n      }\n\n      authentication = {\n        type: config.domain ? 'ntlm' : 'default',\n        options: {\n          userName: config.userName,\n          password: config.password,\n          domain: config.domain && config.domain.toUpperCase()\n        }\n      };\n    }\n\n    this.config = {\n      server: config.server,\n      authentication: authentication,\n      options: {\n        abortTransactionOnError: false,\n        appName: undefined,\n        camelCaseColumns: false,\n        cancelTimeout: DEFAULT_CANCEL_TIMEOUT,\n        columnNameReplacer: undefined,\n        connectionRetryInterval: DEFAULT_CONNECT_RETRY_INTERVAL,\n        connectTimeout: DEFAULT_CONNECT_TIMEOUT,\n        connectionIsolationLevel: ISOLATION_LEVEL.READ_COMMITTED,\n        cryptoCredentialsDetails: {},\n        database: undefined,\n        datefirst: DEFAULT_DATEFIRST,\n        dateFormat: DEFAULT_DATEFORMAT,\n        debug: {\n          data: false,\n          packet: false,\n          payload: false,\n          token: false\n        },\n        enableAnsiNull: true,\n        enableAnsiNullDefault: true,\n        enableAnsiPadding: true,\n        enableAnsiWarnings: true,\n        enableArithAbort: false,\n        enableConcatNullYieldsNull: true,\n        enableCursorCloseOnCommit: null,\n        enableImplicitTransactions: false,\n        enableNumericRoundabort: false,\n        enableQuotedIdentifier: true,\n        encrypt: false,\n        fallbackToDefaultDb: false,\n        instanceName: undefined,\n        isolationLevel: ISOLATION_LEVEL.READ_COMMITTED,\n        language: DEFAULT_LANGUAGE,\n        localAddress: undefined,\n        maxRetriesOnTransientErrors: 3,\n        multiSubnetFailover: false,\n        packetSize: DEFAULT_PACKET_SIZE,\n        port: DEFAULT_PORT,\n        readOnlyIntent: false,\n        requestTimeout: DEFAULT_CLIENT_REQUEST_TIMEOUT,\n        rowCollectionOnDone: false,\n        rowCollectionOnRequestCompletion: false,\n        tdsVersion: DEFAULT_TDS_VERSION,\n        textsize: DEFAULT_TEXTSIZE,\n        trustServerCertificate: true,\n        useColumnNames: false,\n        useUTC: true\n      }\n    };\n\n    if (config.options) {\n      if (config.options.port && config.options.instanceName) {\n        throw new Error('Port and instanceName are mutually exclusive, but ' + config.options.port + ' and ' + config.options.instanceName + ' provided');\n      }\n\n      if (config.options.abortTransactionOnError !== undefined) {\n        if (typeof config.options.abortTransactionOnError !== 'boolean' && config.options.abortTransactionOnError !== null) {\n          throw new TypeError('The \"config.options.abortTransactionOnError\" property must be of type string or null.');\n        }\n\n        this.config.options.abortTransactionOnError = config.options.abortTransactionOnError;\n      }\n\n      if (config.options.appName !== undefined) {\n        if (typeof config.options.appName !== 'string') {\n          throw new TypeError('The \"config.options.appName\" property must be of type string.');\n        }\n\n        this.config.options.appName = config.options.appName;\n      }\n\n      if (config.options.camelCaseColumns !== undefined) {\n        if (typeof config.options.camelCaseColumns !== 'boolean') {\n          throw new TypeError('The \"config.options.camelCaseColumns\" property must be of type boolean.');\n        }\n\n        this.config.options.camelCaseColumns = config.options.camelCaseColumns;\n      }\n\n      if (config.options.cancelTimeout !== undefined) {\n        if (typeof config.options.cancelTimeout !== 'number') {\n          throw new TypeError('The \"config.options.cancelTimeout\" property must be of type number.');\n        }\n\n        this.config.options.cancelTimeout = config.options.cancelTimeout;\n      }\n\n      if (config.options.columnNameReplacer) {\n        if (typeof config.options.columnNameReplacer !== 'function') {\n          throw new TypeError('The \"config.options.cancelTimeout\" property must be of type function.');\n        }\n\n        this.config.options.columnNameReplacer = config.options.columnNameReplacer;\n      }\n\n      if (config.options.connectTimeout !== undefined) {\n        if (typeof config.options.connectTimeout !== 'number') {\n          throw new TypeError('The \"config.options.connectTimeout\" property must be of type number.');\n        }\n\n        this.config.options.connectTimeout = config.options.connectTimeout;\n      }\n\n      if (config.options.connectionIsolationLevel !== undefined) {\n        this.config.options.connectionIsolationLevel = config.options.connectionIsolationLevel;\n      }\n\n      if (config.options.connectTimeout !== undefined) {\n        if (typeof config.options.connectTimeout !== 'number') {\n          throw new TypeError('The \"config.options.connectTimeout\" property must be of type number.');\n        }\n\n        this.config.options.connectTimeout = config.options.connectTimeout;\n      }\n\n      if (config.options.cryptoCredentialsDetails !== undefined) {\n        if (typeof config.options.cryptoCredentialsDetails !== 'object' || config.options.cryptoCredentialsDetails === null) {\n          throw new TypeError('The \"config.options.cryptoCredentialsDetails\" property must be of type Object.');\n        }\n\n        this.config.options.cryptoCredentialsDetails = config.options.cryptoCredentialsDetails;\n      }\n\n      if (config.options.database !== undefined) {\n        if (typeof config.options.database !== 'string') {\n          throw new TypeError('The \"config.options.database\" property must be of type string.');\n        }\n\n        this.config.options.database = config.options.database;\n      }\n\n      if (config.options.datefirst !== undefined) {\n        if (typeof config.options.datefirst !== 'number' && config.options.datefirst !== null) {\n          throw new TypeError('The \"config.options.datefirst\" property must be of type number.');\n        }\n\n        if (config.options.datefirst !== null && (config.options.datefirst < 1 || config.options.datefirst > 7)) {\n          throw new RangeError('The \"config.options.datefirst\" property must be >= 1 and <= 7');\n        }\n\n        this.config.options.datefirst = config.options.datefirst;\n      }\n\n      if (config.options.dateFormat !== undefined) {\n        if (typeof config.options.dateFormat !== 'string' && config.options.dateFormat !== null) {\n          throw new TypeError('The \"config.options.dateFormat\" property must be of type string or null.');\n        }\n\n        this.config.options.dateFormat = config.options.dateFormat;\n      }\n\n      if (config.options.debug) {\n        if (config.options.debug.data !== undefined) {\n          if (typeof config.options.debug.data !== 'boolean') {\n            throw new TypeError('The \"config.options.debug.data\" property must be of type boolean.');\n          }\n\n          this.config.options.debug.data = config.options.debug.data;\n        }\n\n        if (config.options.debug.packet !== undefined) {\n          if (typeof config.options.debug.packet !== 'boolean') {\n            throw new TypeError('The \"config.options.debug.packet\" property must be of type boolean.');\n          }\n\n          this.config.options.debug.packet = config.options.debug.packet;\n        }\n\n        if (config.options.debug.payload !== undefined) {\n          if (typeof config.options.debug.payload !== 'boolean') {\n            throw new TypeError('The \"config.options.debug.payload\" property must be of type boolean.');\n          }\n\n          this.config.options.debug.payload = config.options.debug.payload;\n        }\n\n        if (config.options.debug.token !== undefined) {\n          if (typeof config.options.debug.token !== 'boolean') {\n            throw new TypeError('The \"config.options.debug.token\" property must be of type boolean.');\n          }\n\n          this.config.options.debug.token = config.options.debug.token;\n        }\n      }\n\n      if (config.options.enableAnsiNull !== undefined) {\n        if (typeof config.options.enableAnsiNull !== 'boolean' && config.options.enableAnsiNull !== null) {\n          throw new TypeError('The \"config.options.enableAnsiNull\" property must be of type boolean or null.');\n        }\n\n        this.config.options.enableAnsiNull = config.options.enableAnsiNull;\n      }\n\n      if (config.options.enableAnsiNullDefault !== undefined) {\n        if (typeof config.options.enableAnsiNullDefault !== 'boolean' && config.options.enableAnsiNullDefault !== null) {\n          throw new TypeError('The \"config.options.enableAnsiNullDefault\" property must be of type boolean or null.');\n        }\n\n        this.config.options.enableAnsiNullDefault = config.options.enableAnsiNullDefault;\n      }\n\n      if (config.options.enableAnsiPadding !== undefined) {\n        if (typeof config.options.enableAnsiPadding !== 'boolean' && config.options.enableAnsiPadding !== null) {\n          throw new TypeError('The \"config.options.enableAnsiPadding\" property must be of type boolean or null.');\n        }\n\n        this.config.options.enableAnsiPadding = config.options.enableAnsiPadding;\n      }\n\n      if (config.options.enableAnsiWarnings !== undefined) {\n        if (typeof config.options.enableAnsiWarnings !== 'boolean' && config.options.enableAnsiWarnings !== null) {\n          throw new TypeError('The \"config.options.enableAnsiWarnings\" property must be of type boolean or null.');\n        }\n\n        this.config.options.enableAnsiWarnings = config.options.enableAnsiWarnings;\n      }\n\n      if (config.options.enableArithAbort !== undefined) {\n        if (typeof config.options.enableArithAbort !== 'boolean' && config.options.enableArithAbort !== null) {\n          throw new TypeError('The \"config.options.enableArithAbort\" property must be of type boolean or null.');\n        }\n\n        this.config.options.enableArithAbort = config.options.enableArithAbort;\n      }\n\n      if (config.options.enableConcatNullYieldsNull !== undefined) {\n        if (typeof config.options.enableConcatNullYieldsNull !== 'boolean' && config.options.enableConcatNullYieldsNull !== null) {\n          throw new TypeError('The \"config.options.enableConcatNullYieldsNull\" property must be of type boolean or null.');\n        }\n\n        this.config.options.enableConcatNullYieldsNull = config.options.enableConcatNullYieldsNull;\n      }\n\n      if (config.options.enableCursorCloseOnCommit !== undefined) {\n        if (typeof config.options.enableCursorCloseOnCommit !== 'boolean' && config.options.enableCursorCloseOnCommit !== null) {\n          throw new TypeError('The \"config.options.enableCursorCloseOnCommit\" property must be of type boolean or null.');\n        }\n\n        this.config.options.enableCursorCloseOnCommit = config.options.enableCursorCloseOnCommit;\n      }\n\n      if (config.options.enableImplicitTransactions !== undefined) {\n        if (typeof config.options.enableImplicitTransactions !== 'boolean' && config.options.enableImplicitTransactions !== null) {\n          throw new TypeError('The \"config.options.enableImplicitTransactions\" property must be of type boolean or null.');\n        }\n\n        this.config.options.enableImplicitTransactions = config.options.enableImplicitTransactions;\n      }\n\n      if (config.options.enableNumericRoundabort !== undefined) {\n        if (typeof config.options.enableNumericRoundabort !== 'boolean' && config.options.enableNumericRoundabort !== null) {\n          throw new TypeError('The \"config.options.enableNumericRoundabort\" property must be of type boolean or null.');\n        }\n\n        this.config.options.enableNumericRoundabort = config.options.enableNumericRoundabort;\n      }\n\n      if (config.options.enableQuotedIdentifier !== undefined) {\n        if (typeof config.options.enableQuotedIdentifier !== 'boolean' && config.options.enableQuotedIdentifier !== null) {\n          throw new TypeError('The \"config.options.enableQuotedIdentifier\" property must be of type boolean or null.');\n        }\n\n        this.config.options.enableQuotedIdentifier = config.options.enableQuotedIdentifier;\n      }\n\n      if (config.options.encrypt !== undefined) {\n        if (typeof config.options.encrypt !== 'boolean') {\n          throw new TypeError('The \"config.options.encrypt\" property must be of type boolean.');\n        }\n\n        this.config.options.encrypt = config.options.encrypt;\n      } else {\n        deprecate('The default value for `options.encrypt` will change from `false` to `true`. Please pass `false` explicitly if you want to retain current behaviour.');\n        this.config.options.encrypt = false;\n      }\n\n      if (config.options.fallbackToDefaultDb !== undefined) {\n        if (typeof config.options.fallbackToDefaultDb !== 'boolean') {\n          throw new TypeError('The \"config.options.fallbackToDefaultDb\" property must be of type boolean.');\n        }\n\n        this.config.options.fallbackToDefaultDb = config.options.fallbackToDefaultDb;\n      }\n\n      if (config.options.instanceName !== undefined) {\n        if (typeof config.options.instanceName !== 'string') {\n          throw new TypeError('The \"config.options.instanceName\" property must be of type string.');\n        }\n\n        this.config.options.instanceName = config.options.instanceName;\n        this.config.options.port = undefined;\n      }\n\n      if (config.options.isolationLevel !== undefined) {\n        if (typeof config.options.isolationLevel !== 'number') {\n          throw new TypeError('The \"config.options.language\" property must be of type numer.');\n        }\n\n        this.config.options.isolationLevel = config.options.isolationLevel;\n      }\n\n      if (config.options.language !== undefined) {\n        if (typeof config.options.language !== 'string' && config.options.language !== null) {\n          throw new TypeError('The \"config.options.language\" property must be of type string or null.');\n        }\n\n        this.config.options.language = config.options.language;\n      }\n\n      if (config.options.localAddress !== undefined) {\n        if (typeof config.options.localAddress !== 'string') {\n          throw new TypeError('The \"config.options.localAddress\" property must be of type string.');\n        }\n\n        this.config.options.localAddress = config.options.localAddress;\n      }\n\n      if (config.options.multiSubnetFailover !== undefined) {\n        if (typeof config.options.multiSubnetFailover !== 'boolean') {\n          throw new TypeError('The \"config.options.multiSubnetFailover\" property must be of type boolean.');\n        }\n\n        this.config.options.multiSubnetFailover = config.options.multiSubnetFailover;\n      }\n\n      if (config.options.packetSize !== undefined) {\n        if (typeof config.options.packetSize !== 'number') {\n          throw new TypeError('The \"config.options.packetSize\" property must be of type number.');\n        }\n\n        this.config.options.packetSize = config.options.packetSize;\n      }\n\n      if (config.options.port !== undefined) {\n        if (typeof config.options.port !== 'number') {\n          throw new TypeError('The \"config.options.port\" property must be of type number.');\n        }\n\n        if (config.options.port <= 0 || config.options.port >= 65536) {\n          throw new RangeError('The \"config.options.port\" property must be > 0 and < 65536');\n        }\n\n        this.config.options.port = config.options.port;\n        this.config.options.instanceName = undefined;\n      }\n\n      if (config.options.readOnlyIntent !== undefined) {\n        if (typeof config.options.readOnlyIntent !== 'boolean') {\n          throw new TypeError('The \"config.options.readOnlyIntent\" property must be of type boolean.');\n        }\n\n        this.config.options.readOnlyIntent = config.options.readOnlyIntent;\n      }\n\n      if (config.options.requestTimeout !== undefined) {\n        if (typeof config.options.requestTimeout !== 'number') {\n          throw new TypeError('The \"config.options.requestTimeout\" property must be of type number.');\n        }\n\n        this.config.options.requestTimeout = config.options.requestTimeout;\n      }\n\n      if (config.options.maxRetriesOnTransientErrors !== undefined) {\n        if (typeof config.options.maxRetriesOnTransientErrors !== 'number') {\n          throw new TypeError('The \"config.options.maxRetriesOnTransientErrors\" property must be of type number.');\n        }\n\n        if (config.options.maxRetriesOnTransientErrors < 0) {\n          throw new TypeError('The \"config.options.maxRetriesOnTransientErrors\" property must be equal or greater than 0.');\n        }\n\n        this.config.options.maxRetriesOnTransientErrors = config.options.maxRetriesOnTransientErrors;\n      }\n\n      if (config.options.connectionRetryInterval !== undefined) {\n        if (typeof config.options.connectionRetryInterval !== 'number') {\n          throw new TypeError('The \"config.options.connectionRetryInterval\" property must be of type number.');\n        }\n\n        if (config.options.connectionRetryInterval <= 0) {\n          throw new TypeError('The \"config.options.connectionRetryInterval\" property must be greater than 0.');\n        }\n\n        this.config.options.connectionRetryInterval = config.options.connectionRetryInterval;\n      }\n\n      if (config.options.rowCollectionOnDone !== undefined) {\n        if (typeof config.options.rowCollectionOnDone !== 'boolean') {\n          throw new TypeError('The \"config.options.rowCollectionOnDone\" property must be of type boolean.');\n        }\n\n        this.config.options.rowCollectionOnDone = config.options.rowCollectionOnDone;\n      }\n\n      if (config.options.rowCollectionOnRequestCompletion !== undefined) {\n        if (typeof config.options.rowCollectionOnRequestCompletion !== 'boolean') {\n          throw new TypeError('The \"config.options.rowCollectionOnRequestCompletion\" property must be of type boolean.');\n        }\n\n        this.config.options.rowCollectionOnRequestCompletion = config.options.rowCollectionOnRequestCompletion;\n      }\n\n      if (config.options.tdsVersion !== undefined) {\n        if (typeof config.options.tdsVersion !== 'string') {\n          throw new TypeError('The \"config.options.tdsVersion\" property must be of type string.');\n        }\n\n        this.config.options.tdsVersion = config.options.tdsVersion;\n      }\n\n      if (config.options.textsize !== undefined) {\n        if (typeof config.options.textsize !== 'number' && config.options.textsize !== null) {\n          throw new TypeError('The \"config.options.textsize\" property must be of type number or null.');\n        }\n\n        this.config.options.textsize = config.options.textsize;\n      }\n\n      if (config.options.trustServerCertificate !== undefined) {\n        if (typeof config.options.trustServerCertificate !== 'boolean') {\n          throw new TypeError('The \"config.options.trustServerCertificate\" property must be of type boolean.');\n        }\n\n        this.config.options.trustServerCertificate = config.options.trustServerCertificate;\n      }\n\n      if (config.options.useColumnNames !== undefined) {\n        if (typeof config.options.useColumnNames !== 'boolean') {\n          throw new TypeError('The \"config.options.useColumnNames\" property must be of type boolean.');\n        }\n\n        this.config.options.useColumnNames = config.options.useColumnNames;\n      }\n\n      if (config.options.useUTC !== undefined) {\n        if (typeof config.options.useUTC !== 'boolean') {\n          throw new TypeError('The \"config.options.useUTC\" property must be of type boolean.');\n        }\n\n        this.config.options.useUTC = config.options.useUTC;\n      }\n    }\n\n    let credentialsDetails = this.config.options.cryptoCredentialsDetails;\n\n    if (credentialsDetails.secureOptions === undefined) {\n      // If the caller has not specified their own `secureOptions`,\n      // we set `SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS` here.\n      // Older SQL Server instances running on older Windows versions have\n      // trouble with the BEAST workaround in OpenSSL.\n      // As BEAST is a browser specific exploit, we can just disable this option here.\n      credentialsDetails = Object.create(credentialsDetails, {\n        secureOptions: {\n          value: constants.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS\n        }\n      });\n    }\n\n    this.secureContext = createSecureContext(credentialsDetails);\n    this.createDebug();\n    this.createTokenStreamParser();\n    this.inTransaction = false;\n    this.transactionDescriptors = [Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])];\n    this.transitionTo(this.STATE.CONNECTING);\n\n    if (this.config.options.tdsVersion < '7_2') {\n      // 'beginTransaction', 'commitTransaction' and 'rollbackTransaction'\n      // events are utilized to maintain inTransaction property state which in\n      // turn is used in managing transactions. These events are only fired for\n      // TDS version 7.2 and beyond. The properties below are used to emulate\n      // equivalent behavior for TDS versions before 7.2.\n      this.transactionDepth = 0;\n      this.isSqlBatch = false;\n    }\n\n    this.curTransientRetryCount = 0;\n    this.transientErrorLookup = new TransientErrorLookup();\n    this.cleanupTypeEnum = {\n      NORMAL: 0,\n      REDIRECT: 1,\n      RETRY: 2\n    };\n  }\n\n  close() {\n    this.transitionTo(this.STATE.FINAL);\n  }\n\n  initialiseConnection() {\n    this.connect();\n    this.createConnectTimer();\n  }\n\n  cleanupConnection(cleanupTypeEnum) {\n    if (!this.closed) {\n      this.clearConnectTimer();\n      this.clearRequestTimer();\n      this.clearRetryTimer();\n      this.closeConnection();\n\n      if (cleanupTypeEnum === this.cleanupTypeEnum.REDIRECT) {\n        this.emit('rerouting');\n      } else if (cleanupTypeEnum !== this.cleanupTypeEnum.RETRY) {\n        this.emit('end');\n      }\n\n      if (this.request) {\n        const err = RequestError('Connection closed before request completed.', 'ECLOSE');\n        this.request.callback(err);\n        this.request = undefined;\n      }\n\n      this.closed = true;\n      this.loggedIn = false;\n      this.loginError = null;\n    }\n  }\n\n  createDebug() {\n    this.debug = new Debug(this.config.options.debug);\n    this.debug.on('debug', message => {\n      this.emit('debug', message);\n    });\n  }\n\n  createTokenStreamParser() {\n    this.tokenStreamParser = new TokenStreamParser(this.debug, undefined, this.config.options);\n    this.tokenStreamParser.on('infoMessage', token => {\n      this.emit('infoMessage', token);\n    });\n    this.tokenStreamParser.on('sspichallenge', token => {\n      if (token.ntlmpacket) {\n        this.ntlmpacket = token.ntlmpacket;\n        this.ntlmpacketBuffer = token.ntlmpacketBuffer;\n      }\n\n      this.emit('sspichallenge', token);\n    });\n    this.tokenStreamParser.on('errorMessage', token => {\n      this.emit('errorMessage', token);\n\n      if (this.loggedIn) {\n        if (this.request) {\n          this.request.error = RequestError(token.message, 'EREQUEST');\n          this.request.error.number = token.number;\n          this.request.error.state = token.state;\n          this.request.error['class'] = token['class'];\n          this.request.error.serverName = token.serverName;\n          this.request.error.procName = token.procName;\n          this.request.error.lineNumber = token.lineNumber;\n        }\n      } else {\n        const isLoginErrorTransient = this.transientErrorLookup.isTransientError(token.number);\n\n        if (isLoginErrorTransient && this.curTransientRetryCount !== this.config.options.maxRetriesOnTransientErrors) {\n          this.debug.log('Initiating retry on transient error = ', token.number);\n          this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);\n        } else {\n          this.loginError = ConnectionError(token.message, 'ELOGIN');\n        }\n      }\n    });\n    this.tokenStreamParser.on('databaseChange', token => {\n      this.emit('databaseChange', token.newValue);\n    });\n    this.tokenStreamParser.on('languageChange', token => {\n      this.emit('languageChange', token.newValue);\n    });\n    this.tokenStreamParser.on('charsetChange', token => {\n      this.emit('charsetChange', token.newValue);\n    });\n    this.tokenStreamParser.on('fedAuthInfo', token => {\n      this.dispatchEvent('fedAuthInfo', token);\n    });\n    this.tokenStreamParser.on('featureExtAck', token => {\n      this.dispatchEvent('featureExtAck', token);\n    });\n    this.tokenStreamParser.on('loginack', token => {\n      if (!token.tdsVersion) {\n        // unsupported TDS version\n        this.loginError = ConnectionError('Server responded with unknown TDS version.', 'ETDS');\n        this.loggedIn = false;\n        return;\n      }\n\n      if (!token['interface']) {\n        // unsupported interface\n        this.loginError = ConnectionError('Server responded with unsupported interface.', 'EINTERFACENOTSUPP');\n        this.loggedIn = false;\n        return;\n      } // use negotiated version\n\n\n      this.config.options.tdsVersion = token.tdsVersion;\n      this.loggedIn = true;\n    });\n    this.tokenStreamParser.on('routingChange', token => {\n      this.routingData = token.newValue;\n      this.dispatchEvent('routingChange');\n    });\n    this.tokenStreamParser.on('packetSizeChange', token => {\n      this.messageIo.packetSize(token.newValue);\n    }); // A new top-level transaction was started. This is not fired\n    // for nested transactions.\n\n    this.tokenStreamParser.on('beginTransaction', token => {\n      this.transactionDescriptors.push(token.newValue);\n      this.inTransaction = true;\n    }); // A top-level transaction was committed. This is not fired\n    // for nested transactions.\n\n    this.tokenStreamParser.on('commitTransaction', () => {\n      this.transactionDescriptors.length = 1;\n      this.inTransaction = false;\n    }); // A top-level transaction was rolled back. This is not fired\n    // for nested transactions. This is also fired if a batch\n    // aborting error happened that caused a rollback.\n\n    this.tokenStreamParser.on('rollbackTransaction', () => {\n      this.transactionDescriptors.length = 1; // An outermost transaction was rolled back. Reset the transaction counter\n\n      this.inTransaction = false;\n      this.emit('rollbackTransaction');\n    });\n    this.tokenStreamParser.on('columnMetadata', token => {\n      if (this.request) {\n        let columns;\n\n        if (this.config.options.useColumnNames) {\n          columns = {};\n\n          for (let j = 0, len = token.columns.length; j < len; j++) {\n            const col = token.columns[j];\n\n            if (columns[col.colName] == null) {\n              columns[col.colName] = col;\n            }\n          }\n        } else {\n          columns = token.columns;\n        }\n\n        this.request.emit('columnMetadata', columns);\n      } else {\n        this.emit('error', new Error(\"Received 'columnMetadata' when no sqlRequest is in progress\"));\n        this.close();\n      }\n    });\n    this.tokenStreamParser.on('order', token => {\n      if (this.request) {\n        this.request.emit('order', token.orderColumns);\n      } else {\n        this.emit('error', new Error(\"Received 'order' when no sqlRequest is in progress\"));\n        this.close();\n      }\n    });\n    this.tokenStreamParser.on('row', token => {\n      if (this.request) {\n        if (this.config.options.rowCollectionOnRequestCompletion) {\n          this.request.rows.push(token.columns);\n        }\n\n        if (this.config.options.rowCollectionOnDone) {\n          this.request.rst.push(token.columns);\n        }\n\n        if (!(this.state === this.STATE.SENT_ATTENTION && this.request.paused)) {\n          this.request.emit('row', token.columns);\n        }\n      } else {\n        this.emit('error', new Error(\"Received 'row' when no sqlRequest is in progress\"));\n        this.close();\n      }\n    });\n    this.tokenStreamParser.on('returnStatus', token => {\n      if (this.request) {\n        // Keep value for passing in 'doneProc' event.\n        this.procReturnStatusValue = token.value;\n      }\n    });\n    this.tokenStreamParser.on('returnValue', token => {\n      if (this.request) {\n        this.request.emit('returnValue', token.paramName, token.value, token.metadata);\n      }\n    });\n    this.tokenStreamParser.on('doneProc', token => {\n      if (this.request) {\n        this.request.emit('doneProc', token.rowCount, token.more, this.procReturnStatusValue, this.request.rst);\n        this.procReturnStatusValue = undefined;\n\n        if (token.rowCount !== undefined) {\n          this.request.rowCount += token.rowCount;\n        }\n\n        if (this.config.options.rowCollectionOnDone) {\n          this.request.rst = [];\n        }\n      }\n    });\n    this.tokenStreamParser.on('doneInProc', token => {\n      if (this.request) {\n        this.request.emit('doneInProc', token.rowCount, token.more, this.request.rst);\n\n        if (token.rowCount !== undefined) {\n          this.request.rowCount += token.rowCount;\n        }\n\n        if (this.config.options.rowCollectionOnDone) {\n          this.request.rst = [];\n        }\n      }\n    });\n    this.tokenStreamParser.on('done', token => {\n      if (this.request) {\n        if (token.attention) {\n          this.dispatchEvent('attention');\n        }\n\n        if (token.sqlError && !this.request.error) {\n          // check if the DONE_ERROR flags was set, but an ERROR token was not sent.\n          this.request.error = RequestError('An unknown error has occurred.', 'UNKNOWN');\n        }\n\n        this.request.emit('done', token.rowCount, token.more, this.request.rst);\n\n        if (token.rowCount !== undefined) {\n          this.request.rowCount += token.rowCount;\n        }\n\n        if (this.config.options.rowCollectionOnDone) {\n          this.request.rst = [];\n        }\n      }\n    });\n    this.tokenStreamParser.on('endOfMessage', () => {\n      // EOM pseudo token received\n      if (this.state === this.STATE.SENT_CLIENT_REQUEST) {\n        this.dispatchEvent('endOfMessageMarkerReceived');\n      }\n    });\n    this.tokenStreamParser.on('resetConnection', () => {\n      this.emit('resetConnection');\n    });\n    this.tokenStreamParser.on('tokenStreamError', error => {\n      this.emit('error', error);\n      this.close();\n    });\n    this.tokenStreamParser.on('drain', () => {\n      // Bridge the release of backpressure from the token stream parser\n      // transform to the packet stream transform.\n      this.messageIo.resume();\n    });\n  }\n\n  connect() {\n    if (this.config.options.port) {\n      return this.connectOnPort(this.config.options.port, this.config.options.multiSubnetFailover);\n    } else {\n      return new InstanceLookup().instanceLookup({\n        server: this.config.server,\n        instanceName: this.config.options.instanceName,\n        timeout: this.config.options.connectTimeout\n      }, (message, port) => {\n        if (this.state === this.STATE.FINAL) {\n          return;\n        }\n\n        if (message) {\n          this.emit('connect', ConnectionError(message, 'EINSTLOOKUP'));\n        } else {\n          this.connectOnPort(port, this.config.options.multiSubnetFailover);\n        }\n      });\n    }\n  }\n\n  connectOnPort(port, multiSubnetFailover) {\n    const connectOpts = {\n      host: this.routingData ? this.routingData.server : this.config.server,\n      port: this.routingData ? this.routingData.port : port,\n      localAddress: this.config.options.localAddress\n    };\n    new Connector(connectOpts, multiSubnetFailover).execute((err, socket) => {\n      if (err) {\n        return this.socketError(err);\n      }\n\n      if (this.state === this.STATE.FINAL) {\n        socket.destroy();\n        return;\n      }\n\n      this.socket = socket;\n      this.socket.on('error', error => {\n        this.socketError(error);\n      });\n      this.socket.on('close', () => {\n        this.socketClose();\n      });\n      this.socket.on('end', () => {\n        this.socketEnd();\n      });\n      this.messageIo = new MessageIO(this.socket, this.config.options.packetSize, this.debug);\n      this.messageIo.on('data', data => {\n        this.dispatchEvent('data', data);\n      });\n      this.messageIo.on('message', () => {\n        this.dispatchEvent('message');\n      });\n      this.messageIo.on('secure', cleartext => {\n        this.emit('secure', cleartext);\n      });\n      this.socketConnect();\n    });\n  }\n\n  closeConnection() {\n    if (this.socket) {\n      this.socket.destroy();\n    }\n  }\n\n  createConnectTimer() {\n    this.connectTimer = setTimeout(() => {\n      this.connectTimeout();\n    }, this.config.options.connectTimeout);\n  }\n\n  createRequestTimer() {\n    this.clearRequestTimer(); // release old timer, just to be safe\n\n    const timeout = this.request.timeout !== undefined ? this.request.timeout : this.config.options.requestTimeout;\n\n    if (timeout) {\n      this.requestTimer = setTimeout(() => {\n        this.requestTimeout();\n      }, timeout);\n    }\n  }\n\n  createRetryTimer() {\n    this.clearRetryTimer();\n    this.retryTimer = setTimeout(() => {\n      this.retryTimeout();\n    }, this.config.options.connectionRetryInterval);\n  }\n\n  connectTimeout() {\n    const message = \"Failed to connect to \".concat(this.config.server).concat(this.config.options.port ? \":\".concat(this.config.options.port) : \"\\\\\".concat(this.config.options.instanceName), \" in \").concat(this.config.options.connectTimeout, \"ms\");\n    this.debug.log(message);\n    this.emit('connect', ConnectionError(message, 'ETIMEOUT'));\n    this.connectTimer = undefined;\n    this.dispatchEvent('connectTimeout');\n  }\n\n  requestTimeout() {\n    this.requestTimer = undefined;\n    this.messageIo.sendMessage(TYPE.ATTENTION);\n    this.transitionTo(this.STATE.SENT_ATTENTION);\n  }\n\n  retryTimeout() {\n    this.retryTimer = undefined;\n    this.emit('retry');\n    this.transitionTo(this.STATE.CONNECTING);\n  }\n\n  clearConnectTimer() {\n    if (this.connectTimer) {\n      clearTimeout(this.connectTimer);\n    }\n  }\n\n  clearRequestTimer() {\n    if (this.requestTimer) {\n      clearTimeout(this.requestTimer);\n      this.requestTimer = undefined;\n    }\n  }\n\n  clearRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = undefined;\n    }\n  }\n\n  transitionTo(newState) {\n    if (this.state === newState) {\n      this.debug.log('State is already ' + newState.name);\n      return;\n    }\n\n    if (this.state && this.state.exit) {\n      this.state.exit.call(this, newState);\n    }\n\n    this.debug.log('State change: ' + (this.state ? this.state.name : undefined) + ' -> ' + newState.name);\n    this.state = newState;\n\n    if (this.state.enter) {\n      this.state.enter.apply(this);\n    }\n  }\n\n  dispatchEvent(eventName, ...args) {\n    if (this.state.events[eventName]) {\n      this.state.events[eventName].apply(this, args);\n    } else {\n      this.emit('error', new Error(\"No event '\".concat(eventName, \"' in state '\").concat(this.state.name, \"'\")));\n      this.close();\n    }\n  }\n\n  socketError(error) {\n    if (this.state === this.STATE.CONNECTING || this.state === this.STATE.SENT_TLSSSLNEGOTIATION) {\n      const message = \"Failed to connect to \".concat(this.config.server, \":\").concat(this.config.options.port, \" - \").concat(error.message);\n      this.debug.log(message);\n      this.emit('connect', ConnectionError(message, 'ESOCKET'));\n    } else {\n      const message = \"Connection lost - \".concat(error.message);\n      this.debug.log(message);\n      this.emit('error', ConnectionError(message, 'ESOCKET'));\n    }\n\n    this.dispatchEvent('socketError', error);\n  }\n\n  socketConnect() {\n    this.socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);\n    this.closed = false;\n    this.debug.log('connected to ' + this.config.server + ':' + this.config.options.port);\n    this.dispatchEvent('socketConnect');\n  }\n\n  socketEnd() {\n    this.debug.log('socket ended');\n\n    if (this.state !== this.STATE.FINAL) {\n      const error = new Error('socket hang up');\n      error.code = 'ECONNRESET';\n      this.socketError(error);\n    }\n  }\n\n  socketClose() {\n    this.debug.log('connection to ' + this.config.server + ':' + this.config.options.port + ' closed');\n\n    if (this.state === this.STATE.REROUTING) {\n      this.debug.log('Rerouting to ' + this.routingData.server + ':' + this.routingData.port);\n      this.dispatchEvent('reconnect');\n    } else if (this.state === this.STATE.TRANSIENT_FAILURE_RETRY) {\n      const server = this.routingData ? this.routingData.server : this.server;\n      const port = this.routingData ? this.routingData.port : this.config.options.port;\n      this.debug.log('Retry after transient failure connecting to ' + server + ':' + port);\n      this.dispatchEvent('retry');\n    } else {\n      this.transitionTo(this.STATE.FINAL);\n    }\n  }\n\n  sendPreLogin() {\n    const payload = new PreloginPayload({\n      encrypt: this.config.options.encrypt\n    });\n    this.messageIo.sendMessage(TYPE.PRELOGIN, payload.data);\n    this.debug.payload(function () {\n      return payload.toString('  ');\n    });\n  }\n\n  emptyMessageBuffer() {\n    this.messageBuffer = Buffer.alloc(0);\n  }\n\n  addToMessageBuffer(data) {\n    this.messageBuffer = Buffer.concat([this.messageBuffer, data]);\n  }\n\n  processPreLoginResponse() {\n    const preloginPayload = new PreloginPayload(this.messageBuffer);\n    this.debug.payload(function () {\n      return preloginPayload.toString('  ');\n    });\n\n    if (preloginPayload.fedAuthRequired === 1) {\n      this.fedAuthRequired = true;\n    }\n\n    if (preloginPayload.encryptionString === 'ON' || preloginPayload.encryptionString === 'REQ') {\n      if (!this.config.options.encrypt) {\n        this.emit('connect', ConnectionError(\"Server requires encryption, set 'encrypt' config option to true.\", 'EENCRYPT'));\n        return this.close();\n      }\n\n      this.dispatchEvent('tls');\n    } else {\n      this.dispatchEvent('noTls');\n    }\n  }\n\n  sendLogin7Packet(cb) {\n    const payload = new Login7Payload({\n      tdsVersion: versions[this.config.options.tdsVersion],\n      packetSize: this.config.options.packetSize,\n      clientProgVer: 0,\n      clientPid: process.pid,\n      connectionId: 0,\n      clientTimeZone: new Date().getTimezoneOffset(),\n      clientLcid: 0x00000409\n    });\n    const authentication = this.config.authentication;\n\n    switch (authentication.type) {\n      case 'azure-active-directory-password':\n        payload.fedAuth = {\n          type: 'ADAL',\n          echo: this.fedAuthRequired,\n          workflow: 'default'\n        };\n        break;\n\n      case 'ntlm':\n        payload.sspi = createNTLMRequest({\n          domain: authentication.options.domain\n        });\n        break;\n\n      default:\n        payload.userName = authentication.options.userName;\n        payload.password = authentication.options.password;\n    }\n\n    payload.hostname = os.hostname();\n    payload.serverName = this.routingData ? this.routingData.server : this.config.server;\n    payload.appName = this.config.options.appName || 'Tedious';\n    payload.libraryName = libraryName;\n    payload.language = this.config.options.language;\n    payload.database = this.config.options.database;\n    payload.clientId = Buffer.from([1, 2, 3, 4, 5, 6]);\n    payload.readOnlyIntent = this.config.options.readOnlyIntent;\n    payload.initDbFatal = !this.config.options.fallbackToDefaultDb;\n    this.routingData = undefined;\n    this.messageIo.sendMessage(TYPE.LOGIN7, payload.toBuffer());\n    this.debug.payload(function () {\n      return payload.toString('  ');\n    });\n    process.nextTick(cb);\n  }\n\n  sendNTLMResponsePacket() {\n    const authentication = this.config.authentication;\n    const payload = new NTLMResponsePayload({\n      domain: authentication.options.domain,\n      userName: authentication.options.userName,\n      password: authentication.options.password,\n      database: this.config.options.database,\n      appName: this.config.options.appName,\n      packetSize: this.config.options.packetSize,\n      tdsVersion: this.config.options.tdsVersion,\n      ntlmpacket: this.ntlmpacket,\n      additional: this.additional\n    });\n    this.messageIo.sendMessage(TYPE.NTLMAUTH_PKT, payload.data);\n    this.debug.payload(function () {\n      return payload.toString('  ');\n    });\n    process.nextTick(() => {\n      this.transitionTo(this.STATE.SENT_NTLM_RESPONSE);\n    });\n  }\n\n  sendFedAuthResponsePacket(tokenResponse) {\n    const accessTokenLen = Buffer.byteLength(tokenResponse.accessToken, 'ucs2');\n    const data = Buffer.alloc(8 + accessTokenLen);\n    let offset = 0;\n    offset = data.writeUInt32LE(accessTokenLen + 4, offset);\n    offset = data.writeUInt32LE(accessTokenLen, offset);\n    data.write(tokenResponse.accessToken, offset, 'ucs2');\n    this.messageIo.sendMessage(TYPE.FEDAUTH_TOKEN, data); // sent the fedAuth token message, the rest is similar to standard login 7\n\n    process.nextTick(() => {\n      this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);\n    });\n  } // Returns false to apply backpressure.\n\n\n  sendDataToTokenStreamParser(data) {\n    return this.tokenStreamParser.addBuffer(data);\n  } // This is an internal method that is called from Request.pause().\n  // It has to check whether the passed Request object represents the currently\n  // active request, because the application might have called Request.pause()\n  // on an old inactive Request object.\n\n\n  pauseRequest(request) {\n    if (this.isRequestActive(request)) {\n      this.tokenStreamParser.pause();\n    }\n  } // This is an internal method that is called from Request.resume().\n\n\n  resumeRequest(request) {\n    if (this.isRequestActive(request)) {\n      this.tokenStreamParser.resume();\n    }\n  } // Returns true if the passed request is the currently active request of the connection.\n\n\n  isRequestActive(request) {\n    return request === this.request && this.state === this.STATE.SENT_CLIENT_REQUEST;\n  }\n\n  sendInitialSql() {\n    const payload = new SqlBatchPayload(this.getInitialSql(), this.currentTransactionDescriptor(), this.config.options);\n    return this.messageIo.sendMessage(TYPE.SQL_BATCH, payload.data);\n  }\n\n  getInitialSql() {\n    const options = [];\n\n    if (this.config.options.enableAnsiNull === true) {\n      options.push('set ansi_nulls on');\n    } else if (this.config.options.enableAnsiNull === false) {\n      options.push('set ansi_nulls off');\n    }\n\n    if (this.config.options.enableAnsiNullDefault === true) {\n      options.push('set ansi_null_dflt_on on');\n    } else if (this.config.options.enableAnsiNullDefault === false) {\n      options.push('set ansi_null_dflt_on off');\n    }\n\n    if (this.config.options.enableAnsiPadding === true) {\n      options.push('set ansi_padding on');\n    } else if (this.config.options.enableAnsiPadding === false) {\n      options.push('set ansi_padding off');\n    }\n\n    if (this.config.options.enableAnsiWarnings === true) {\n      options.push('set ansi_warnings on');\n    } else if (this.config.options.enableAnsiWarnings === false) {\n      options.push('set ansi_warnings off');\n    }\n\n    if (this.config.options.enableArithAbort === true) {\n      options.push('set arithabort on');\n    } else if (this.config.options.enableArithAbort === false) {\n      options.push('set arithabort off');\n    }\n\n    if (this.config.options.enableConcatNullYieldsNull === true) {\n      options.push('set concat_null_yields_null on');\n    } else if (this.config.options.enableArithAbort === false) {\n      options.push('set concat_null_yields_null off');\n    }\n\n    if (this.config.options.enableCursorCloseOnCommit === true) {\n      options.push('set cursor_close_on_commit on');\n    } else if (this.config.options.enableCursorCloseOnCommit === false) {\n      options.push('set cursor_close_on_commit off');\n    }\n\n    if (this.config.options.datefirst !== null) {\n      options.push(\"set datefirst \".concat(this.config.options.datefirst));\n    }\n\n    if (this.config.options.dateFormat !== null) {\n      options.push(\"set dateformat \".concat(this.config.options.dateFormat));\n    }\n\n    if (this.config.options.enableImplicitTransactions === true) {\n      options.push('set implicit_transactions on');\n    } else if (this.config.options.enableImplicitTransactions === false) {\n      options.push('set implicit_transactions off');\n    }\n\n    if (this.config.options.language !== null) {\n      options.push(\"set language \".concat(this.config.options.language));\n    }\n\n    if (this.config.options.enableNumericRoundabort === true) {\n      options.push('set numeric_roundabort on');\n    } else if (this.config.options.enableNumericRoundabort === false) {\n      options.push('set numeric_roundabort off');\n    }\n\n    if (this.config.options.enableQuotedIdentifier === true) {\n      options.push('set quoted_identifier on');\n    } else if (this.config.options.enableQuotedIdentifier === false) {\n      options.push('set quoted_identifier off');\n    }\n\n    if (this.config.options.textsize !== null) {\n      options.push(\"set textsize \".concat(this.config.options.textsize));\n    }\n\n    if (this.config.options.connectionIsolationLevel !== null) {\n      options.push(\"set transaction isolation level \".concat(this.getIsolationLevelText(this.config.options.connectionIsolationLevel)));\n    }\n\n    if (this.config.options.abortTransactionOnError === true) {\n      options.push('set xact_abort on');\n    } else if (this.config.options.abortTransactionOnError === false) {\n      options.push('set xact_abort off');\n    }\n\n    return options.join('\\n');\n  }\n\n  processedInitialSql() {\n    this.clearConnectTimer();\n    this.emit('connect');\n  }\n\n  processLogin7Response() {\n    if (this.loggedIn) {\n      this.dispatchEvent('loggedIn');\n    } else {\n      if (this.loginError) {\n        this.emit('connect', this.loginError);\n      } else {\n        this.emit('connect', ConnectionError('Login failed.', 'ELOGIN'));\n      }\n\n      this.dispatchEvent('loginFailed');\n    }\n  }\n\n  processLogin7NTLMResponse() {\n    if (this.ntlmpacket) {\n      this.dispatchEvent('receivedChallenge');\n    } else {\n      if (this.loginError) {\n        this.emit('connect', this.loginError);\n      } else {\n        this.emit('connect', ConnectionError('Login failed.', 'ELOGIN'));\n      }\n\n      this.dispatchEvent('loginFailed');\n    }\n  }\n\n  processLogin7NTLMAck() {\n    if (this.loggedIn) {\n      this.dispatchEvent('loggedIn');\n    } else {\n      if (this.loginError) {\n        this.emit('connect', this.loginError);\n      } else {\n        this.emit('connect', ConnectionError('Login failed.', 'ELOGIN'));\n      }\n\n      this.dispatchEvent('loginFailed');\n    }\n  }\n\n  execSqlBatch(request) {\n    this.makeRequest(request, TYPE.SQL_BATCH, new SqlBatchPayload(request.sqlTextOrProcedure, this.currentTransactionDescriptor(), this.config.options));\n  }\n\n  execSql(request) {\n    request.transformIntoExecuteSqlRpc();\n\n    if (request.error != null) {\n      process.nextTick(() => {\n        this.debug.log(request.error.message);\n        request.callback(request.error);\n      });\n      return;\n    }\n\n    this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n  }\n  /**\n   @function newBulkLoad\n   @param {string} table - Table's name.\n   @param {Object} [options] - BulkLoad options.\n   @param {boolean} [options.checkConstraints=false] - Honors constraints during bulk load, it is disabled by default.\n   @param {boolean} [options.fireTriggers=false] - Honors insert triggers during bulk load, it is disabled by default.\n   @param {boolean} [options.keepNulls=false] - Honors null value passed, ignores the default values set on table.\n   @param {boolean} [options.tableLock=false] - Places a bulk update(BU) lock on table while performing bulk load. Uses row locks by default.\n   @param {callback} callback - Function to call after BulkLoad executes.\n  */\n\n\n  newBulkLoad(table, options, callback) {\n    if (callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    if (typeof options !== 'object') {\n      throw new TypeError('\"options\" argument must be an object');\n    }\n\n    return new BulkLoad(table, this.config.options, options, callback);\n  }\n\n  execBulkLoad(bulkLoad) {\n    bulkLoad.executionStarted = true;\n    const request = new Request(bulkLoad.getBulkInsertSql(), error => {\n      if (error) {\n        if (error.code === 'UNKNOWN') {\n          error.message += ' This is likely because the schema of the BulkLoad does not match the schema of the table you are attempting to insert into.';\n        }\n\n        bulkLoad.error = error;\n        bulkLoad.callback(error);\n        return;\n      }\n\n      this.makeRequest(bulkLoad, TYPE.BULK_LOAD, undefined);\n    });\n    this.execSqlBatch(request);\n  }\n\n  prepare(request) {\n    request.transformIntoPrepareRpc();\n    this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n  }\n\n  unprepare(request) {\n    request.transformIntoUnprepareRpc();\n    this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n  }\n\n  execute(request, parameters) {\n    request.transformIntoExecuteRpc(parameters);\n\n    if (request.error != null) {\n      process.nextTick(() => {\n        this.debug.log(request.error.message);\n        request.callback(request.error);\n      });\n      return;\n    }\n\n    this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n  }\n\n  callProcedure(request) {\n    request.validateParameters();\n\n    if (request.error != null) {\n      process.nextTick(() => {\n        this.debug.log(request.error.message);\n        request.callback(request.error);\n      });\n      return;\n    }\n\n    this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n  }\n\n  beginTransaction(callback, name, isolationLevel) {\n    isolationLevel || (isolationLevel = this.config.options.isolationLevel);\n    const transaction = new Transaction(name || '', isolationLevel);\n\n    if (this.config.options.tdsVersion < '7_2') {\n      return this.execSqlBatch(new Request('SET TRANSACTION ISOLATION LEVEL ' + transaction.isolationLevelToTSQL() + ';BEGIN TRAN ' + transaction.name, (...args) => {\n        this.transactionDepth++;\n\n        if (this.transactionDepth === 1) {\n          this.inTransaction = true;\n        }\n\n        callback(...args);\n      }));\n    }\n\n    const request = new Request(undefined, err => {\n      return callback(err, this.currentTransactionDescriptor());\n    });\n    return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.beginPayload(this.currentTransactionDescriptor()));\n  }\n\n  commitTransaction(callback, name) {\n    const transaction = new Transaction(name || '');\n\n    if (this.config.options.tdsVersion < '7_2') {\n      return this.execSqlBatch(new Request('COMMIT TRAN ' + transaction.name, (...args) => {\n        this.transactionDepth--;\n\n        if (this.transactionDepth === 0) {\n          this.inTransaction = false;\n        }\n\n        callback(...args);\n      }));\n    }\n\n    const request = new Request(undefined, callback);\n    return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.commitPayload(this.currentTransactionDescriptor()));\n  }\n\n  rollbackTransaction(callback, name) {\n    const transaction = new Transaction(name || '');\n\n    if (this.config.options.tdsVersion < '7_2') {\n      return this.execSqlBatch(new Request('ROLLBACK TRAN ' + transaction.name, (...args) => {\n        this.transactionDepth--;\n\n        if (this.transactionDepth === 0) {\n          this.inTransaction = false;\n        }\n\n        callback(...args);\n      }));\n    }\n\n    const request = new Request(undefined, callback);\n    return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.rollbackPayload(this.currentTransactionDescriptor()));\n  }\n\n  saveTransaction(callback, name) {\n    const transaction = new Transaction(name);\n\n    if (this.config.options.tdsVersion < '7_2') {\n      return this.execSqlBatch(new Request('SAVE TRAN ' + transaction.name, (...args) => {\n        this.transactionDepth++;\n        callback(...args);\n      }));\n    }\n\n    const request = new Request(undefined, callback);\n    return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.savePayload(this.currentTransactionDescriptor()));\n  }\n\n  transaction(cb, isolationLevel) {\n    if (typeof cb !== 'function') {\n      throw new TypeError('`cb` must be a function');\n    }\n\n    const useSavepoint = this.inTransaction;\n    const name = '_tedious_' + crypto.randomBytes(10).toString('hex');\n\n    const txDone = (err, done, ...args) => {\n      if (err) {\n        if (this.inTransaction && this.state === this.STATE.LOGGED_IN) {\n          return this.rollbackTransaction(txErr => {\n            done(txErr || err, ...args);\n          }, name);\n        } else {\n          return process.nextTick(() => {\n            done(err, ...args);\n          });\n        }\n      } else {\n        if (useSavepoint) {\n          return process.nextTick(() => {\n            if (this.config.options.tdsVersion < '7_2') {\n              this.transactionDepth--;\n            }\n\n            done(null, ...args);\n          });\n        } else {\n          return this.commitTransaction(txErr => {\n            done(txErr, ...args);\n          }, name);\n        }\n      }\n    };\n\n    if (useSavepoint) {\n      return this.saveTransaction(err => {\n        if (err) {\n          return cb(err);\n        }\n\n        if (isolationLevel) {\n          return this.execSqlBatch(new Request('SET transaction isolation level ' + this.getIsolationLevelText(isolationLevel), err => {\n            return cb(err, txDone);\n          }));\n        } else {\n          return cb(null, txDone);\n        }\n      }, name);\n    } else {\n      return this.beginTransaction(err => {\n        if (err) {\n          return cb(err);\n        }\n\n        return cb(null, txDone);\n      }, name, isolationLevel);\n    }\n  }\n\n  makeRequest(request, packetType, payload) {\n    if (this.state !== this.STATE.LOGGED_IN) {\n      const message = 'Requests can only be made in the ' + this.STATE.LOGGED_IN.name + ' state, not the ' + this.state.name + ' state';\n      this.debug.log(message);\n      request.callback(RequestError(message, 'EINVALIDSTATE'));\n    } else {\n      if (packetType === TYPE.SQL_BATCH) {\n        this.isSqlBatch = true;\n      } else {\n        this.isSqlBatch = false;\n      }\n\n      this.request = request;\n      this.request.connection = this;\n      this.request.rowCount = 0;\n      this.request.rows = [];\n      this.request.rst = [];\n\n      if (request instanceof BulkLoad) {\n        const message = request.getMessageStream(); // If the bulkload was not put into streaming mode by the user,\n        // we end the rowToPacketTransform here for them.\n        //\n        // If it was put into streaming mode, it's the user's responsibility\n        // to end the stream.\n\n        if (!request.streamingMode) {\n          request.rowToPacketTransform.end();\n        }\n\n        this.messageIo.outgoingMessageStream.write(message);\n      } else {\n        this.createRequestTimer();\n        this.messageIo.sendMessage(packetType, payload.data, this.resetConnectionOnNextRequest);\n        this.resetConnectionOnNextRequest = false;\n        this.debug.payload(function () {\n          return payload.toString('  ');\n        });\n      }\n\n      this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);\n\n      if (request.paused) {\n        // Request.pause() has been called before the request was started\n        this.pauseRequest(request);\n      }\n    }\n  }\n\n  cancel() {\n    if (this.state !== this.STATE.SENT_CLIENT_REQUEST) {\n      const message = 'Requests can only be canceled in the ' + this.STATE.SENT_CLIENT_REQUEST.name + ' state, not the ' + this.state.name + ' state';\n      this.debug.log(message);\n      return false;\n    } else if (this.request instanceof BulkLoad) {\n      this.debug.log('Canceling a bulk load has not yet been implemented.');\n      return false;\n    } else {\n      this.request.canceled = true;\n      this.messageIo.sendMessage(TYPE.ATTENTION);\n      this.transitionTo(this.STATE.SENT_ATTENTION);\n      return true;\n    }\n  }\n\n  reset(callback) {\n    const request = new Request(this.getInitialSql(), err => {\n      if (this.config.options.tdsVersion < '7_2') {\n        this.inTransaction = false;\n      }\n\n      callback(err);\n    });\n    this.resetConnectionOnNextRequest = true;\n    return this.execSqlBatch(request);\n  }\n\n  currentTransactionDescriptor() {\n    return this.transactionDescriptors[this.transactionDescriptors.length - 1];\n  }\n\n  getIsolationLevelText(isolationLevel) {\n    switch (isolationLevel) {\n      case ISOLATION_LEVEL.READ_UNCOMMITTED:\n        return 'read uncommitted';\n\n      case ISOLATION_LEVEL.REPEATABLE_READ:\n        return 'repeatable read';\n\n      case ISOLATION_LEVEL.SERIALIZABLE:\n        return 'serializable';\n\n      case ISOLATION_LEVEL.SNAPSHOT:\n        return 'snapshot';\n\n      default:\n        return 'read committed';\n    }\n  }\n\n}\n\nmodule.exports = Connection;\nConnection.prototype.STATE = {\n  CONNECTING: {\n    name: 'Connecting',\n    enter: function enter() {\n      this.initialiseConnection();\n    },\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      socketConnect: function socketConnect() {\n        this.sendPreLogin();\n        this.transitionTo(this.STATE.SENT_PRELOGIN);\n      }\n    }\n  },\n  SENT_PRELOGIN: {\n    name: 'SentPrelogin',\n    enter: function enter() {\n      this.emptyMessageBuffer();\n    },\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data) {\n        this.addToMessageBuffer(_data);\n      },\n      message: function message() {\n        this.processPreLoginResponse();\n      },\n      noTls: function noTls() {\n        this.sendLogin7Packet(() => {\n          const authentication = this.config.authentication;\n\n          if (authentication.type === 'ntlm') {\n            this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);\n          } else {\n            this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);\n          }\n        });\n      },\n      tls: function tls() {\n        this.messageIo.startTls(this.secureContext, this.config.server, this.config.options.trustServerCertificate);\n        this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);\n      }\n    }\n  },\n  REROUTING: {\n    name: 'ReRouting',\n    enter: function enter() {\n      this.cleanupConnection(this.cleanupTypeEnum.REDIRECT);\n    },\n    events: {\n      message: function message() {},\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      reconnect: function reconnect() {\n        this.transitionTo(this.STATE.CONNECTING);\n      }\n    }\n  },\n  TRANSIENT_FAILURE_RETRY: {\n    name: 'TRANSIENT_FAILURE_RETRY',\n    enter: function enter() {\n      this.curTransientRetryCount++;\n      this.cleanupConnection(this.cleanupTypeEnum.RETRY);\n    },\n    events: {\n      message: function message() {},\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      retry: function retry() {\n        this.createRetryTimer();\n      }\n    }\n  },\n  SENT_TLSSSLNEGOTIATION: {\n    name: 'SentTLSSSLNegotiation',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data2) {\n        this.messageIo.tlsHandshakeData(_data2);\n      },\n      message: function message() {\n        if (this.messageIo.tlsNegotiationComplete) {\n          this.sendLogin7Packet(() => {\n            const authentication = this.config.authentication;\n\n            if (authentication.type === 'azure-active-directory-password') {\n              this.transitionTo(this.STATE.SENT_LOGIN7_WITH_FEDAUTH);\n            } else if (authentication.type === 'ntlm') {\n              this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);\n            } else {\n              this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);\n            }\n          });\n        }\n      }\n    }\n  },\n  SENT_LOGIN7_WITH_STANDARD_LOGIN: {\n    name: 'SentLogin7WithStandardLogin',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data3) {\n        this.sendDataToTokenStreamParser(_data3);\n      },\n      loggedIn: function loggedIn() {\n        this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);\n      },\n      routingChange: function routingChange() {\n        this.transitionTo(this.STATE.REROUTING);\n      },\n      loginFailed: function loginFailed() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      featureExtAck: function featureExtAck(token) {\n        const authentication = this.config.authentication;\n\n        if (authentication.type === 'azure-active-directory-password') {\n          if (token.fedAuth === undefined) {\n            this.loginError = ConnectionError('Did not receive Active Directory authentication acknowledgement');\n            this.loggedIn = false;\n          } else if (token.fedAuth.length !== 0) {\n            this.loginError = ConnectionError(\"Active Directory authentication acknowledgment for \".concat(authentication.type, \" authentication method includes extra data\"));\n            this.loggedIn = false;\n          }\n        } else {\n          if (token.fedAuth === undefined) {\n            this.loginError = ConnectionError('Received acknowledgement for unknown feature');\n            this.loggedIn = false;\n          } else {\n            this.loginError = ConnectionError('Did not request Active Directory authentication, but received the acknowledgment');\n            this.loggedIn = false;\n          }\n        }\n      },\n      message: function message() {\n        this.processLogin7Response();\n      }\n    }\n  },\n  SENT_LOGIN7_WITH_NTLM: {\n    name: 'SentLogin7WithNTLMLogin',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data4) {\n        this.sendDataToTokenStreamParser(_data4);\n      },\n      receivedChallenge: function receivedChallenge() {\n        this.sendNTLMResponsePacket();\n      },\n      loginFailed: function loginFailed() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      message: function message() {\n        this.processLogin7NTLMResponse();\n      }\n    }\n  },\n  SENT_NTLM_RESPONSE: {\n    name: 'SentNTLMResponse',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data5) {\n        this.sendDataToTokenStreamParser(_data5);\n      },\n      loggedIn: function loggedIn() {\n        this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);\n      },\n      loginFailed: function loginFailed() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      routingChange: function routingChange() {\n        this.transitionTo(this.STATE.REROUTING);\n      },\n      message: function message() {\n        this.processLogin7NTLMAck();\n      }\n    }\n  },\n  SENT_LOGIN7_WITH_FEDAUTH: {\n    name: 'SentLogin7Withfedauth',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data6) {\n        this.sendDataToTokenStreamParser(_data6);\n      },\n      loginFailed: function loginFailed() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      routingChange: function routingChange() {\n        this.transitionTo(this.STATE.REROUTING);\n      },\n      fedAuthInfo: function fedAuthInfo(token) {\n        this.fedAuthInfoToken = token;\n      },\n      message: function message() {\n        if (this.fedAuthInfoToken && this.fedAuthInfoToken.stsurl && this.fedAuthInfoToken.spn) {\n          const clientId = '7f98cb04-cd1e-40df-9140-3bf7e2cea4db';\n          const context = new AuthenticationContext(this.fedAuthInfoToken.stsurl);\n          const authentication = this.config.authentication;\n          context.acquireTokenWithUsernamePassword(this.fedAuthInfoToken.spn, authentication.options.userName, authentication.options.password, clientId, (err, tokenResponse) => {\n            if (err) {\n              this.loginError = ConnectionError('Security token could not be authenticated or authorized.', 'EFEDAUTH');\n              this.emit('connect', this.loginError);\n              this.dispatchEvent('loginFailed');\n              return;\n            }\n\n            this.sendFedAuthResponsePacket(tokenResponse);\n          });\n        } else {\n          if (this.loginError) {\n            this.emit('connect', this.loginError);\n          } else {\n            this.emit('connect', ConnectionError('Login failed.', 'ELOGIN'));\n          }\n\n          this.dispatchEvent('loginFailed');\n        }\n      }\n    }\n  },\n  LOGGED_IN_SENDING_INITIAL_SQL: {\n    name: 'LoggedInSendingInitialSql',\n    enter: function enter() {\n      this.sendInitialSql();\n    },\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data7) {\n        this.sendDataToTokenStreamParser(_data7);\n      },\n      message: function message() {\n        this.transitionTo(this.STATE.LOGGED_IN);\n        this.processedInitialSql();\n      }\n    }\n  },\n  LOGGED_IN: {\n    name: 'LoggedIn',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      }\n    }\n  },\n  SENT_CLIENT_REQUEST: {\n    name: 'SentClientRequest',\n    exit: function exit(nextState) {\n      this.clearRequestTimer();\n\n      if (nextState !== this.STATE.FINAL) {\n        this.tokenStreamParser.resume();\n      }\n    },\n    events: {\n      socketError: function socketError(err) {\n        const sqlRequest = this.request;\n        this.request = undefined;\n        sqlRequest.callback(err);\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data8) {\n        this.clearRequestTimer(); // request timer is stopped on first data package\n\n        const ret = this.sendDataToTokenStreamParser(_data8);\n\n        if (ret === false) {\n          // Bridge backpressure from the token stream parser transform to the\n          // packet stream transform.\n          this.messageIo.pause();\n        }\n      },\n      message: function message() {\n        // We have to channel the 'message' (EOM) event through the token stream\n        // parser transform, to keep it in line with the flow of the tokens, when\n        // the incoming data flow is paused and resumed.\n        this.tokenStreamParser.addEndOfMessageMarker();\n      },\n      endOfMessageMarkerReceived: function endOfMessageMarkerReceived() {\n        this.transitionTo(this.STATE.LOGGED_IN);\n        const sqlRequest = this.request;\n        this.request = undefined;\n\n        if (this.config.options.tdsVersion < '7_2' && sqlRequest.error && this.isSqlBatch) {\n          this.inTransaction = false;\n        }\n\n        sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);\n      }\n    }\n  },\n  SENT_ATTENTION: {\n    name: 'SentAttention',\n    enter: function enter() {\n      this.attentionReceived = false;\n    },\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data9) {\n        this.sendDataToTokenStreamParser(_data9);\n      },\n      attention: function attention() {\n        this.attentionReceived = true;\n      },\n      message: function message() {\n        // 3.2.5.7 Sent Attention State\n        // Discard any data contained in the response, until we receive the attention response\n        if (this.attentionReceived) {\n          const sqlRequest = this.request;\n          this.request = undefined;\n          this.transitionTo(this.STATE.LOGGED_IN);\n\n          if (sqlRequest.canceled) {\n            sqlRequest.callback(RequestError('Canceled.', 'ECANCEL'));\n          } else {\n            const timeout = sqlRequest.timeout !== undefined ? sqlRequest.timeout : this.config.options.requestTimeout;\n            const message = 'Timeout: Request failed to complete in ' + timeout + 'ms';\n            sqlRequest.callback(RequestError(message, 'ETIMEOUT'));\n          }\n        }\n      }\n    }\n  },\n  FINAL: {\n    name: 'Final',\n    enter: function enter() {\n      this.cleanupConnection(this.cleanupTypeEnum.NORMAL);\n    },\n    events: {\n      loginFailed: function loginFailed() {// Do nothing. The connection was probably closed by the client code.\n      },\n      connectTimeout: function connectTimeout() {// Do nothing, as the timer should be cleaned up.\n      },\n      message: function message() {// Do nothing\n      },\n      socketError: function socketError() {// Do nothing\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}