{"ast":null,"code":"\"use strict\";\n\nconst net = require('net');\n\nconst dns = require('dns');\n\nconst punycode = require('punycode');\n\nclass Connector {\n  constructor(options, multiSubnetFailover) {\n    this.options = options;\n    this.multiSubnetFailover = multiSubnetFailover;\n  }\n\n  execute(cb) {\n    if (net.isIP(this.options.host)) {\n      this.executeForIP(cb);\n    } else {\n      this.executeForHostname(cb);\n    }\n  }\n\n  executeForIP(cb) {\n    const socket = net.connect(this.options);\n\n    const onError = err => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      socket.destroy();\n      cb(err);\n    };\n\n    const onConnect = () => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      cb(null, socket);\n    };\n\n    socket.on('error', onError);\n    socket.on('connect', onConnect);\n  }\n\n  executeForHostname(cb) {\n    dns.lookup(punycode.toASCII(this.options.host), {\n      all: true\n    }, (err, addresses) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (this.multiSubnetFailover) {\n        new ParallelConnectionStrategy(addresses, this.options).connect(cb);\n      } else {\n        new SequentialConnectionStrategy(addresses, this.options).connect(cb);\n      }\n    });\n  }\n\n}\n\nclass ParallelConnectionStrategy {\n  constructor(addresses, options) {\n    this.addresses = addresses;\n    this.options = options;\n  }\n\n  connect(callback) {\n    const addresses = this.addresses;\n    const sockets = new Array(addresses.length);\n    let errorCount = 0;\n\n    const onError = function onError(err) {\n      errorCount += 1;\n      this.removeListener('error', onError);\n      this.removeListener('connect', onConnect);\n\n      if (errorCount === addresses.length) {\n        callback(new Error('Could not connect (parallel)'));\n      }\n    };\n\n    const onConnect = function onConnect() {\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n\n        if (this === socket) {\n          continue;\n        }\n\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n\n      callback(null, this);\n    };\n\n    for (let i = 0, len = addresses.length; i < len; i++) {\n      const socket = sockets[i] = net.connect(Object.create(this.options, {\n        host: {\n          value: addresses[i].address\n        }\n      }));\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n  }\n\n}\n\nclass SequentialConnectionStrategy {\n  constructor(addresses, options) {\n    this.addresses = addresses;\n    this.options = options;\n  }\n\n  connect(callback) {\n    const addresses = this.addresses;\n\n    if (!addresses.length) {\n      callback(new Error('Could not connect (sequence)'));\n      return;\n    }\n\n    const next = addresses.shift();\n    const socket = net.connect(Object.create(this.options, {\n      host: {\n        value: next.address\n      }\n    }));\n\n    const onError = err => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      socket.destroy();\n      this.connect(callback);\n    };\n\n    const onConnect = () => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      callback(null, socket);\n    };\n\n    socket.on('error', onError);\n    socket.on('connect', onConnect);\n  }\n\n}\n\nmodule.exports.Connector = Connector;\nmodule.exports.ParallelConnectionStrategy = ParallelConnectionStrategy;\nmodule.exports.SequentialConnectionStrategy = SequentialConnectionStrategy;","map":null,"metadata":{},"sourceType":"script"}