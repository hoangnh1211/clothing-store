{"ast":null,"code":"'use strict';\n\nconst url = require('url');\n\nconst qs = require('querystring');\n\nconst IGNORE_KEYS = ['stream'];\n\nconst oror = function () {\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    if (arguments[i] !== null && arguments[i] !== undefined) {\n      return arguments[i];\n    }\n  }\n};\n\nconst parseConnectionURI = function (uri) {\n  const parsed = url.parse(uri);\n  let instance;\n  let user;\n  let password;\n  const path = parsed.pathname.substr(1).split('/');\n\n  if (path.length > 1) {\n    instance = path.shift();\n  }\n\n  if (parsed.auth) {\n    parsed.auth = parsed.auth.split(':');\n    user = parsed.auth.shift();\n    password = parsed.auth.join(':');\n  }\n\n  const port = parsed.port ? \",\".concat(parsed.port) : instance ? \"\\\\\".concat(instance) : '';\n  const object = {\n    server: \"\".concat(parsed.hostname).concat(port),\n    uid: user || '',\n    pwd: password || '',\n    database: path[0]\n  };\n\n  if (parsed.query) {\n    const query = qs.parse(parsed.query);\n\n    for (const key in query) {\n      if (Object.prototype.hasOwnProperty.call(query, key)) {\n        const value = query[key];\n\n        if (key === 'domain') {\n          object.uid = \"\".concat(value, \"\\\\\").concat(object.uid);\n        } else {\n          object[key] = value;\n        }\n      }\n    }\n  }\n\n  Object.defineProperty(object, 'toString', {\n    value() {\n      const out = [];\n\n      for (const key in this) {\n        if (IGNORE_KEYS.indexOf(key) === -1) {\n          out.push(\"\".concat(key, \"={\").concat(this[key], \"}\"));\n        }\n      }\n\n      return out.join(';');\n    }\n\n  });\n  return object;\n};\n\nconst parseConnectionString = function (string) {\n  let cursor = 0;\n  let parsing = 'name';\n  let param = null;\n  let buffer = '';\n  let quotes = null;\n  const parsed = {};\n  const original = {};\n  Object.defineProperty(parsed, '__original__', {\n    value: original\n  });\n  Object.defineProperty(parsed, 'toString', {\n    value() {\n      const out = [];\n\n      for (const key in this) {\n        if (IGNORE_KEYS.indexOf(key) === -1) {\n          const esc = original[key].escape || ['', ''];\n          out.push(\"\".concat(original[key].name, \"=\").concat(esc[0] || '').concat(this[key]).concat(esc[1] || ''));\n        }\n      }\n\n      return out.join(';');\n    }\n\n  });\n\n  while (cursor < string.length) {\n    const char = string.charAt(cursor);\n\n    switch (char) {\n      case '=':\n        if (parsing === 'name') {\n          buffer = buffer.trim();\n          param = buffer.toLowerCase();\n          original[param] = {\n            name: buffer\n          };\n          parsing = 'value';\n          buffer = '';\n        } else {\n          buffer += char;\n        }\n\n        break;\n\n      case '\\'':\n      case '\"':\n        if (parsing === 'value') {\n          if (!buffer.trim().length) {\n            // value is wrapped in qotes\n            original[param].escape = [char, char];\n            quotes = char;\n            buffer = '';\n          } else if (quotes) {\n            if (char === quotes) {\n              // found same char as used for wrapping quotes\n              if (char === string.charAt(cursor + 1)) {\n                // escaped quote\n                buffer += char;\n                cursor++;\n              } else {\n                // end of value\n                parsed[param] = buffer;\n                param = null;\n                parsing = null;\n                buffer = '';\n                quotes = null;\n              }\n            } else {\n              buffer += char;\n            }\n          } else {\n            buffer += char;\n          }\n        } else {\n          throw new Error('Invalid connection string.');\n        }\n\n        break;\n\n      case '{':\n        if (parsing === 'value') {\n          if (buffer.trim().length === 0) {\n            // value is wrapped in qotes\n            original[param].escape = ['{', '}'];\n            quotes = '{}';\n            buffer = '';\n          } else {\n            buffer += char;\n          }\n        } else {\n          throw new Error('Invalid connection string.');\n        }\n\n        break;\n\n      case '}':\n        if (parsing === 'value') {\n          if (quotes === '{}') {\n            // end of value\n            parsed[param] = buffer;\n            param = null;\n            parsing = null;\n            buffer = '';\n            quotes = null;\n          } else {\n            buffer += char;\n          }\n        } else {\n          throw new Error('Invalid connection string.');\n        }\n\n        break;\n\n      case ';':\n        if (parsing === 'value') {\n          if (quotes) {\n            buffer += char;\n          } else {\n            // end of value\n            parsed[param] = buffer;\n            param = null;\n            parsing = 'name';\n            buffer = '';\n          }\n        } else {\n          buffer = '';\n          parsing = 'name';\n        }\n\n        break;\n\n      default:\n        buffer += char;\n    }\n\n    cursor++;\n  }\n\n  if (parsing === 'value') {\n    // end of value\n    parsed[param] = buffer;\n  }\n\n  return parsed;\n};\n\nconst resolveConnectionString = function (string, driver) {\n  const parsed = /^(mssql|tedious|msnodesql|tds):\\/\\//i.test(string) ? parseConnectionURI(string) : parseConnectionString(string);\n  const stream = (parsed.stream || '').toLowerCase();\n  const encrypt = (parsed.encrypt || '').toLowerCase();\n\n  if (driver === 'msnodesqlv8') {\n    parsed.driver = 'SQL Server Native Client 11.0';\n\n    if (parsed.__original__) {\n      parsed.__original__.driver = {\n        name: 'Driver',\n        escape: ['{', '}']\n      };\n    }\n\n    return {\n      connectionString: parsed.toString()\n    };\n  }\n\n  let user = parsed.uid || parsed.uid || parsed['user id'];\n  let server = parsed.server || parsed.address || parsed.addr || parsed['data source'] || parsed['network address'];\n  const config = {\n    password: oror(parsed.pwd, parsed.password),\n    database: oror(parsed.database, parsed['initial catalog']),\n    connectionTimeout: oror(parsed.connectionTimeout, parsed.timeout, parsed['connect timeout'], parsed['connection timeout']),\n    requestTimeout: oror(parsed.requestTimeout, parsed['request timeout']),\n    stream: stream === 'true' || stream === 'yes' || stream === '1',\n    options: {\n      readOnlyIntent: parsed.applicationintent && parsed.applicationintent.toLowerCase() === 'readonly',\n      encrypt: encrypt === 'true' || encrypt === 'yes' || encrypt === '1'\n    }\n  };\n\n  if (parsed.useUTC != null) {\n    const utc = parsed.useUTC.toLowerCase();\n    config.options.useUTC = utc === 'true' || utc === 'yes' || utc === '1';\n  }\n\n  if (config.connectionTimeout != null) {\n    config.connectionTimeout = parseInt(config.connectionTimeout, 10) * 1000;\n  }\n\n  if (config.requestTimeout != null) {\n    config.requestTimeout = parseInt(config.requestTimeout, 10);\n  }\n\n  if (parsed.multisubnetfailover != null) {\n    config.options.multiSubnetFailover = parsed.multisubnetfailover.toLowerCase() === 'true';\n  }\n\n  if (/^(.*)\\\\(.*)$/.exec(user)) {\n    config.domain = RegExp.$1;\n    user = RegExp.$2;\n  }\n\n  if (server) {\n    server = server.trim();\n\n    if (/^np:/i.test(server)) {\n      throw new Error('Connection via Named Pipes is not supported.');\n    }\n\n    if (/^tcp:/i.test(server)) {\n      server = server.substr(4);\n    }\n\n    if (/^(.*)\\\\(.*)$/.exec(server)) {\n      server = RegExp.$1;\n      config.options.instanceName = RegExp.$2;\n    }\n\n    if (/^(.*),(.*)$/.exec(server)) {\n      server = RegExp.$1.trim();\n      config.port = parseInt(RegExp.$2.trim(), 10);\n    }\n\n    if (server === '.' || server === '(.)' || server.toLowerCase() === '(localdb)' || server.toLowerCase() === '(local)') {\n      server = 'localhost';\n    }\n  }\n\n  config.user = user;\n  config.server = server;\n  return config;\n};\n\nmodule.exports = {\n  parse: parseConnectionString,\n  resolve: resolveConnectionString\n};","map":null,"metadata":{},"sourceType":"script"}