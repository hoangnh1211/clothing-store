{"ast":null,"code":"\"use strict\";\n\nconst codepageBySortId = require('./collation').codepageBySortId;\n\nconst codepageByLcid = require('./collation').codepageByLcid;\n\nconst TYPE = require('./data-type').TYPE;\n\nconst sprintf = require('sprintf-js').sprintf;\n\nmodule.exports = metadataParse;\nmodule.exports.readPrecision = readPrecision;\nmodule.exports.readScale = readScale;\nmodule.exports.readCollation = readCollation;\n\nfunction readDataLength(parser, type, callback) {\n  if ((type.id & 0x30) === 0x20) {\n    // xx10xxxx - s2.2.4.2.1.3\n    // Variable length\n    if (type.dataLengthFromScale) {\n      return callback(0); // dataLength is resolved from scale\n    } else if (type.fixedDataLength) {\n      return callback(type.fixedDataLength);\n    }\n\n    switch (type.dataLengthLength) {\n      case 0:\n        return callback(undefined);\n\n      case 1:\n        return parser.readUInt8(callback);\n\n      case 2:\n        return parser.readUInt16LE(callback);\n\n      case 4:\n        return parser.readUInt32LE(callback);\n\n      default:\n        return parser.emit(new Error('Unsupported dataLengthLength ' + type.dataLengthLength + ' for data type ' + type.name));\n    }\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readPrecision(parser, type, callback) {\n  if (type.hasPrecision) {\n    parser.readUInt8(callback);\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readScale(parser, type, callback) {\n  if (type.hasScale) {\n    parser.readUInt8(callback);\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readCollation(parser, type, callback) {\n  if (type.hasCollation) {\n    // s2.2.5.1.2\n    parser.readBuffer(5, collationData => {\n      const collation = {};\n      collation.lcid = (collationData[2] & 0x0F) << 16;\n      collation.lcid |= collationData[1] << 8;\n      collation.lcid |= collationData[0]; // This may not be extracting the correct nibbles in the correct order.\n\n      collation.flags = collationData[3] >> 4;\n      collation.flags |= collationData[2] & 0xF0; // This may not be extracting the correct nibble.\n\n      collation.version = collationData[3] & 0x0F;\n      collation.sortId = collationData[4];\n      collation.codepage = codepageBySortId[collation.sortId] || codepageByLcid[collation.lcid] || 'CP1252';\n      callback(collation);\n    });\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readSchema(parser, type, callback) {\n  if (type.hasSchemaPresent) {\n    // s2.2.5.5.3\n    parser.readUInt8(schemaPresent => {\n      if (schemaPresent === 0x01) {\n        parser.readBVarChar(dbname => {\n          parser.readBVarChar(owningSchema => {\n            parser.readUsVarChar(xmlSchemaCollection => {\n              callback({\n                dbname: dbname,\n                owningSchema: owningSchema,\n                xmlSchemaCollection: xmlSchemaCollection\n              });\n            });\n          });\n        });\n      } else {\n        callback(undefined);\n      }\n    });\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readUDTInfo(parser, type, callback) {\n  if (type.hasUDTInfo) {\n    parser.readUInt16LE(maxByteSize => {\n      parser.readBVarChar(dbname => {\n        parser.readBVarChar(owningSchema => {\n          parser.readBVarChar(typeName => {\n            parser.readUsVarChar(assemblyName => {\n              callback({\n                maxByteSize: maxByteSize,\n                dbname: dbname,\n                owningSchema: owningSchema,\n                typeName: typeName,\n                assemblyName: assemblyName\n              });\n            });\n          });\n        });\n      });\n    });\n  } else {\n    return callback();\n  }\n}\n\nfunction metadataParse(parser, options, callback) {\n  (options.tdsVersion < '7_2' ? parser.readUInt16LE : parser.readUInt32LE).call(parser, userType => {\n    parser.readUInt16LE(flags => {\n      parser.readUInt8(typeNumber => {\n        const type = TYPE[typeNumber];\n\n        if (!type) {\n          return parser.emit(new Error(sprintf('Unrecognised data type 0x%02X', typeNumber)));\n        }\n\n        readDataLength(parser, type, dataLength => {\n          readPrecision(parser, type, precision => {\n            readScale(parser, type, scale => {\n              if (scale && type.dataLengthFromScale) {\n                dataLength = type.dataLengthFromScale(scale);\n              }\n\n              readCollation(parser, type, collation => {\n                readSchema(parser, type, schema => {\n                  readUDTInfo(parser, type, udtInfo => {\n                    callback({\n                      userType: userType,\n                      flags: flags,\n                      type: type,\n                      collation: collation,\n                      precision: precision,\n                      scale: scale,\n                      dataLength: dataLength,\n                      schema: schema,\n                      udtInfo: udtInfo\n                    });\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"script"}