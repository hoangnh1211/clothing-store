{"ast":null,"code":"\"use strict\";\n\nconst BufferList = require('bl');\n\nconst _require = require('readable-stream'),\n      Transform = _require.Transform;\n\nconst Message = require('./message');\n\nconst _require2 = require('./packet'),\n      Packet = _require2.Packet,\n      HEADER_LENGTH = _require2.HEADER_LENGTH;\n/**\n  IncomingMessageStream\n  Transform received TDS data into individual IncomingMessage streams.\n*/\n\n\nclass IncomingMessageStream extends Transform {\n  constructor(debug) {\n    super({\n      readableObjectMode: true\n    });\n    this.debug = debug;\n    this.currentMessage = undefined;\n    this.bl = new BufferList();\n  }\n\n  processBufferedData(callback) {\n    // The packet header is always 8 bytes of length.\n    while (this.bl.length >= HEADER_LENGTH) {\n      // Get the full packet length\n      const length = this.bl.readUInt16BE(2);\n\n      if (this.bl.length >= length) {\n        const data = this.bl.slice(0, length);\n        this.bl.consume(length); // TODO: Get rid of creating `Packet` instances here.\n\n        const packet = new Packet(data);\n        this.debug.packet('Received', packet);\n        this.debug.data(packet);\n        let message = this.currentMessage;\n\n        if (message === undefined) {\n          message = new Message({\n            type: packet.type(),\n            resetConnection: false\n          });\n          this.push(message);\n        }\n\n        if (packet.isLast()) {\n          this.currentMessage = undefined; // Wait until the current message was fully processed before we\n          // continue processing any remaining messages.\n\n          message.once('end', () => {\n            this.processBufferedData(callback);\n          });\n          message.end(packet.data());\n          return;\n        } else {\n          this.currentMessage = message; // If too much data is buffering up in the\n          // current message, wait for it to drain.\n\n          if (!message.write(packet.data())) {\n            message.once('drain', () => {\n              this.processBufferedData(callback);\n            });\n            return;\n          }\n        }\n      } else {\n        break;\n      }\n    } // Not enough data to read the next packet. Stop here and wait for\n    // the next call to `_transform`.\n\n\n    callback();\n  }\n\n  _transform(chunk, encoding, callback) {\n    this.bl.append(chunk);\n    this.processBufferedData(callback);\n  }\n\n}\n\nmodule.exports = IncomingMessageStream;","map":null,"metadata":{},"sourceType":"script"}