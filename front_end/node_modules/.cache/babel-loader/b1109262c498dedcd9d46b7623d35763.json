{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\n\nconst _require = require('../../utils/logger'),\n      logger = _require.logger;\n\nconst debug = logger.debugContext('connection:pg');\n\nconst Promise = require('../../promise');\n\nconst sequelizeErrors = require('../../errors');\n\nconst semver = require('semver');\n\nconst dataTypes = require('../../data-types');\n\nconst moment = require('moment-timezone');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 5432;\n    super(dialect, sequelize);\n\n    const pgLib = this._loadDialectModule('pg');\n\n    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;\n\n    this._clearDynamicOIDs();\n\n    this._clearTypeParser();\n\n    this.refreshTypeParser(dataTypes.postgres);\n  } // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n\n\n  _refreshTypeParser(dataType) {\n    const arrayParserBuilder = parser => {\n      return value => this.lib.types.arrayParser.create(value, parser).parse();\n    };\n\n    const rangeParserBuilder = parser => {\n      return value => dataType.parse(value, {\n        parser\n      });\n    }; // Set range parsers\n\n\n    if (dataType.key.toLowerCase() === 'range') {\n      for (const name in this.nameOidMap) {\n        const entry = this.nameOidMap[name];\n        if (!entry.rangeOid) continue;\n        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));\n        const arrayRangeParser = arrayParserBuilder(rangeParser);\n        this.oidParserMap.set(entry.rangeOid, rangeParser);\n        if (!entry.arrayRangeOid) continue;\n        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);\n      }\n\n      return;\n    } // Create parsers for normal or enum data types\n\n\n    const parser = value => dataType.parse(value);\n\n    const arrayParser = arrayParserBuilder(parser); // Set enum parsers\n\n    if (dataType.key.toLowerCase() === 'enum') {\n      this.enumOids.oids.forEach(oid => {\n        this.oidParserMap.set(oid, parser);\n      });\n      this.enumOids.arrayOids.forEach(arrayOid => {\n        this.oidParserMap.set(arrayOid, arrayParser);\n      });\n      return;\n    } // Set parsers for normal data types\n\n\n    dataType.types.postgres.forEach(name => {\n      if (!this.nameOidMap[name]) return;\n      this.oidParserMap.set(this.nameOidMap[name].oid, parser);\n      if (!this.nameOidMap[name].arrayOid) return;\n      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);\n    });\n  }\n\n  _clearTypeParser() {\n    this.oidParserMap = new Map();\n  }\n\n  getTypeParser(oid, ...args) {\n    if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);\n    return this.lib.types.getTypeParser(oid, ...args);\n  }\n\n  connect(config) {\n    config.user = config.username;\n\n    const connectionConfig = _.pick(config, ['user', 'password', 'host', 'database', 'port']);\n\n    connectionConfig.types = {\n      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)\n    };\n\n    if (config.dialectOptions) {\n      _.merge(connectionConfig, _.pick(config.dialectOptions, [// see [http://www.postgresql.org/docs/9.3/static/runtime-config-logging.html#GUC-APPLICATION-NAME]\n      'application_name', // choose the SSL mode with the PGSSLMODE environment variable\n      // object format: [https://github.com/brianc/node-postgres/blob/master/lib/connection.js#L79]\n      // see also [http://www.postgresql.org/docs/9.3/static/libpq-ssl.html]\n      'ssl', // In addition to the values accepted by the corresponding server,\n      // you can use \"auto\" to determine the right encoding from the\n      // current locale in the client (LC_CTYPE environment variable on Unix systems)\n      'client_encoding', // !! DO NOT SET THIS TO TRUE !!\n      // (unless you know what you're doing)\n      // see [http://www.postgresql.org/message-id/flat/bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com#bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com]\n      'binary', // This should help with backends incorrectly considering idle clients to be dead and prematurely disconnecting them.\n      // this feature has been added in pg module v6.0.0, check pg/CHANGELOG.md\n      'keepAlive', // Times out queries after a set time in milliseconds. Added in pg v7.3\n      'statement_timeout']));\n    }\n\n    return new Promise((resolve, reject) => {\n      let responded = false;\n      const connection = new this.lib.Client(connectionConfig);\n\n      const parameterHandler = message => {\n        switch (message.parameterName) {\n          case 'server_version':\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = semver.coerce(message.parameterValue).version;\n              this.sequelize.options.databaseVersion = semver.valid(version) ? version : this.defaultVersion;\n            }\n\n            break;\n\n          case 'standard_conforming_strings':\n            connection['standard_conforming_strings'] = message.parameterValue;\n            break;\n        }\n      };\n\n      const endHandler = () => {\n        debug('connection timeout');\n\n        if (!responded) {\n          reject(new sequelizeErrors.ConnectionTimedOutError(new Error('Connection timed out')));\n        }\n      }; // If we didn't ever hear from the client.connect() callback the connection timeout\n      // node-postgres does not treat this as an error since no active query was ever emitted\n\n\n      connection.once('end', endHandler);\n\n      if (!this.sequelize.config.native) {\n        // Receive various server parameters for further configuration\n        connection.connection.on('parameterStatus', parameterHandler);\n      }\n\n      connection.connect(err => {\n        responded = true;\n\n        if (!this.sequelize.config.native) {\n          // remove parameter handler\n          connection.connection.removeListener('parameterStatus', parameterHandler);\n        }\n\n        if (err) {\n          if (err.code) {\n            switch (err.code) {\n              case 'ECONNREFUSED':\n                reject(new sequelizeErrors.ConnectionRefusedError(err));\n                break;\n\n              case 'ENOTFOUND':\n                reject(new sequelizeErrors.HostNotFoundError(err));\n                break;\n\n              case 'EHOSTUNREACH':\n                reject(new sequelizeErrors.HostNotReachableError(err));\n                break;\n\n              case 'EINVAL':\n                reject(new sequelizeErrors.InvalidConnectionError(err));\n                break;\n\n              default:\n                reject(new sequelizeErrors.ConnectionError(err));\n                break;\n            }\n          } else {\n            reject(new sequelizeErrors.ConnectionError(err));\n          }\n        } else {\n          debug('connection acquired');\n          connection.removeListener('end', endHandler);\n          resolve(connection);\n        }\n      });\n    }).tap(connection => {\n      let query = '';\n\n      if (this.sequelize.options.standardConformingStrings !== false && connection['standard_conforming_strings'] !== 'on') {\n        // Disable escape characters in strings\n        // see https://github.com/sequelize/sequelize/issues/3545 (security issue)\n        // see https://www.postgresql.org/docs/current/static/runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS\n        query += 'SET standard_conforming_strings=on;';\n      }\n\n      if (this.sequelize.options.clientMinMessages !== false) {\n        query += \"SET client_min_messages TO \".concat(this.sequelize.options.clientMinMessages, \";\");\n      }\n\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        const isZone = !!moment.tz.zone(this.sequelize.options.timezone);\n\n        if (isZone) {\n          query += \"SET TIME ZONE '\".concat(this.sequelize.options.timezone, \"';\");\n        } else {\n          query += \"SET TIME ZONE INTERVAL '\".concat(this.sequelize.options.timezone, \"' HOUR TO MINUTE;\");\n        }\n      }\n\n      if (query) {\n        return connection.query(query);\n      }\n    }).tap(connection => {\n      if (Object.keys(this.nameOidMap).length === 0 && this.enumOids.oids.length === 0 && this.enumOids.arrayOids.length === 0) {\n        return this._refreshDynamicOIDs(connection);\n      }\n    }).tap(connection => {\n      // Don't let a Postgres restart (or error) to take down the whole app\n      connection.on('error', error => {\n        connection._invalid = true;\n        debug(\"connection error \".concat(error.code || error.message));\n        this.pool.destroy(connection);\n      });\n    });\n  }\n\n  disconnect(connection) {\n    if (connection._ending) {\n      debug('connection tried to disconnect but was already at ENDING state');\n      return Promise.resolve();\n    }\n\n    return Promise.fromCallback(callback => connection.end(callback));\n  }\n\n  validate(connection) {\n    return !connection._invalid && !connection._ending;\n  }\n\n  _refreshDynamicOIDs(connection) {\n    const databaseVersion = this.sequelize.options.databaseVersion;\n    const supportedVersion = '8.3.0'; // Check for supported version\n\n    if ((databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {\n      return Promise.resolve();\n    } // Refresh dynamic OIDs for some types\n    // These include Geometry / Geography / HStore / Enum / Citext / Range\n\n\n    return (connection || this.sequelize).query('WITH ranges AS (' + '  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,' + '         pg_type.typarray AS rngtyparray, pg_range.rngsubtype' + '    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid' + ')' + 'SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,' + '       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray' + '  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype' + ' WHERE (pg_type.typtype IN(\\'b\\', \\'e\\'));').then(results => {\n      let result = Array.isArray(results) ? results.pop() : results; // When searchPath is prepended then two statements are executed and the result is\n      // an array of those two statements. First one is the SET search_path and second is\n      // the SELECT query result.\n\n      if (Array.isArray(result)) {\n        if (result[0].command === 'SET') {\n          result = result.pop();\n        }\n      }\n\n      const newNameOidMap = {};\n      const newEnumOids = {\n        oids: [],\n        arrayOids: []\n      };\n\n      for (const row of result.rows) {\n        // Mapping enums, handled separatedly\n        if (row.typtype === 'e') {\n          newEnumOids.oids.push(row.oid);\n          if (row.typarray) newEnumOids.arrayOids.push(row.typarray);\n          continue;\n        } // Mapping base types and their arrays\n\n\n        newNameOidMap[row.typname] = {\n          oid: row.oid\n        };\n        if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray; // Mapping ranges(of base types) and their arrays\n\n        if (row.rngtypid) {\n          newNameOidMap[row.typname].rangeOid = row.rngtypid;\n          if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;\n        }\n      } // Replace all OID mappings. Avoids temporary empty OID mappings.\n\n\n      this.nameOidMap = newNameOidMap;\n      this.enumOids = newEnumOids;\n      this.refreshTypeParser(dataTypes.postgres);\n    });\n  }\n\n  _clearDynamicOIDs() {\n    this.nameOidMap = {};\n    this.enumOids = {\n      oids: [],\n      arrayOids: []\n    };\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":null,"metadata":{},"sourceType":"script"}