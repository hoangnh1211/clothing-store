{"ast":null,"code":"\"use strict\";\n\nconst dgram = require('dgram');\n\nconst dns = require('dns');\n\nconst net = require('net');\n\nconst punycode = require('punycode');\n\nclass Sender {\n  constructor(host, port, request) {\n    this.host = host;\n    this.port = port;\n    this.request = request;\n    this.parallelSendStrategy = null;\n  }\n\n  execute(cb) {\n    if (net.isIP(this.host)) {\n      this.executeForIP(cb);\n    } else {\n      this.executeForHostname(cb);\n    }\n  }\n\n  executeForIP(cb) {\n    this.executeForAddresses([{\n      address: this.host\n    }], cb);\n  } // Wrapper for stubbing. Sinon does not have support for stubbing module functions.\n\n\n  invokeLookupAll(host, cb) {\n    dns.lookup(punycode.toASCII(host), {\n      all: true\n    }, cb);\n  }\n\n  executeForHostname(cb) {\n    this.invokeLookupAll(this.host, (err, addresses) => {\n      if (err) {\n        return cb(err);\n      }\n\n      this.executeForAddresses(addresses, cb);\n    });\n  } // Wrapper for stubbing creation of Strategy object. Sinon support for constructors\n  // seems limited.\n\n\n  createParallelSendStrategy(addresses, port, request) {\n    return new ParallelSendStrategy(addresses, port, request);\n  }\n\n  executeForAddresses(addresses, cb) {\n    this.parallelSendStrategy = this.createParallelSendStrategy(addresses, this.port, this.request);\n    this.parallelSendStrategy.send(cb);\n  }\n\n  cancel() {\n    if (this.parallelSendStrategy) {\n      this.parallelSendStrategy.cancel();\n    }\n  }\n\n}\n\nclass ParallelSendStrategy {\n  constructor(addresses, port, request) {\n    this.addresses = addresses;\n    this.port = port;\n    this.request = request;\n    this.socketV4 = null;\n    this.socketV6 = null;\n    this.onError = null;\n    this.onMessage = null;\n  }\n\n  clearSockets() {\n    const clearSocket = (socket, onError, onMessage) => {\n      socket.removeListener('error', onError);\n      socket.removeListener('message', onMessage);\n      socket.close();\n    };\n\n    if (this.socketV4) {\n      clearSocket(this.socketV4, this.onError, this.onMessage);\n      this.socketV4 = null;\n    }\n\n    if (this.socketV6) {\n      clearSocket(this.socketV6, this.onError, this.onMessage);\n      this.socketV6 = null;\n    }\n  }\n\n  send(cb) {\n    let errorCount = 0;\n\n    const onError = err => {\n      errorCount++;\n\n      if (errorCount === this.addresses.length) {\n        this.clearSockets();\n        cb(err);\n      }\n    };\n\n    const onMessage = message => {\n      this.clearSockets();\n      cb(null, message);\n    };\n\n    const createDgramSocket = (udpType, onError, onMessage) => {\n      const socket = dgram.createSocket(udpType);\n      socket.on('error', onError);\n      socket.on('message', onMessage);\n      return socket;\n    };\n\n    for (let j = 0; j < this.addresses.length; j++) {\n      const udpTypeV4 = 'udp4';\n      const udpTypeV6 = 'udp6';\n      const udpType = net.isIPv4(this.addresses[j].address) ? udpTypeV4 : udpTypeV6;\n      let socket;\n\n      if (udpType === udpTypeV4) {\n        if (!this.socketV4) {\n          this.socketV4 = createDgramSocket(udpTypeV4, onError, onMessage);\n        }\n\n        socket = this.socketV4;\n      } else {\n        if (!this.socketV6) {\n          this.socketV6 = createDgramSocket(udpTypeV6, onError, onMessage);\n        }\n\n        socket = this.socketV6;\n      }\n\n      socket.send(this.request, 0, this.request.length, this.port, this.addresses[j].address);\n    }\n\n    this.onError = onError;\n    this.onMessage = onMessage;\n  }\n\n  cancel() {\n    this.clearSockets();\n  }\n\n}\n\nmodule.exports.Sender = Sender;\nmodule.exports.ParallelSendStrategy = ParallelSendStrategy;","map":null,"metadata":{},"sourceType":"script"}