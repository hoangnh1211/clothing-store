{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Promise = require('../../promise');\n\nconst sequelizeErrors = require('../../errors');\n\nconst QueryTypes = require('../../query-types');\n/**\n Returns an object that treats SQLite's inabilities to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\n/**\n  A wrapper that fixes SQLite's inability to remove columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but without the obsolete column.\n\n  @param  {QueryInterface} qi\n  @param  {string} tableName     The name of the table.\n  @param  {string} attributeName The name of the attribute that we want to remove.\n  @param  {Object} options\n  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\n\n\nfunction removeColumn(qi, tableName, attributeName, options) {\n  options = options || {};\n  return qi.describeTable(tableName, options).then(fields => {\n    delete fields[attributeName];\n    const sql = qi.QueryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n    return Promise.each(subQueries, subQuery => qi.sequelize.query(\"\".concat(subQuery, \";\"), Object.assign({\n      raw: true\n    }, options)));\n  });\n}\n\nexports.removeColumn = removeColumn;\n/**\n  A wrapper that fixes SQLite's inability to change columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but with a modified version of the respective column.\n\n  @param  {QueryInterface} qi\n  @param  {string} tableName The name of the table.\n  @param  {Object} attributes An object with the attribute's name as key and its options as value object.\n  @param  {Object} options\n  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\n\nfunction changeColumn(qi, tableName, attributes, options) {\n  const attributeName = Object.keys(attributes)[0];\n  options = options || {};\n  return qi.describeTable(tableName, options).then(fields => {\n    fields[attributeName] = attributes[attributeName];\n    const sql = qi.QueryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n    return Promise.each(subQueries, subQuery => qi.sequelize.query(\"\".concat(subQuery, \";\"), Object.assign({\n      raw: true\n    }, options)));\n  });\n}\n\nexports.changeColumn = changeColumn;\n/**\n  A wrapper that fixes SQLite's inability to rename columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but with a renamed version of the respective column.\n\n  @param  {QueryInterface} qi\n  @param  {string} tableName The name of the table.\n  @param  {string} attrNameBefore The name of the attribute before it was renamed.\n  @param  {string} attrNameAfter The name of the attribute after it was renamed.\n  @param  {Object} options\n  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\n\nfunction renameColumn(qi, tableName, attrNameBefore, attrNameAfter, options) {\n  options = options || {};\n  return qi.describeTable(tableName, options).then(fields => {\n    fields[attrNameAfter] = _.clone(fields[attrNameBefore]);\n    delete fields[attrNameBefore];\n    const sql = qi.QueryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n    return Promise.each(subQueries, subQuery => qi.sequelize.query(\"\".concat(subQuery, \";\"), Object.assign({\n      raw: true\n    }, options)));\n  });\n}\n\nexports.renameColumn = renameColumn;\n/**\n * @param {QueryInterface} qi\n * @param {string} tableName\n * @param {string} constraintName\n * @param {Object} options\n *\n * @private\n */\n\nfunction removeConstraint(qi, tableName, constraintName, options) {\n  let createTableSql;\n  return qi.showConstraint(tableName, constraintName).then(constraints => {\n    // sqlite can't show only one constraint, so we find here the one to remove\n    const constraint = constraints.find(constaint => constaint.constraintName === constraintName);\n\n    if (constraint) {\n      createTableSql = constraint.sql;\n      constraint.constraintName = qi.QueryGenerator.quoteIdentifier(constraint.constraintName);\n      let constraintSnippet = \", CONSTRAINT \".concat(constraint.constraintName, \" \").concat(constraint.constraintType, \" \").concat(constraint.constraintCondition);\n\n      if (constraint.constraintType === 'FOREIGN KEY') {\n        const referenceTableName = qi.QueryGenerator.quoteTable(constraint.referenceTableName);\n        constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => qi.QueryGenerator.quoteIdentifier(columnName));\n        const referenceTableKeys = constraint.referenceTableKeys.join(', ');\n        constraintSnippet += \" REFERENCES \".concat(referenceTableName, \" (\").concat(referenceTableKeys, \")\");\n        constraintSnippet += \" ON UPDATE \".concat(constraint.updateAction);\n        constraintSnippet += \" ON DELETE \".concat(constraint.deleteAction);\n      }\n\n      createTableSql = createTableSql.replace(constraintSnippet, '');\n      createTableSql += ';';\n      return qi.describeTable(tableName, options);\n    }\n\n    throw new sequelizeErrors.UnknownConstraintError({\n      message: \"Constraint \".concat(constraintName, \" on table \").concat(tableName, \" does not exist\"),\n      constraint: constraintName,\n      table: tableName\n    });\n  }).then(fields => {\n    const sql = qi.QueryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n\n    const subQueries = sql.split(';').filter(q => q !== '');\n    return Promise.each(subQueries, subQuery => qi.sequelize.query(\"\".concat(subQuery, \";\"), Object.assign({\n      raw: true\n    }, options)));\n  });\n}\n\nexports.removeConstraint = removeConstraint;\n/**\n * @param {QueryInterface} qi\n * @param {string} tableName\n * @param {Object} options\n *\n * @private\n */\n\nfunction addConstraint(qi, tableName, options) {\n  const constraintSnippet = qi.QueryGenerator.getConstraintSnippet(tableName, options);\n  const describeCreateTableSql = qi.QueryGenerator.describeCreateTableQuery(tableName);\n  let createTableSql;\n  return qi.sequelize.query(describeCreateTableSql, Object.assign({}, options, {\n    type: QueryTypes.SELECT,\n    raw: true\n  })).then(constraints => {\n    const sql = constraints[0].sql;\n    const index = sql.length - 1; //Replace ending ')' with constraint snippet - Simulates String.replaceAt\n    //http://stackoverflow.com/questions/1431094\n\n    createTableSql = \"\".concat(sql.substr(0, index), \", \").concat(constraintSnippet, \")\").concat(sql.substr(index + 1), \";\");\n    return qi.describeTable(tableName, options);\n  }).then(fields => {\n    const sql = qi.QueryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n\n    const subQueries = sql.split(';').filter(q => q !== '');\n    return Promise.each(subQueries, subQuery => qi.sequelize.query(\"\".concat(subQuery, \";\"), Object.assign({\n      raw: true\n    }, options)));\n  });\n}\n\nexports.addConstraint = addConstraint;\n/**\n * @param {QueryInterface} qi\n * @param {string} tableName\n * @param {Object} options  Query Options\n *\n * @private\n * @returns {Promise}\n */\n\nfunction getForeignKeyReferencesForTable(qi, tableName, options) {\n  const database = qi.sequelize.config.database;\n  const query = qi.QueryGenerator.getForeignKeysQuery(tableName, database);\n  return qi.sequelize.query(query, options).then(result => {\n    return result.map(row => ({\n      tableName,\n      columnName: row.from,\n      referencedTableName: row.table,\n      referencedColumnName: row.to,\n      tableCatalog: database,\n      referencedTableCatalog: database\n    }));\n  });\n}\n\nexports.getForeignKeyReferencesForTable = getForeignKeyReferencesForTable;","map":null,"metadata":{},"sourceType":"script"}