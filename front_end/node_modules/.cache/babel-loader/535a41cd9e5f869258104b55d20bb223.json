{"ast":null,"code":"'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\n\nconst Promise = require('../../promise');\n\nconst _require = require('../../utils/logger'),\n      logger = _require.logger;\n\nconst debug = logger.debugContext('connection:sqlite');\n\nconst dataTypes = require('../../data-types').sqlite;\n\nconst sequelizeErrors = require('../../errors');\n\nconst parserStore = require('../parserStore')('sqlite');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize); // We attempt to parse file location from a connection uri\n    // but we shouldn't match sequelize default host.\n\n    if (this.sequelize.options.host === 'localhost') {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule('sqlite3').verbose();\n    this.refreshTypeParser(dataTypes);\n  }\n\n  _onProcessExit() {\n    const promises = Object.getOwnPropertyNames(this.connections).map(connection => Promise.fromCallback(callback => this.connections[connection].close(callback)));\n    return Promise.all(promises).then(() => super._onProcessExit.call(this));\n  } // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n    options.inMemory = (this.sequelize.options.storage || this.sequelize.options.host || ':memory:') === ':memory:' ? 1 : 0;\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    options.readWriteMode = dialectOptions && dialectOptions.mode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return Promise.resolve(this.connections[options.inMemory || options.uuid]);\n    }\n\n    return new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(this.sequelize.options.storage || this.sequelize.options.host || ':memory:', options.readWriteMode || this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE, // default mode\n      err => {\n        if (err) return reject(new sequelizeErrors.ConnectionError(err));\n        debug(\"connection acquired \".concat(options.uuid));\n        resolve(this.connections[options.inMemory || options.uuid]);\n      });\n    }).tap(connection => {\n      if (this.sequelize.config.password) {\n        // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n        connection.run(\"PRAGMA KEY=\".concat(this.sequelize.escape(this.sequelize.config.password)));\n      }\n\n      if (this.sequelize.options.foreignKeys !== false) {\n        // Make it possible to define and use foreign key constraints unless\n        // explicitly disallowed. It's still opt-in per relation\n        connection.run('PRAGMA FOREIGN_KEYS=ON');\n      }\n    });\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(\"connection released \".concat(connection.uuid));\n      delete this.connections[connection.uuid];\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":null,"metadata":{},"sourceType":"script"}