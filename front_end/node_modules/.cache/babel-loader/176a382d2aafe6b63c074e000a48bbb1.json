{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst debug = require('debug')('mssql:base');\n\nconst gp = require('generic-pool');\n\nconst TYPES = require('./datatypes').TYPES;\n\nconst declare = require('./datatypes').declare;\n\nconst ISOLATION_LEVEL = require('./isolationlevel');\n\nconst Table = require('./table');\n\nconst ConnectionString = require('./connectionstring');\n\nconst IDS = require('./utils').IDS;\n\nlet globalConnection = null;\nlet PromiseLibrary = Promise;\nconst globalConnectionHandlers = {};\nconst map = [];\nconst driver = {};\n/**\n * Register you own type map.\n *\n * @path module.exports.map\n * @param {*} jstype JS data type.\n * @param {*} sqltype SQL data type.\n */\n\nmap.register = function (jstype, sqltype) {\n  for (let index = 0; index < this.length; index++) {\n    let item = this[index];\n\n    if (item.js === jstype) {\n      this.splice(index, 1);\n      break;\n    }\n  }\n\n  this.push({\n    js: jstype,\n    sql: sqltype\n  });\n  return null;\n};\n\nmap.register(String, TYPES.NVarChar);\nmap.register(Number, TYPES.Int);\nmap.register(Boolean, TYPES.Bit);\nmap.register(Date, TYPES.DateTime);\nmap.register(Buffer, TYPES.VarBinary);\nmap.register(Table, TYPES.TVP);\n/**\n * @ignore\n */\n\nlet getTypeByValue = function (value) {\n  if (value === null || value === undefined) {\n    return TYPES.NVarChar;\n  }\n\n  switch (typeof value) {\n    case 'string':\n      for (var item of Array.from(map)) {\n        if (item.js === String) {\n          return item.sql;\n        }\n      }\n\n      return TYPES.NVarChar;\n\n    case 'number':\n      if (value % 1 === 0) {\n        return TYPES.Int;\n      } else {\n        return TYPES.Float;\n      }\n\n    case 'boolean':\n      for (item of Array.from(map)) {\n        if (item.js === Boolean) {\n          return item.sql;\n        }\n      }\n\n      return TYPES.Bit;\n\n    case 'object':\n      for (item of Array.from(map)) {\n        if (value instanceof item.js) {\n          return item.sql;\n        }\n      }\n\n      return TYPES.NVarChar;\n\n    default:\n      return TYPES.NVarChar;\n  }\n};\n/**\n * Class ConnectionPool.\n *\n * Internally, each `Connection` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool.\n *\n * @property {Boolean} connected If true, connection is established.\n * @property {Boolean} connecting If true, connection is being established.\n *\n * @fires ConnectionPool#connect\n * @fires ConnectionPool#close\n */\n\n\nclass ConnectionPool extends EventEmitter {\n  /**\n   * Create new Connection.\n   *\n   * @param {Object|String} config Connection configuration object or connection string.\n   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.\n   */\n  constructor(config, callback) {\n    super();\n    IDS.add(this, 'ConnectionPool');\n    debug('pool(%d): created', IDS.get(this));\n    this._connected = false;\n    this._connecting = false;\n\n    if (typeof config === 'string') {\n      try {\n        this.config = ConnectionString.resolve(config, driver.name);\n      } catch (ex) {\n        if (typeof callback === 'function') {\n          return setImmediate(callback, ex);\n        }\n\n        throw ex;\n      }\n    } else {\n      this.config = Object.assign({}, config);\n    } // set defaults\n\n\n    this.config.port = this.config.port || 1433;\n    this.config.options = this.config.options || {};\n    this.config.stream = this.config.stream || false;\n    this.config.parseJSON = this.config.parseJSON || false;\n\n    if (/^(.*)\\\\(.*)$/.exec(this.config.server)) {\n      this.config.server = RegExp.$1;\n      this.config.options.instanceName = RegExp.$2;\n    }\n\n    if (typeof callback === 'function') {\n      this.connect(callback);\n    }\n  }\n\n  get connected() {\n    return this._connected;\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n  /**\n   * Acquire connection from this connection pool.\n   *\n   * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.\n   * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.\n   * @return {ConnectionPool|Promise}\n   */\n\n\n  acquire(requester, callback) {\n    if (typeof callback === 'function') {\n      this._acquire().then(connection => callback(null, connection, this.config)).catch(callback);\n\n      return this;\n    }\n\n    return this._acquire();\n  }\n\n  _acquire() {\n    if (!this.pool) {\n      return Promise.reject(new ConnectionError('Connection not yet open.', 'ENOTOPEN'));\n    }\n\n    return this.pool.acquire();\n  }\n  /**\n   * Release connection back to the pool.\n   *\n   * @param {Connection} connection Previously acquired connection.\n   * @return {ConnectionPool}\n   */\n\n\n  release(connection) {\n    debug('connection(%d): released', IDS.get(connection));\n\n    if (this.pool) {\n      this.pool.release(connection);\n    }\n\n    return this;\n  }\n  /**\n   * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.\n   *\n   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n   * @return {ConnectionPool|Promise}\n   */\n\n\n  connect(callback) {\n    if (typeof callback === 'function') {\n      this._connect(callback);\n\n      return this;\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      return this._connect(err => {\n        if (err) return reject(err);\n        resolve(this);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {basicCallback} callback\n   */\n\n\n  _connect(callback) {\n    if (this._connected) {\n      return setImmediate(callback, new ConnectionError('Database is already connected! Call close before connecting to different database.', 'EALREADYCONNECTED'));\n    }\n\n    if (this._connecting) {\n      return setImmediate(callback, new ConnectionError('Already connecting to database! Call close before connecting to different database.', 'EALREADYCONNECTING'));\n    }\n\n    this._connecting = true;\n    debug('pool(%d): connecting', IDS.get(this)); // create one test connection to check if everything is ok\n\n    this._poolCreate().then(connection => {\n      debug('pool(%d): connected', IDS.get(this));\n      return this._poolDestroy(connection).then(() => {\n        if (!this._connecting) {\n          debug('pool(%d): not connecting, exiting silently (was close called before connection established?)', IDS.get(this));\n          return;\n        }\n\n        let createAttempt = 0;\n\n        function create() {\n          // Create an \"ID\" to help track debugging messages\n          const createId = createAttempt++;\n          const timeout = this.config.pool ? this.config.pool.acquireTimeoutMillis : undefined;\n          return this._poolCreateRetry(createId, 0, timeout);\n        } // prepare pool\n\n\n        this.pool = gp.createPool({\n          create: create.bind(this),\n          validate: this._poolValidate.bind(this),\n          destroy: this._poolDestroy.bind(this)\n        }, Object.assign({\n          max: 10,\n          min: 0,\n          evictionRunIntervalMillis: 1000,\n          idleTimeoutMillis: 30000,\n          testOnBorrow: true\n        }, this.config.pool));\n        this.pool.on('factoryCreateError', this.emit.bind(this, 'error'));\n        this.pool.on('factoryDestroyError', this.emit.bind(this, 'error'));\n        this._connecting = false;\n        this._connected = true;\n        callback(null);\n      });\n    }).catch(err => {\n      this._connecting = false;\n      callback(err);\n    });\n  }\n\n  _poolCreateRetry(createId, retryCount, timeout) {\n    const self = this;\n    let backoff;\n    debug('pool(%d): attempting to create connection resource(%d), attempt #%d', IDS.get(this), createId, retryCount); // increment our retry count on error and calculate a new backoff\n\n    retryCount++;\n    return this._poolCreate().catch(e => {\n      // don't bother calculating backoffs > 8, this caps us at ~30s per retry\n      backoff = retryCount > 8 ? backoff : Math.pow(2, retryCount) * 100;\n\n      if (typeof timeout !== 'undefined') {\n        timeout -= backoff;\n\n        if (timeout <= 0) {\n          throw e;\n        }\n      }\n\n      return new Promise((resolve, reject) => {\n        // construct a timer-based promise to retry the connection attempt\n        const timer = setTimeout(() => {\n          debug('pool(%d): backoff timer complete resource(%d)', IDS.get(self), createId); // if the connection has been closed, reject\n\n          if (!self.connecting && !self.connected) {\n            debug('pool(%d): pool closed while trying to acquire a connection resource(%d)', IDS.get(self), createId);\n            reject(new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n          } else {\n            resolve();\n          }\n        }, backoff); // don't let this timer block node from exiting\n\n        timer.unref();\n        debug('pool(%d): failed to create connection resource(%d), retrying with backoff of %dms', IDS.get(self), createId, backoff);\n      }).then(this._poolCreateRetry.bind(this, createId, retryCount, timeout));\n    });\n  }\n  /**\n   * Close all active connections in the pool.\n   *\n   * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.\n   * @return {ConnectionPool|Promise}\n   */\n\n\n  close(callback) {\n    if (typeof callback === 'function') {\n      this._close(callback);\n\n      return this;\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._close(err => {\n        if (err) return reject(err);\n        resolve(this);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {basicCallback} callback\n   */\n\n\n  _close(callback) {\n    this._connecting = this._connected = false;\n    if (!this.pool) return setImmediate(callback, null);\n    const pool = this.pool;\n    this.pool = null;\n    pool.drain().then(() => {\n      return pool.clear();\n    }).then(() => {\n      callback(null);\n    });\n  }\n  /**\n   * Returns new request using this connection.\n   *\n   * @return {Request}\n   */\n\n\n  request() {\n    return new driver.Request(this);\n  }\n  /**\n   * Returns new transaction using this connection.\n   *\n   * @return {Transaction}\n   */\n\n\n  transaction() {\n    return new driver.Transaction(this);\n  }\n  /**\n   * Creates a new query using this connection from a tagged template string.\n   *\n   * @variation 1\n   * @param {Array} strings Array of string literals.\n   * @param {...*} keys Values.\n   * @return {Request}\n   */\n\n  /**\n   * Execute the SQL command.\n   *\n   * @variation 2\n   * @param {String} command T-SQL command to be executed.\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n\n  query() {\n    if (typeof arguments[0] === 'string') {\n      return new driver.Request(this).query(arguments[0], arguments[1]);\n    }\n\n    const values = Array.prototype.slice.call(arguments);\n    const strings = values.shift();\n    return new driver.Request(this)._template(strings, values, 'query');\n  }\n  /**\n   * Creates a new batch using this connection from a tagged template string.\n   *\n   * @variation 1\n   * @param {Array} strings Array of string literals.\n   * @param {...*} keys Values.\n   * @return {Request}\n   */\n\n  /**\n   * Execute the SQL command.\n   *\n   * @variation 2\n   * @param {String} command T-SQL command to be executed.\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n\n  batch() {\n    if (typeof arguments[0] === 'string') {\n      return new driver.Request(this).batch(arguments[0], arguments[1]);\n    }\n\n    const values = Array.prototype.slice.call(arguments);\n    const strings = values.shift();\n    return new driver.Request(this)._template(strings, values, 'batch');\n  }\n\n}\n/**\n * Class PreparedStatement.\n *\n * IMPORTANT: Rememeber that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n *\n * @property {String} statement Prepared SQL statement.\n */\n\n\nclass PreparedStatement extends EventEmitter {\n  /**\n   * Creates a new Prepared Statement.\n   *\n   * @param {ConnectionPool|Transaction} [holder]\n   */\n  constructor(parent) {\n    super();\n    IDS.add(this, 'PreparedStatement');\n    debug('ps(%d): created', IDS.get(this));\n    this.parent = parent || globalConnection;\n    this._handle = 0;\n    this.prepared = false;\n    this.parameters = {};\n  }\n\n  get connected() {\n    return this.parent.connected;\n  }\n  /**\n   * Acquire connection from connection pool.\n   *\n   * @param {Request} request Request.\n   * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n   * @return {PreparedStatement|Promise}\n   */\n\n\n  acquire(request, callback) {\n    if (!this._acquiredConnection) {\n      setImmediate(callback, new PreparedStatementError('Statement is not prepared. Call prepare() first.', 'ENOTPREPARED'));\n      return this;\n    }\n\n    if (this._activeRequest) {\n      setImmediate(callback, new TransactionError(\"Can't acquire connection for the request. There is another request in progress.\", 'EREQINPROG'));\n      return this;\n    }\n\n    this._activeRequest = request;\n    setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);\n    return this;\n  }\n  /**\n   * Release connection back to the pool.\n   *\n   * @param {Connection} connection Previously acquired connection.\n   * @return {PreparedStatement}\n   */\n\n\n  release(connection) {\n    if (connection === this._acquiredConnection) {\n      this._activeRequest = null;\n    }\n\n    return this;\n  }\n  /**\n   * Add an input parameter to the prepared statement.\n   *\n   * @param {String} name Name of the input parameter without @ char.\n   * @param {*} type SQL data type of input parameter.\n   * @return {PreparedStatement}\n   */\n\n\n  input(name, type) {\n    if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n      throw new PreparedStatementError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n    }\n\n    if (arguments.length < 2) {\n      throw new PreparedStatementError('Invalid number of arguments. 2 arguments expected.', 'EARGS');\n    }\n\n    if (type instanceof Function) {\n      type = type();\n    }\n\n    this.parameters[name] = {\n      name,\n      type: type.type,\n      io: 1,\n      length: type.length,\n      scale: type.scale,\n      precision: type.precision,\n      tvpType: type.tvpType\n    };\n    return this;\n  }\n  /**\n   * Add an output parameter to the prepared statement.\n   *\n   * @param {String} name Name of the output parameter without @ char.\n   * @param {*} type SQL data type of output parameter.\n   * @return {PreparedStatement}\n   */\n\n\n  output(name, type) {\n    if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n      throw new PreparedStatementError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n    }\n\n    if (arguments.length < 2) {\n      throw new PreparedStatementError('Invalid number of arguments. 2 arguments expected.', 'EARGS');\n    }\n\n    if (type instanceof Function) type = type();\n    this.parameters[name] = {\n      name,\n      type: type.type,\n      io: 2,\n      length: type.length,\n      scale: type.scale,\n      precision: type.precision\n    };\n    return this;\n  }\n  /**\n   * Prepare a statement.\n   *\n   * @param {String} statement SQL statement to prepare.\n   * @param {basicCallback} [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {PreparedStatement|Promise}\n   */\n\n\n  prepare(statement, callback) {\n    if (typeof callback === 'function') {\n      this._prepare(statement, callback);\n\n      return this;\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._prepare(statement, err => {\n        if (err) return reject(err);\n        resolve(this);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {String} statement\n   * @param {basicCallback} callback\n   */\n\n\n  _prepare(statement, callback) {\n    debug('ps(%d): prepare', IDS.get(this));\n\n    if (typeof statement === 'function') {\n      callback = statement;\n      statement = undefined;\n    }\n\n    if (this.prepared) {\n      return setImmediate(callback, new PreparedStatementError('Statement is already prepared.', 'EALREADYPREPARED'));\n    }\n\n    this.statement = statement || this.statement;\n    this.parent.acquire(this, (err, connection, config) => {\n      if (err) return callback(err);\n      this._acquiredConnection = connection;\n      this._acquiredConfig = config;\n      const req = new driver.Request(this);\n      req.stream = false;\n      req.output('handle', TYPES.Int);\n      req.input('params', TYPES.NVarChar, (() => {\n        let result = [];\n\n        for (let name in this.parameters) {\n          let param = this.parameters[name];\n          result.push(\"@\".concat(name, \" \").concat(declare(param.type, param)).concat(param.io === 2 ? ' output' : ''));\n        }\n\n        return result;\n      })().join(','));\n      req.input('stmt', TYPES.NVarChar, this.statement);\n      req.execute('sp_prepare', (err, result) => {\n        if (err) {\n          this.parent.release(this._acquiredConnection);\n          this._acquiredConnection = null;\n          this._acquiredConfig = null;\n          return callback(err);\n        }\n\n        debug('ps(%d): prepared', IDS.get(this));\n        this._handle = result.output.handle;\n        this.prepared = true;\n        callback(null);\n      });\n    });\n  }\n  /**\n   * Execute a prepared statement.\n   *\n   * @param {Object} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n   * @param {basicCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n\n  execute(values, callback) {\n    if (this.stream || typeof callback === 'function') {\n      return this._execute(values, callback);\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._execute(values, (err, recordset) => {\n        if (err) return reject(err);\n        resolve(recordset);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {Object} values\n   * @param {basicCallback} callback\n   */\n\n\n  _execute(values, callback) {\n    const req = new driver.Request(this);\n    req.stream = this.stream;\n    req.input('handle', TYPES.Int, this._handle); // copy parameters with new values\n\n    for (let name in this.parameters) {\n      let param = this.parameters[name];\n      req.parameters[name] = {\n        name,\n        type: param.type,\n        io: param.io,\n        value: values[name],\n        length: param.length,\n        scale: param.scale,\n        precision: param.precision\n      };\n    }\n\n    req.execute('sp_execute', (err, result) => {\n      if (err) return callback(err);\n      callback(null, result);\n    });\n    return req;\n  }\n  /**\n   * Unprepare a prepared statement.\n   *\n   * @param {basicCallback} [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {PreparedStatement|Promise}\n   */\n\n\n  unprepare(callback) {\n    if (typeof callback === 'function') {\n      this._unprepare(callback);\n\n      return this;\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._unprepare(err => {\n        if (err) return reject(err);\n        resolve();\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {basicCallback} callback\n   */\n\n\n  _unprepare(callback) {\n    debug('ps(%d): unprepare', IDS.get(this));\n\n    if (!this.prepared) {\n      return setImmediate(callback, new PreparedStatementError('Statement is not prepared. Call prepare() first.', 'ENOTPREPARED'));\n    }\n\n    if (this._activeRequest) {\n      return setImmediate(callback, new TransactionError(\"Can't unprepare the statement. There is a request in progress.\", 'EREQINPROG'));\n    }\n\n    const req = new driver.Request(this);\n    req.stream = false;\n    req.input('handle', TYPES.Int, this._handle);\n    req.execute('sp_unprepare', err => {\n      if (err) return callback(err);\n      this.parent.release(this._acquiredConnection);\n      this._acquiredConnection = null;\n      this._acquiredConfig = null;\n      this._handle = 0;\n      this.prepared = false;\n      debug('ps(%d): unprepared', IDS.get(this));\n      return callback(null);\n    });\n  }\n\n}\n/**\n * Class Transaction.\n *\n * @property {Number} isolationLevel Controls the locking and row versioning behavior of TSQL statements issued by a connection. READ_COMMITTED by default.\n * @property {String} name Transaction name. Empty string by default.\n *\n * @fires Transaction#begin\n * @fires Transaction#commit\n * @fires Transaction#rollback\n */\n\n\nclass Transaction extends EventEmitter {\n  /**\n   * Create new Transaction.\n   *\n   * @param {Connection} [holder] If ommited, global connection is used instead.\n   */\n  constructor(parent) {\n    super();\n    IDS.add(this, 'Transaction');\n    debug('transaction(%d): created', IDS.get(this));\n    this.parent = parent || globalConnection;\n    this.isolationLevel = ISOLATION_LEVEL.READ_COMMITTED;\n    this.name = '';\n  }\n\n  get connected() {\n    return this.parent.connected;\n  }\n  /**\n   * Acquire connection from connection pool.\n   *\n   * @param {Request} request Request.\n   * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n   * @return {Transaction|Promise}\n   */\n\n\n  acquire(request, callback) {\n    if (!this._acquiredConnection) {\n      setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'));\n      return this;\n    }\n\n    if (this._activeRequest) {\n      setImmediate(callback, new TransactionError(\"Can't acquire connection for the request. There is another request in progress.\", 'EREQINPROG'));\n      return this;\n    }\n\n    this._activeRequest = request;\n    setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);\n    return this;\n  }\n  /**\n   * Release connection back to the pool.\n   *\n   * @param {Connection} connection Previously acquired connection.\n   * @return {Transaction}\n   */\n\n\n  release(connection) {\n    if (connection === this._acquiredConnection) {\n      this._activeRequest = null;\n    }\n\n    return this;\n  }\n  /**\n   * Begin a transaction.\n   *\n   * @param {Number} [isolationLevel] Controls the locking and row versioning behavior of TSQL statements issued by a connection.\n   * @param {basicCallback} [callback] A callback which is called after transaction has began, or an error has occurred. If omited, method returns Promise.\n   * @return {Transaction|Promise}\n   */\n\n\n  begin(isolationLevel, callback) {\n    if (isolationLevel instanceof Function) {\n      callback = isolationLevel;\n      isolationLevel = undefined;\n    }\n\n    if (typeof callback === 'function') {\n      this._begin(isolationLevel, err => {\n        if (!err) {\n          this.emit('begin');\n        }\n\n        callback(err);\n      });\n\n      return this;\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._begin(isolationLevel, err => {\n        if (err) return reject(err);\n        this.emit('begin');\n        resolve(this);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {Number} [isolationLevel]\n   * @param {basicCallback} [callback]\n   * @return {Transaction}\n   */\n\n\n  _begin(isolationLevel, callback) {\n    if (this._acquiredConnection) {\n      return setImmediate(callback, new TransactionError('Transaction has already begun.', 'EALREADYBEGUN'));\n    }\n\n    this._aborted = false;\n    this._rollbackRequested = false;\n    this.isolationLevel = isolationLevel || this.isolationLevel;\n    setImmediate(callback);\n  }\n  /**\n   * Commit a transaction.\n   *\n   * @param {basicCallback} [callback] A callback which is called after transaction has commited, or an error has occurred. If omited, method returns Promise.\n   * @return {Transaction|Promise}\n   */\n\n\n  commit(callback) {\n    if (typeof callback === 'function') {\n      this._commit(err => {\n        if (!err) {\n          this.emit('commit');\n        }\n\n        callback(err);\n      });\n\n      return this;\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._commit(err => {\n        if (err) return reject(err);\n        this.emit('commit');\n        resolve();\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {basicCallback} [callback]\n   * @return {Transaction}\n   */\n\n\n  _commit(callback) {\n    if (this._aborted) {\n      return setImmediate(callback, new TransactionError('Transaction has been aborted.', 'EABORT'));\n    }\n\n    if (!this._acquiredConnection) {\n      return setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'));\n    }\n\n    if (this._activeRequest) {\n      return setImmediate(callback, new TransactionError(\"Can't commit transaction. There is a request in progress.\", 'EREQINPROG'));\n    }\n\n    setImmediate(callback);\n  }\n  /**\n   * Returns new request using this transaction.\n   *\n   * @return {Request}\n   */\n\n\n  request() {\n    return new driver.Request(this);\n  }\n  /**\n   * Rollback a transaction.\n   *\n   * @param {basicCallback} [callback] A callback which is called after transaction has rolled back, or an error has occurred. If omited, method returns Promise.\n   * @return {Transaction|Promise}\n   */\n\n\n  rollback(callback) {\n    if (typeof callback === 'function') {\n      this._rollback(err => {\n        if (!err) {\n          this.emit('rollback', this._aborted);\n        }\n\n        callback(err);\n      });\n\n      return this;\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      return this._rollback(err => {\n        if (err) return reject(err);\n        this.emit('rollback', this._aborted);\n        resolve();\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {basicCallback} [callback]\n   * @return {Transaction}\n   */\n\n\n  _rollback(callback) {\n    if (this._aborted) {\n      return setImmediate(callback, new TransactionError('Transaction has been aborted.', 'EABORT'));\n    }\n\n    if (!this._acquiredConnection) {\n      return setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'));\n    }\n\n    if (this._activeRequest) {\n      return setImmediate(callback, new TransactionError(\"Can't rollback transaction. There is a request in progress.\", 'EREQINPROG'));\n    }\n\n    this._rollbackRequested = true;\n    setImmediate(callback);\n  }\n\n}\n/**\n * Class Request.\n *\n * @property {Transaction} transaction Reference to transaction when request was created in transaction.\n * @property {*} parameters Collection of input and output parameters.\n * @property {Boolean} canceled `true` if request was canceled.\n *\n * @fires Request#recordset\n * @fires Request#row\n * @fires Request#done\n * @fires Request#error\n */\n\n\nclass Request extends EventEmitter {\n  /**\n   * Create new Request.\n   *\n   * @param {Connection|ConnectionPool|Transaction|PreparedStatement} parent If ommited, global connection is used instead.\n   */\n  constructor(parent) {\n    super();\n    IDS.add(this, 'Request');\n    debug('request(%d): created', IDS.get(this));\n    this.canceled = false;\n    this._paused = false;\n    this.parent = parent || globalConnection;\n    this.parameters = {};\n  }\n  /**\n   * Fetch request from tagged template string.\n   *\n   * @private\n   * @param {Array} strings\n   * @param {Array} values\n   * @param {String} [method] If provided, method is automtically called with serialized command on this object.\n   * @return {Request}\n   */\n\n\n  _template(strings, values, method) {\n    let command = [strings[0]];\n\n    for (let index = 0; index < values.length; index++) {\n      let value = values[index]; // if value is an array, prepare each items as it's own comma separated parameter\n\n      if (Array.isArray(value)) {\n        for (let parameterIndex = 0; parameterIndex < value.length; parameterIndex++) {\n          this.input(\"param\".concat(index + 1, \"_\").concat(parameterIndex), value[parameterIndex]);\n          command.push(\"@param\".concat(index + 1, \"_\").concat(parameterIndex));\n\n          if (parameterIndex < value.length - 1) {\n            command.push(', ');\n          } else {\n            command.push(strings[index + 1]);\n          }\n        }\n      } else {\n        this.input(\"param\".concat(index + 1), value);\n        command.push(\"@param\".concat(index + 1), strings[index + 1]);\n      }\n    }\n\n    if (method) {\n      return this[method](command.join(''));\n    } else {\n      return command.join('');\n    }\n  }\n  /**\n   * Add an input parameter to the request.\n   *\n   * @param {String} name Name of the input parameter without @ char.\n   * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.\n   * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n   * @return {Request}\n   */\n\n\n  input(name, type, value) {\n    if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n      throw new RequestError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n    }\n\n    if (arguments.length === 1) {\n      throw new RequestError('Invalid number of arguments. At least 2 arguments expected.', 'EARGS');\n    } else if (arguments.length === 2) {\n      value = type;\n      type = getTypeByValue(value);\n    } // support for custom data types\n\n\n    if (value && typeof value.valueOf === 'function' && !(value instanceof Date)) value = value.valueOf();\n    if (value === undefined) value = null; // undefined to null\n\n    if (typeof value === 'number' && isNaN(value)) value = null; // NaN to null\n\n    if (type instanceof Function) type = type();\n    this.parameters[name] = {\n      name,\n      type: type.type,\n      io: 1,\n      value,\n      length: type.length,\n      scale: type.scale,\n      precision: type.precision,\n      tvpType: type.tvpType\n    };\n    return this;\n  }\n  /**\n   * Add an output parameter to the request.\n   *\n   * @param {String} name Name of the output parameter without @ char.\n   * @param {*} type SQL data type of output parameter.\n   * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n   * @return {Request}\n   */\n\n\n  output(name, type, value) {\n    if (!type) {\n      type = TYPES.NVarChar;\n    }\n\n    if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n      throw new RequestError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n    }\n\n    if (type === TYPES.Text || type === TYPES.NText || type === TYPES.Image) {\n      throw new RequestError('Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.', 'EDEPRECATED');\n    } // support for custom data types\n\n\n    if (value && typeof value.valueOf === 'function' && !(value instanceof Date)) value = value.valueOf();\n    if (value === undefined) value = null; // undefined to null\n\n    if (typeof value === 'number' && isNaN(value)) value = null; // NaN to null\n\n    if (type instanceof Function) type = type();\n    this.parameters[name] = {\n      name,\n      type: type.type,\n      io: 2,\n      value,\n      length: type.length,\n      scale: type.scale,\n      precision: type.precision\n    };\n    return this;\n  }\n  /**\n   * Execute the SQL batch.\n   *\n   * @param {String} batch T-SQL batch to be executed.\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n\n  batch(batch, callback) {\n    if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n    this.rowsAffected = 0;\n\n    if (typeof callback === 'function') {\n      this._batch(batch, (err, recordsets, output, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err);\n          err = null;\n          this.emit('done', {\n            output,\n            rowsAffected\n          });\n        }\n\n        if (err) return callback(err);\n        callback(null, {\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected\n        });\n      });\n\n      return this;\n    } // Check is method was called as tagged template\n\n\n    if (typeof batch === 'object') {\n      const values = Array.prototype.slice.call(arguments);\n      const strings = values.shift();\n      batch = this._template(strings, values);\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._batch(batch, (err, recordsets, output, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err);\n          err = null;\n          this.emit('done', {\n            output,\n            rowsAffected\n          });\n        }\n\n        if (err) return reject(err);\n        resolve({\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected\n        });\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {String} batch\n   * @param {Request~requestCallback} callback\n   */\n\n\n  _batch(batch, callback) {\n    if (!this.connection) {\n      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n    }\n\n    if (!this.connection.connected) {\n      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n    }\n\n    this.canceled = false;\n    setImmediate(callback);\n  }\n  /**\n   * Bulk load.\n   *\n   * @param {Table} table SQL table.\n   * @param {object} [options] Options to be passed to the underlying driver (tedious only).\n   * @param {Request~bulkCallback} [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n\n  bulk(table, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else if (typeof options === 'undefined') {\n      options = {};\n    }\n\n    if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n\n    if (this.stream || typeof callback === 'function') {\n      this._bulk(table, options, (err, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err);\n          return this.emit('done', {\n            rowsAffected\n          });\n        }\n\n        if (err) return callback(err);\n        callback(null, {\n          rowsAffected\n        });\n      });\n\n      return this;\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._bulk(table, options, (err, rowsAffected) => {\n        if (err) return reject(err);\n        resolve({\n          rowsAffected\n        });\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {Table} table\n   * @param {object} options\n   * @param {Request~bulkCallback} callback\n   */\n\n\n  _bulk(table, options, callback) {\n    if (!this.parent) {\n      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n    }\n\n    if (!this.parent.connected) {\n      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n    }\n\n    this.canceled = false;\n    setImmediate(callback);\n  }\n  /**\n   * Sets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n   *\n   * @param {Stream} stream Stream to pipe data into.\n   * @return {Stream}\n   */\n\n\n  pipe(stream) {\n    this.stream = true;\n    this.on('row', stream.write.bind(stream));\n    this.on('error', stream.emit.bind(stream, 'error'));\n    this.on('done', () => {\n      setImmediate(() => stream.end());\n    });\n    stream.emit('pipe', this);\n    return stream;\n  }\n  /**\n   * Execute the SQL command.\n   *\n   * @param {String} command T-SQL command to be executed.\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n\n  query(command, callback) {\n    if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n    this.rowsAffected = 0;\n\n    if (typeof callback === 'function') {\n      this._query(command, (err, recordsets, output, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err);\n          err = null;\n          this.emit('done', {\n            output,\n            rowsAffected\n          });\n        }\n\n        if (err) return callback(err);\n        callback(null, {\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected\n        });\n      });\n\n      return this;\n    } // Check is method was called as tagged template\n\n\n    if (typeof command === 'object') {\n      const values = Array.prototype.slice.call(arguments);\n      const strings = values.shift();\n      command = this._template(strings, values);\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._query(command, (err, recordsets, output, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err);\n          err = null;\n          this.emit('done', {\n            output,\n            rowsAffected\n          });\n        }\n\n        if (err) return reject(err);\n        resolve({\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected\n        });\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {String} command\n   * @param {Request~bulkCallback} callback\n   */\n\n\n  _query(command, callback) {\n    if (!this.parent) {\n      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n    }\n\n    if (!this.parent.connected) {\n      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n    }\n\n    this.canceled = false;\n    setImmediate(callback);\n  }\n  /**\n   * Call a stored procedure.\n   *\n   * @param {String} procedure Name of the stored procedure to be executed.\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n\n  execute(command, callback) {\n    if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n    this.rowsAffected = 0;\n\n    if (typeof callback === 'function') {\n      this._execute(command, (err, recordsets, output, returnValue, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err);\n          err = null;\n          this.emit('done', {\n            output,\n            rowsAffected,\n            returnValue\n          });\n        }\n\n        if (err) return callback(err);\n        callback(null, {\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected,\n          returnValue\n        });\n      });\n\n      return this;\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._execute(command, (err, recordsets, output, returnValue, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err);\n          err = null;\n          this.emit('done', {\n            output,\n            rowsAffected,\n            returnValue\n          });\n        }\n\n        if (err) return reject(err);\n        resolve({\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected,\n          returnValue\n        });\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {String} procedure\n   * @param {Request~bulkCallback} callback\n   */\n\n\n  _execute(procedure, callback) {\n    if (!this.parent) {\n      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n    }\n\n    if (!this.parent.connected) {\n      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n    }\n\n    this.canceled = false;\n    setImmediate(callback);\n  }\n  /**\n   * Cancel currently executed request.\n   *\n   * @return {Boolean}\n   */\n\n\n  cancel() {\n    this._cancel();\n\n    return true;\n  }\n  /**\n   * @private\n   */\n\n\n  _cancel() {\n    this.canceled = true;\n  }\n\n  pause() {\n    if (this.stream) {\n      this._pause();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _pause() {\n    this._paused = true;\n  }\n\n  resume() {\n    if (this.stream) {\n      this._resume();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _resume() {\n    this._paused = false;\n  }\n\n  _setCurrentRequest(request) {\n    this._currentRequest = request;\n\n    if (this._paused) {\n      this.pause();\n    }\n\n    return this;\n  }\n\n}\n/**\n * Class ConnectionError.\n */\n\n\nclass ConnectionError extends Error {\n  /**\n   * Creates a new ConnectionError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n  constructor(message, code) {\n    if (message instanceof Error) {\n      super(message.message);\n      this.code = message.code || code;\n      Error.captureStackTrace(this, this.constructor);\n      Object.defineProperty(this, 'originalError', {\n        enumerable: true,\n        value: message\n      });\n    } else {\n      super(message);\n      this.code = code;\n    }\n\n    this.name = 'ConnectionError';\n  }\n\n}\n/**\n * Class TransactionError.\n */\n\n\nclass TransactionError extends Error {\n  /**\n   * Creates a new TransactionError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n  constructor(message, code) {\n    if (message instanceof Error) {\n      super(message.message);\n      this.code = message.code || code;\n      Error.captureStackTrace(this, this.constructor);\n      Object.defineProperty(this, 'originalError', {\n        enumerable: true,\n        value: message\n      });\n    } else {\n      super(message);\n      this.code = code;\n    }\n\n    this.name = 'TransactionError';\n  }\n\n}\n/**\n * Class RequestError.\n *\n * @property {String} number Error number.\n * @property {Number} lineNumber Line number.\n * @property {String} state Error state.\n * @property {String} class Error class.\n * @property {String} serverName Server name.\n * @property {String} procName Procedure name.\n */\n\n\nclass RequestError extends Error {\n  /**\n   * Creates a new RequestError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n  constructor(message, code) {\n    if (message instanceof Error) {\n      super(message.message);\n      this.code = message.code || code;\n\n      if (message.info) {\n        this.number = message.info.number || message.code; // err.code is returned by msnodesql driver\n\n        this.lineNumber = message.info.lineNumber;\n        this.state = message.info.state || message.sqlstate; // err.sqlstate is returned by msnodesql driver\n\n        this.class = message.info.class;\n        this.serverName = message.info.serverName;\n        this.procName = message.info.procName;\n      } else {\n        this.number = message.code; // err.code is returned by msnodesql driver\n\n        this.state = message.sqlstate; // err.sqlstate is returned by msnodesql driver\n      }\n\n      Error.captureStackTrace(this, this.constructor);\n      Object.defineProperty(this, 'originalError', {\n        enumerable: true,\n        value: message\n      });\n    } else {\n      super(message);\n      this.code = code;\n    }\n\n    this.name = 'RequestError';\n\n    if (/^\\[Microsoft\\]\\[SQL Server Native Client 11\\.0\\](?:\\[SQL Server\\])?([\\s\\S]*)$/.exec(this.message)) {\n      this.message = RegExp.$1;\n    }\n  }\n\n}\n/**\n * Class PreparedStatementError.\n */\n\n\nclass PreparedStatementError extends Error {\n  /**\n   * Creates a new PreparedStatementError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n  constructor(message, code) {\n    if (message instanceof Error) {\n      super(message.message);\n      this.code = message.code || code;\n      Error.captureStackTrace(this, this.constructor);\n      Object.defineProperty(this, 'originalError', {\n        enumerable: true,\n        value: message\n      });\n    } else {\n      super(message);\n      this.code = code;\n    }\n\n    this.name = 'PreparedStatementError';\n  }\n\n}\n\nmodule.exports = {\n  ConnectionPool,\n  Transaction,\n  Request,\n  PreparedStatement,\n  ConnectionError,\n  TransactionError,\n  RequestError,\n  PreparedStatementError,\n  driver,\n  exports: {\n    ConnectionError,\n    TransactionError,\n    RequestError,\n    PreparedStatementError,\n    Table,\n    ISOLATION_LEVEL,\n    TYPES,\n    MAX: 65535,\n    // (1 << 16) - 1\n    map,\n    getTypeByValue\n  }\n};\nObject.defineProperty(module.exports, 'Promise', {\n  get: () => {\n    return PromiseLibrary;\n  },\n  set: value => {\n    PromiseLibrary = value;\n  }\n}); // append datatypes to this modules export\n\nfor (let key in TYPES) {\n  let value = TYPES[key];\n  module.exports.exports[key] = value;\n  module.exports.exports[key.toUpperCase()] = value;\n}\n/**\n * Open global connection pool.\n *\n * @param {Object|String} config Connection configuration object or connection string.\n * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n * @return {ConnectionPool|Promise}\n */\n\n\nmodule.exports.exports.connect = function connect(config, callback) {\n  if (globalConnection) throw new Error('Global connection already exists. Call sql.close() first.');\n  globalConnection = new driver.ConnectionPool(config);\n\n  for (let event in globalConnectionHandlers) {\n    for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {\n      globalConnection.on(event, globalConnectionHandlers[event][i]);\n    }\n  }\n\n  return globalConnection.connect(callback);\n};\n/**\n * Close all active connections in the global pool.\n *\n * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.\n * @return {ConnectionPool|Promise}\n */\n\n\nmodule.exports.exports.close = function close(callback) {\n  if (globalConnection) {\n    // remove event handlers from the global connection\n    for (let event in globalConnectionHandlers) {\n      for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {\n        globalConnection.removeListener(event, globalConnectionHandlers[event][i]);\n      }\n    } // attach error handler to prevent process crash in case of error\n\n\n    globalConnection.on('error', err => {\n      if (globalConnectionHandlers['error']) {\n        for (let i = 0, l = globalConnectionHandlers['error'].length; i < l; i++) {\n          globalConnectionHandlers['error'][i].call(globalConnection, err);\n        }\n      }\n    });\n    const gc = globalConnection;\n    globalConnection = null;\n    return gc.close(callback);\n  }\n\n  if (typeof callback === 'function') {\n    setImmediate(callback);\n    return null;\n  }\n\n  return new PromiseLibrary((resolve, reject) => {\n    resolve(globalConnection);\n  });\n};\n/**\n * Attach event handler to global connection pool.\n *\n * @param {String} event Event name.\n * @param {Function} handler Event handler.\n * @return {ConnectionPool}\n */\n\n\nmodule.exports.exports.on = function on(event, handler) {\n  if (!globalConnectionHandlers[event]) globalConnectionHandlers[event] = [];\n  globalConnectionHandlers[event].push(handler);\n  if (globalConnection) globalConnection.on(event, handler);\n  return globalConnection;\n};\n/**\n * Detach event handler from global connection.\n *\n * @param {String} event Event name.\n * @param {Function} handler Event handler.\n * @return {ConnectionPool}\n */\n\n\nmodule.exports.exports.removeListener = module.exports.exports.off = function removeListener(event, handler) {\n  if (!globalConnectionHandlers[event]) return globalConnection;\n  const index = globalConnectionHandlers[event].indexOf(handler);\n  if (index === -1) return globalConnection;\n  globalConnectionHandlers[event].splice(index, 1);\n  if (globalConnectionHandlers[event].length === 0) globalConnectionHandlers[event] = undefined;\n  if (globalConnection) globalConnection.removeListener(event, handler);\n  return globalConnection;\n};\n/**\n * Creates a new query using global connection from a tagged template string.\n *\n * @variation 1\n * @param {Array|String} strings Array of string literals or sql command.\n * @param {...*} keys Values.\n * @return {Request}\n */\n\n/**\n * Execute the SQL command.\n *\n * @variation 2\n * @param {String} command T-SQL command to be executed.\n * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n * @return {Request|Promise}\n */\n\n\nmodule.exports.exports.query = function query() {\n  if (typeof arguments[0] === 'string') {\n    return new driver.Request().query(arguments[0], arguments[1]);\n  }\n\n  const values = Array.prototype.slice.call(arguments);\n  const strings = values.shift();\n  return new driver.Request()._template(strings, values, 'query');\n};\n/**\n * Creates a new batch using global connection from a tagged template string.\n *\n * @variation 1\n * @param {Array} strings Array of string literals.\n * @param {...*} keys Values.\n * @return {Request}\n */\n\n/**\n * Execute the SQL command.\n *\n * @variation 2\n * @param {String} command T-SQL command to be executed.\n * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n * @return {Request|Promise}\n */\n\n\nmodule.exports.exports.batch = function batch() {\n  if (typeof arguments[0] === 'string') {\n    return new driver.Request().batch(arguments[0], arguments[1]);\n  }\n\n  const values = Array.prototype.slice.call(arguments);\n  const strings = values.shift();\n  return new driver.Request()._template(strings, values, 'batch');\n};\n/**\n * @callback Request~requestCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Object} result Request result.\n */\n\n/**\n * @callback Request~bulkCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Number} rowsAffected Number of affected rows.\n */\n\n/**\n * @callback basicCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Connection} connection Acquired connection.\n */\n\n/**\n * @callback acquireCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Connection} connection Acquired connection.\n */\n\n/**\n * Dispatched after connection has established.\n * @event ConnectionPool#connect\n */\n\n/**\n * Dispatched after connection has closed a pool (by calling close).\n * @event ConnectionPool#close\n */\n\n/**\n * Dispatched when transaction begin.\n * @event Transaction#begin\n */\n\n/**\n * Dispatched on successful commit.\n * @event Transaction#commit\n */\n\n/**\n * Dispatched on successful rollback.\n * @event Transaction#rollback\n */\n\n/**\n * Dispatched when metadata for new recordset are parsed.\n * @event Request#recordset\n */\n\n/**\n * Dispatched when new row is parsed.\n * @event Request#row\n */\n\n/**\n * Dispatched when request is complete.\n * @event Request#done\n */\n\n/**\n * Dispatched on error.\n * @event Request#error\n */","map":null,"metadata":{},"sourceType":"script"}