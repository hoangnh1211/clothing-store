{"ast":null,"code":"\"use strict\";\n\nconst Deferred = require(\"./Deferred\");\n/**\n * Generate an Object pool with a specified `factory`.\n *\n * @class\n * @param {Object} factory\n *   Factory to be used for generating and destroying the items.\n * @param {String} [factory.name]\n *   Name of the factory. Serves only logging purposes.\n * @param {Function} factory.create\n *   Should create the item to be acquired,\n *   and call it's first callback argument with the generated item as it's argument.\n * @param {Function} factory.destroy\n *   Should gently close any resources that the item is using.\n *   Called before the items is destroyed.\n * @param {Function} factory.validate\n *   Should return true if connection is still valid and false\n *   If it should be removed from pool. Called before item is\n *   acquired from pool.\n * @param {Number} factory.max\n *   Maximum number of items that can exist at the same time.\n *   Any further acquire requests will be pushed to the waiting list.\n * @param {Number} factory.min\n *   Minimum number of items in pool (including in-use).\n *   When the pool is created, or a resource destroyed, this minimum will\n *   be checked. If the pool resource count is below the minimum, a new\n *   resource will be created and added to the pool.\n * @param {Number} [factory.idleTimeoutMillis=30000]\n *   Delay in milliseconds after which available resources in the pool will be destroyed.\n *   This does not affects pending acquire requests.\n * @param {Number} [factory.acquireTimeoutMillis=30000]\n *   Delay in milliseconds after which pending acquire request in the pool will be rejected.\n *   Pending acquires are acquire calls which are yet to receive an response from factory.create\n * @param {Number} [factory.reapIntervalMillis=1000]\n *   Clean up is scheduled in every `factory.reapIntervalMillis` milliseconds.\n * @param {Boolean|Function} [factory.log=false]\n *   Whether the pool should log activity. If function is specified,\n *   that will be used instead. The function expects the arguments msg, loglevel\n */\n\n\nclass Pool {\n  constructor(factory) {\n    if (!factory.create) {\n      throw new Error(\"create function is required\");\n    }\n\n    if (!factory.destroy) {\n      throw new Error(\"destroy function is required\");\n    }\n\n    if (!factory.validate) {\n      throw new Error(\"validate function is required\");\n    }\n\n    if (typeof factory.min !== \"number\" || factory.min < 0 || factory.min !== Math.round(factory.min)) {\n      throw new Error(\"min must be an integer >= 0\");\n    }\n\n    if (typeof factory.max !== \"number\" || factory.max <= 0 || factory.max !== Math.round(factory.max)) {\n      throw new Error(\"max must be an integer > 0\");\n    }\n\n    if (factory.min > factory.max) {\n      throw new Error(\"max is smaller than min\");\n    } // defaults\n\n\n    factory.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;\n    factory.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;\n    factory.reapInterval = factory.reapIntervalMillis || 1000;\n    factory.max = parseInt(factory.max, 10);\n    factory.min = parseInt(factory.min, 10);\n    factory.log = factory.log || false;\n    this._factory = factory;\n    this._count = 0;\n    this._draining = false; // queues\n\n    this._pendingAcquires = [];\n    this._inUseObjects = [];\n    this._availableObjects = []; // timing controls\n\n    this._removeIdleTimer = null;\n    this._removeIdleScheduled = false;\n  }\n\n  get size() {\n    return this._count;\n  }\n\n  get name() {\n    return this._factory.name;\n  }\n\n  get available() {\n    return this._availableObjects.length;\n  }\n\n  get using() {\n    return this._inUseObjects.length;\n  }\n\n  get waiting() {\n    return this._pendingAcquires.length;\n  }\n\n  get maxSize() {\n    return this._factory.max;\n  }\n\n  get minSize() {\n    return this._factory.min;\n  }\n  /**\n   * logs to console or user defined log function\n   * @private\n   * @param {string} message\n   * @param {string} level\n   */\n\n\n  _log(message, level) {\n    if (typeof this._factory.log === \"function\") {\n      this._factory.log(message, level);\n    } else if (this._factory.log) {\n      console.log(\"\".concat(level.toUpperCase(), \" pool \").concat(this.name, \" - \").concat(message));\n    }\n  }\n  /**\n   * Checks and removes the available (idle) clients that have timed out.\n   * @private\n   */\n\n\n  _removeIdle() {\n    const toRemove = [];\n    const now = Date.now();\n    let i;\n    let available = this._availableObjects.length;\n    const maxRemovable = this._count - this._factory.min;\n    let timeout;\n    this._removeIdleScheduled = false; // Go through the available (idle) items,\n    // check if they have timed out\n\n    for (i = 0; i < available && maxRemovable > toRemove.length; i++) {\n      timeout = this._availableObjects[i].timeout;\n\n      if (now >= timeout) {\n        // Client timed out, so destroy it.\n        this._log(\"removeIdle() destroying obj - now:\" + now + \" timeout:\" + timeout, \"verbose\");\n\n        toRemove.push(this._availableObjects[i].resource);\n      }\n    }\n\n    toRemove.forEach(this.destroy, this); // NOTE: we are re-calculating this value because it may have changed\n    // after destroying items above\n    // Replace the available items with the ones to keep.\n\n    available = this._availableObjects.length;\n\n    if (available > 0) {\n      this._log(\"this._availableObjects.length=\" + available, \"verbose\");\n\n      this._scheduleRemoveIdle();\n    } else {\n      this._log(\"removeIdle() all objects removed\", \"verbose\");\n    }\n  }\n  /**\n   * Schedule removal of idle items in the pool.\n   *\n   * More schedules cannot run concurrently.\n   */\n\n\n  _scheduleRemoveIdle() {\n    if (!this._removeIdleScheduled) {\n      this._removeIdleScheduled = true;\n      this._removeIdleTimer = setTimeout(() => {\n        this._removeIdle();\n      }, this._factory.reapInterval);\n    }\n  }\n  /**\n   * Try to get a new client to work, and clean up pool unused (idle) items.\n   *\n   *  - If there are available clients waiting, pop the first one out (LIFO),\n   *    and call its callback.\n   *  - If there are no waiting clients, try to create one if it won't exceed\n   *    the maximum number of clients.\n   *  - If creating a new client would exceed the maximum, add the client to\n   *    the wait list.\n   * @private\n   */\n\n\n  _dispense() {\n    let resourceWithTimeout = null;\n    const waitingCount = this._pendingAcquires.length;\n\n    this._log(\"dispense() clients=\".concat(waitingCount, \" available=\").concat(this._availableObjects.length), \"info\");\n\n    if (waitingCount < 1) {\n      return;\n    }\n\n    while (this._availableObjects.length > 0) {\n      this._log(\"dispense() - reusing obj\", \"verbose\");\n\n      resourceWithTimeout = this._availableObjects[this._availableObjects.length - 1];\n\n      if (!this._factory.validate(resourceWithTimeout.resource)) {\n        this.destroy(resourceWithTimeout.resource);\n        continue;\n      }\n\n      this._availableObjects.pop();\n\n      this._inUseObjects.push(resourceWithTimeout.resource);\n\n      const deferred = this._pendingAcquires.shift();\n\n      return deferred.resolve(resourceWithTimeout.resource);\n    }\n\n    if (this._count < this._factory.max) {\n      this._createResource();\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _createResource() {\n    this._count += 1;\n\n    this._log(\"createResource() - creating obj - count=\".concat(this._count, \" min=\").concat(this._factory.min, \" max=\").concat(this._factory.max), \"verbose\");\n\n    this._factory.create().then(resource => {\n      const deferred = this._pendingAcquires.shift();\n\n      this._inUseObjects.push(resource);\n\n      if (deferred) {\n        deferred.resolve(resource);\n      } else {\n        this._addResourceToAvailableObjects(resource);\n      }\n    }).catch(error => {\n      const deferred = this._pendingAcquires.shift();\n\n      this._count -= 1;\n      if (this._count < 0) this._count = 0;\n\n      if (deferred) {\n        deferred.reject(error);\n      }\n\n      process.nextTick(() => {\n        this._dispense();\n      });\n    });\n  }\n\n  _addResourceToAvailableObjects(resource) {\n    const resourceWithTimeout = {\n      resource: resource,\n      timeout: Date.now() + this._factory.idleTimeoutMillis\n    };\n\n    this._availableObjects.push(resourceWithTimeout);\n\n    this._dispense();\n\n    this._scheduleRemoveIdle();\n  }\n  /**\n   * @private\n   */\n\n\n  _ensureMinimum() {\n    let i, diff;\n\n    if (!this._draining && this._count < this._factory.min) {\n      diff = this._factory.min - this._count;\n\n      for (i = 0; i < diff; i++) {\n        this._createResource();\n      }\n    }\n  }\n  /**\n   * Requests a new resource. This will call factory.create to request new resource.\n   *\n   * It will be rejected with timeout error if `factory.create` didn't respond\n   * back within specified `acquireTimeoutMillis`\n   *\n   * @returns {Promise<Object>}\n   */\n\n\n  acquire() {\n    if (this._draining) {\n      return Promise.reject(new Error(\"pool is draining and cannot accept work\"));\n    }\n\n    const deferred = new Deferred();\n    deferred.registerTimeout(this._factory.acquireTimeoutMillis, () => {\n      // timeout triggered, promise will be rejected\n      // remove this object from pending list\n      this._pendingAcquires = this._pendingAcquires.filter(pending => pending !== deferred);\n    });\n\n    this._pendingAcquires.push(deferred);\n\n    this._dispense();\n\n    return deferred.promise();\n  }\n  /**\n   * Return the resource to the pool, in case it is no longer required.\n   *\n   * @param {Object} resource The acquired object to be put back to the pool.\n   *\n   * @returns {void}\n   */\n\n\n  release(resource) {\n    // check to see if this object has already been released\n    // (i.e., is back in the pool of this._availableObjects)\n    if (this._availableObjects.some(resourceWithTimeout => resourceWithTimeout.resource === resource)) {\n      this._log(\"release called twice for the same resource: \" + new Error().stack, \"error\");\n\n      return;\n    } // check to see if this object exists in the `in use` list and remove it\n\n\n    const index = this._inUseObjects.indexOf(resource);\n\n    if (index < 0) {\n      this._log(\"attempt to release an invalid resource: \" + new Error().stack, \"error\");\n\n      return;\n    }\n\n    this._inUseObjects.splice(index, 1);\n\n    this._addResourceToAvailableObjects(resource);\n  }\n  /**\n   * Request the client to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource The acquired item to be destroyed.\n   *\n   * @returns {void}\n   */\n\n\n  destroy(resource) {\n    const available = this._availableObjects.length;\n    const using = this._inUseObjects.length;\n    this._availableObjects = this._availableObjects.filter(object => object.resource !== resource);\n    this._inUseObjects = this._inUseObjects.filter(object => object !== resource); // resource was not removed, then no need to decrement _count\n\n    if (available === this._availableObjects.length && using === this._inUseObjects.length) {\n      this._ensureMinimum();\n\n      return;\n    }\n\n    this._count -= 1;\n    if (this._count < 0) this._count = 0;\n\n    this._factory.destroy(resource);\n\n    this._ensureMinimum();\n  }\n  /**\n   * Disallow any new requests and let the request backlog dissipate.\n   *\n   * @returns {Promise}\n   */\n\n\n  drain() {\n    this._log(\"draining\", \"info\"); // disable the ability to put more work on the queue.\n\n\n    this._draining = true;\n\n    const check = callback => {\n      // wait until all client requests have been satisfied.\n      if (this._pendingAcquires.length > 0) {\n        // pool is draining so we wont accept new acquires but\n        // we need to clear pending acquires\n        this._dispense();\n\n        return setTimeout(() => {\n          check(callback);\n        }, 100);\n      } // wait until in use object have been released.\n\n\n      if (this._availableObjects.length !== this._count) {\n        return setTimeout(() => {\n          check(callback);\n        }, 100);\n      }\n\n      callback();\n    }; // No error handling needed here.\n\n\n    return new Promise(resolve => check(resolve));\n  }\n  /**\n   * Forcibly destroys all clients regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * clients as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0, the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling destroyAllNow()\n   *\n   * @returns {Promise}\n   */\n\n\n  destroyAllNow() {\n    this._log(\"force destroying all objects\", \"info\");\n\n    const willDie = this._availableObjects.slice();\n\n    const todo = willDie.length;\n    this._removeIdleScheduled = false;\n    clearTimeout(this._removeIdleTimer);\n    return new Promise(resolve => {\n      if (todo === 0) {\n        return resolve();\n      }\n\n      let resource;\n      let done = 0;\n\n      while (resource = willDie.shift()) {\n        this.destroy(resource.resource);\n        ++done;\n\n        if (done === todo && resolve) {\n          return resolve();\n        }\n      }\n    });\n  }\n\n}\n\nexports.Pool = Pool;\nexports.default = Pool;\nexports.TimeoutError = require(\"./TimeoutError\").TimeoutError;","map":null,"metadata":{},"sourceType":"script"}