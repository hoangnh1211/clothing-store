{"ast":null,"code":"'use strict';\n\nconst tds = require('tedious');\n\nconst debug = require('debug')('mssql:tedi');\n\nconst base = require('./base');\n\nconst TYPES = require('./datatypes').TYPES;\n\nconst declare = require('./datatypes').declare;\n\nconst cast = require('./datatypes').cast;\n\nconst DECLARATIONS = require('./datatypes').DECLARATIONS;\n\nconst UDT = require('./udt').PARSERS;\n\nconst Table = require('./table');\n\nconst IDS = require('./utils').IDS;\n\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B';\nconst N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n};\n\nconst getTediousType = function (type) {\n  switch (type) {\n    case TYPES.VarChar:\n      return tds.TYPES.VarChar;\n\n    case TYPES.NVarChar:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Text:\n      return tds.TYPES.Text;\n\n    case TYPES.Int:\n      return tds.TYPES.Int;\n\n    case TYPES.BigInt:\n      return tds.TYPES.BigInt;\n\n    case TYPES.TinyInt:\n      return tds.TYPES.TinyInt;\n\n    case TYPES.SmallInt:\n      return tds.TYPES.SmallInt;\n\n    case TYPES.Bit:\n      return tds.TYPES.Bit;\n\n    case TYPES.Float:\n      return tds.TYPES.Float;\n\n    case TYPES.Decimal:\n      return tds.TYPES.Decimal;\n\n    case TYPES.Numeric:\n      return tds.TYPES.Numeric;\n\n    case TYPES.Real:\n      return tds.TYPES.Real;\n\n    case TYPES.Money:\n      return tds.TYPES.Money;\n\n    case TYPES.SmallMoney:\n      return tds.TYPES.SmallMoney;\n\n    case TYPES.Time:\n      return tds.TYPES.Time;\n\n    case TYPES.Date:\n      return tds.TYPES.Date;\n\n    case TYPES.DateTime:\n      return tds.TYPES.DateTime;\n\n    case TYPES.DateTime2:\n      return tds.TYPES.DateTime2;\n\n    case TYPES.DateTimeOffset:\n      return tds.TYPES.DateTimeOffset;\n\n    case TYPES.SmallDateTime:\n      return tds.TYPES.SmallDateTime;\n\n    case TYPES.UniqueIdentifier:\n      return tds.TYPES.UniqueIdentifier;\n\n    case TYPES.Xml:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Char:\n      return tds.TYPES.Char;\n\n    case TYPES.NChar:\n      return tds.TYPES.NChar;\n\n    case TYPES.NText:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Image:\n      return tds.TYPES.Image;\n\n    case TYPES.Binary:\n      return tds.TYPES.Binary;\n\n    case TYPES.VarBinary:\n      return tds.TYPES.VarBinary;\n\n    case TYPES.UDT:\n    case TYPES.Geography:\n    case TYPES.Geometry:\n      return tds.TYPES.UDT;\n\n    case TYPES.TVP:\n      return tds.TYPES.TVP;\n\n    case TYPES.Variant:\n      return tds.TYPES.Variant;\n\n    default:\n      return type;\n  }\n};\n\nconst getMssqlType = function (type, length) {\n  if (typeof type !== 'object') return undefined;\n\n  switch (type) {\n    case tds.TYPES.Char:\n      return TYPES.Char;\n\n    case tds.TYPES.NChar:\n      return TYPES.NChar;\n\n    case tds.TYPES.VarChar:\n      return TYPES.VarChar;\n\n    case tds.TYPES.NVarChar:\n      return TYPES.NVarChar;\n\n    case tds.TYPES.Text:\n      return TYPES.Text;\n\n    case tds.TYPES.NText:\n      return TYPES.NText;\n\n    case tds.TYPES.Int:\n      return TYPES.Int;\n\n    case tds.TYPES.BigInt:\n      return TYPES.BigInt;\n\n    case tds.TYPES.TinyInt:\n      return TYPES.TinyInt;\n\n    case tds.TYPES.SmallInt:\n      return TYPES.SmallInt;\n\n    case tds.TYPES.Bit:\n      return TYPES.Bit;\n\n    case tds.TYPES.Float:\n      return TYPES.Float;\n\n    case tds.TYPES.Real:\n      return TYPES.Real;\n\n    case tds.TYPES.Money:\n      return TYPES.Money;\n\n    case tds.TYPES.SmallMoney:\n      return TYPES.SmallMoney;\n\n    case tds.TYPES.Numeric:\n      return TYPES.Numeric;\n\n    case tds.TYPES.Decimal:\n      return TYPES.Decimal;\n\n    case tds.TYPES.DateTime:\n      return TYPES.DateTime;\n\n    case tds.TYPES.Time:\n      return TYPES.Time;\n\n    case tds.TYPES.Date:\n      return TYPES.Date;\n\n    case tds.TYPES.DateTime2:\n      return TYPES.DateTime2;\n\n    case tds.TYPES.DateTimeOffset:\n      return TYPES.DateTimeOffset;\n\n    case tds.TYPES.SmallDateTime:\n      return TYPES.SmallDateTime;\n\n    case tds.TYPES.UniqueIdentifier:\n      return TYPES.UniqueIdentifier;\n\n    case tds.TYPES.Image:\n      return TYPES.Image;\n\n    case tds.TYPES.Binary:\n      return TYPES.Binary;\n\n    case tds.TYPES.VarBinary:\n      return TYPES.VarBinary;\n\n    case tds.TYPES.Xml:\n      return TYPES.Xml;\n\n    case tds.TYPES.UDT:\n      return TYPES.UDT;\n\n    case tds.TYPES.TVP:\n      return TYPES.TVP;\n\n    case tds.TYPES.Variant:\n      return TYPES.Variant;\n\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN:\n          return TYPES.Bit;\n\n        case N_TYPES.NumericN:\n          return TYPES.Numeric;\n\n        case N_TYPES.DecimalN:\n          return TYPES.Decimal;\n\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt;\n          if (length === 4) return TYPES.Int;\n          if (length === 2) return TYPES.SmallInt;\n          return TYPES.TinyInt;\n\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float;\n          return TYPES.Real;\n\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money;\n          return TYPES.SmallMoney;\n\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime;\n          return TYPES.SmallDateTime;\n      }\n\n  }\n};\n\nconst createColumns = function (metadata) {\n  let out = {};\n\n  for (let index = 0, length = metadata.length; index < length; index++) {\n    let column = metadata[index];\n    out[column.colName] = {\n      index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    };\n\n    if (column.udtInfo) {\n      out[column.colName].udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      };\n\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        out[column.colName].type = DECLARATIONS[column.udtInfo.typeName];\n      }\n    }\n  }\n\n  return out;\n};\n\nconst valueCorrection = function (value, metadata) {\n  if (metadata.type === tds.TYPES.UDT && value != null) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value);\n    } else {\n      return value;\n    }\n  } else {\n    return value;\n  }\n};\n\nconst parameterCorrection = function (value) {\n  if (value instanceof Table) {\n    const tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    };\n\n    for (let col of value.columns) {\n      tvp.columns.push({\n        name: col.name,\n        type: getTediousType(col.type),\n        length: col.length,\n        scale: col.scale,\n        precision: col.precision\n      });\n    }\n\n    return tvp;\n  } else {\n    return value;\n  }\n};\n\nclass ConnectionPool extends base.ConnectionPool {\n  _poolCreate() {\n    return new base.Promise((resolve, reject) => {\n      const cfg = {\n        server: this.config.server,\n        options: Object.assign({\n          encrypt: typeof this.config.encrypt === 'boolean' ? this.config.encrypt : false\n        }, this.config.options),\n        authentication: Object.assign({\n          type: this.config.domain !== undefined ? 'ntlm' : 'default',\n          options: {\n            userName: this.config.user,\n            password: this.config.password,\n            domain: this.config.domain\n          }\n        }, this.config.authentication)\n      };\n      cfg.options.database = this.config.database;\n      cfg.options.port = this.config.port;\n      cfg.options.connectTimeout = this.config.connectionTimeout || this.config.timeout || 15000;\n      cfg.options.requestTimeout = this.config.requestTimeout != null ? this.config.requestTimeout : 15000;\n      cfg.options.tdsVersion = cfg.options.tdsVersion || '7_4';\n      cfg.options.rowCollectionOnDone = false;\n      cfg.options.rowCollectionOnRequestCompletion = false;\n      cfg.options.useColumnNames = false;\n      cfg.options.appName = cfg.options.appName || 'node-mssql'; // tedious always connect via tcp when port is specified\n\n      if (cfg.options.instanceName) delete cfg.options.port;\n      if (isNaN(cfg.options.requestTimeout)) cfg.options.requestTimeout = 15000;\n      if (cfg.options.requestTimeout === Infinity) cfg.options.requestTimeout = 0;\n      if (cfg.options.requestTimeout < 0) cfg.options.requestTimeout = 0;\n\n      if (this.config.debug) {\n        cfg.options.debug = {\n          packet: true,\n          token: true,\n          data: true,\n          payload: true\n        };\n      }\n\n      const tedious = new tds.Connection(cfg);\n      IDS.add(tedious, 'Connection');\n      debug('pool(%d): connection #%d created', IDS.get(this), IDS.get(tedious));\n      debug('connection(%d): establishing', IDS.get(tedious));\n      tedious.once('connect', err => {\n        if (err) {\n          err = new base.ConnectionError(err);\n          return reject(err);\n        }\n\n        debug('connection(%d): established', IDS.get(tedious));\n        resolve(tedious);\n      });\n      tedious.on('error', err => {\n        if (err.code === 'ESOCKET') {\n          tedious.hasError = true;\n          reject(err);\n          return;\n        }\n\n        this.emit('error', err);\n        reject(err);\n      });\n\n      if (this.config.debug) {\n        tedious.on('debug', this.emit.bind(this, 'debug', tedious));\n      }\n\n      if (typeof this.config.beforeConnect === 'function') {\n        this.config.beforeConnect(tedious);\n      }\n    });\n  }\n\n  _poolValidate(tedious) {\n    return new base.Promise((resolve, reject) => {\n      resolve(tedious && !tedious.closed && !tedious.hasError);\n    });\n  }\n\n  _poolDestroy(tedious) {\n    return new base.Promise((resolve, reject) => {\n      if (!tedious) {\n        resolve();\n        return;\n      }\n\n      debug('connection(%d): destroying', IDS.get(tedious));\n\n      if (tedious.closed) {\n        debug('connection(%d): already closed', IDS.get(tedious));\n        resolve();\n      } else {\n        tedious.once('end', () => {\n          debug('connection(%d): destroyed', IDS.get(tedious));\n          resolve();\n        });\n        tedious.close();\n      }\n    });\n  }\n\n}\n\nclass Transaction extends base.Transaction {\n  constructor(parent) {\n    super(parent);\n\n    this._abort = () => {\n      if (!this._rollbackRequested) {\n        // transaction interrupted because of XACT_ABORT\n        const pc = this._acquiredConnection; // defer releasing so connection can switch from SentClientRequest to LoggedIn state\n\n        setImmediate(this.parent.release.bind(this.parent), pc);\n\n        this._acquiredConnection.removeListener('rollbackTransaction', this._abort);\n\n        this._acquiredConnection = null;\n        this._acquiredConfig = null;\n        this._aborted = true;\n        this.emit('rollback', true);\n      }\n    };\n  }\n\n  _begin(isolationLevel, callback) {\n    super._begin(isolationLevel, err => {\n      if (err) return callback(err);\n      debug('transaction(%d): begin', IDS.get(this));\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err);\n        this._acquiredConnection = connection;\n\n        this._acquiredConnection.on('rollbackTransaction', this._abort);\n\n        this._acquiredConfig = config;\n        connection.beginTransaction(err => {\n          if (err) err = new base.TransactionError(err);\n          debug('transaction(%d): begun', IDS.get(this));\n          callback(err);\n        }, this.name, this.isolationLevel);\n      });\n    });\n  }\n\n  _commit(callback) {\n    super._commit(err => {\n      if (err) return callback(err);\n      debug('transaction(%d): commit', IDS.get(this));\n\n      this._acquiredConnection.commitTransaction(err => {\n        if (err) err = new base.TransactionError(err);\n\n        this._acquiredConnection.removeListener('rollbackTransaction', this._abort);\n\n        this.parent.release(this._acquiredConnection);\n        this._acquiredConnection = null;\n        this._acquiredConfig = null;\n        if (!err) debug('transaction(%d): commited', IDS.get(this));\n        callback(err);\n      });\n    });\n  }\n\n  _rollback(callback) {\n    super._rollback(err => {\n      if (err) return callback(err);\n      debug('transaction(%d): rollback', IDS.get(this));\n\n      this._acquiredConnection.rollbackTransaction(err => {\n        if (err) err = new base.TransactionError(err);\n\n        this._acquiredConnection.removeListener('rollbackTransaction', this._abort);\n\n        this.parent.release(this._acquiredConnection);\n        this._acquiredConnection = null;\n        this._acquiredConfig = null;\n        if (!err) debug('transaction(%d): rolled back', IDS.get(this));\n        callback(err);\n      });\n    });\n  }\n\n}\n\nclass Request extends base.Request {\n  /*\n  Execute specified sql batch.\n  */\n  _batch(batch, callback) {\n    this._isBatch = true;\n\n    this._query(batch, callback);\n  }\n  /*\n  Bulk load.\n  */\n\n\n  _bulk(table, options, callback) {\n    super._bulk(table, options, err => {\n      if (err) return callback(err);\n\n      table._makeBulk();\n\n      if (!table.name) {\n        return callback(new base.RequestError('Table name must be specified for bulk insert.', 'ENAME'));\n      }\n\n      if (table.name.charAt(0) === '@') {\n        return callback(new base.RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'));\n      }\n\n      const errors = [];\n      const errorHandlers = {};\n      let hasReturned = false;\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new base.RequestError(err, 'EREQUEST');\n\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (let event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              this.parent.release(connection);\n            }\n\n            hasReturned = true;\n            callback(err);\n          }\n        } // we must collect errors even in stream mode\n\n\n        errors.push(err);\n      };\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n\n      this.parent.acquire(this, (err, connection) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new base.RequestError('Canceled.', 'ECANCEL'));\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        }; // attach handler to handle multiple error messages\n\n\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n\n        const done = (err, rowCount) => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new base.RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          }\n\n          delete this._cancel;\n          let error;\n\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n\n          if (!hasReturned) {\n            for (let event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n\n            this.parent.release(connection);\n            hasReturned = true;\n\n            if (this.stream) {\n              callback(null, rowCount);\n            } else {\n              callback(error, rowCount);\n            }\n          }\n        };\n\n        const bulk = connection.newBulkLoad(table.path, options, done);\n\n        for (let col of table.columns) {\n          bulk.addColumn(col.name, getTediousType(col.type), {\n            nullable: col.nullable,\n            length: col.length,\n            scale: col.scale,\n            precision: col.precision\n          });\n        }\n\n        for (let row of table.rows) {\n          bulk.addRow(row);\n        }\n\n        if (table.create) {\n          const objectid = table.temporary ? \"tempdb..[\".concat(table.name, \"]\") : table.path;\n          const req = new tds.Request(\"if object_id('\".concat(objectid.replace(/'/g, '\\'\\''), \"') is null \").concat(table.declare()), err => {\n            if (err) return done(err);\n            connection.execBulkLoad(bulk);\n          });\n\n          this._setCurrentRequest(req);\n\n          connection.execSqlBatch(req);\n        } else {\n          connection.execBulkLoad(bulk);\n        }\n      });\n    });\n  }\n  /*\n  Execute specified sql command.\n  */\n\n\n  _query(command, callback) {\n    super._query(command, err => {\n      if (err) return callback(err);\n      const recordsets = [];\n      const errors = [];\n      const errorHandlers = {};\n      const output = {};\n      const rowsAffected = [];\n      let columns = {};\n      let recordset = [];\n      let batchLastRow = null;\n      let batchHasOutput = false;\n      let isChunkedRecordset = false;\n      let chunksBuffer = null;\n      let hasReturned = false;\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new base.RequestError(err, 'EREQUEST');\n\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (let event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              this.parent.release(connection);\n            }\n\n            hasReturned = true;\n            callback(err);\n          }\n        } // we must collect errors even in stream mode\n\n\n        errors.push(err);\n      };\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        let row;\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new base.RequestError('Canceled.', 'ECANCEL'));\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        }; // attach handler to handle multiple error messages\n\n\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n        debug('request(%d): query', IDS.get(this), command);\n        const req = new tds.Request(command, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new base.RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          } // process batch outputs\n\n\n          if (batchHasOutput) {\n            if (!this.stream) batchLastRow = recordsets.pop()[0];\n\n            for (let name in batchLastRow) {\n              let value = batchLastRow[name];\n\n              if (name !== '___return___') {\n                output[name] = value;\n              }\n            }\n          }\n\n          delete this._cancel;\n          let error;\n\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n\n          if (!hasReturned) {\n            for (let event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n\n            this.parent.release(connection);\n            hasReturned = true;\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error);\n            } else {\n              debug('request(%d): completed', IDS.get(this));\n            }\n\n            if (this.stream) {\n              callback(null, null, output, rowsAffected);\n            } else {\n              callback(error, recordsets, output, rowsAffected);\n            }\n          }\n        });\n\n        this._setCurrentRequest(req);\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata);\n          isChunkedRecordset = false;\n\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true;\n            chunksBuffer = [];\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // don't stream recordset with output values in batches\n              if (!columns.___return___) {\n                this.emit('recordset', columns);\n              }\n            } else {\n              this.emit('recordset', columns);\n            }\n          }\n        });\n\n        const doneHandler = (rowCount, more) => {\n          if (rowCount != null) rowsAffected.push(rowCount); // this function is called even when select only set variables so we should skip adding a new recordset\n\n          if (Object.keys(columns).length === 0) return;\n\n          if (isChunkedRecordset) {\n            const concatenatedChunks = chunksBuffer.join('');\n\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (concatenatedChunks === '') {\n                  row = null;\n                } else {\n                  row = JSON.parse(concatenatedChunks);\n                }\n              } catch (ex) {\n                row = null;\n                const ex2 = new base.RequestError(new Error(\"Failed to parse incoming JSON. \".concat(ex.message)), 'EJSON');\n                if (this.stream) this.emit('error', ex2); // we must collect errors even in stream mode\n\n                errors.push(ex2);\n              }\n            } else {\n              row = {};\n              row[Object.keys(columns)[0]] = concatenatedChunks;\n            }\n\n            chunksBuffer = null;\n\n            if (this.stream) {\n              this.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            });\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n\n              value(name) {\n                return Table.fromRecordset(this, name);\n              }\n\n            });\n            recordsets.push(recordset);\n          }\n\n          recordset = [];\n          columns = {};\n        };\n\n        req.on('doneInProc', doneHandler); // doneInProc handlers are used in both queries and batches\n\n        req.on('done', doneHandler); // done handlers are used in batches\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value;\n        });\n        req.on('row', columns => {\n          if (!recordset) recordset = [];\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value);\n          }\n\n          row = {};\n\n          for (let col of columns) {\n            col.value = valueCorrection(col.value, col.metadata);\n            let exi = row[col.metadata.colName];\n\n            if (exi != null) {\n              if (exi instanceof Array) {\n                exi.push(col.value);\n              } else {\n                row[col.metadata.colName] = [exi, col.value];\n              }\n            } else {\n              row[col.metadata.colName] = col.value;\n            }\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // dont stream recordset with output values in batches\n              if (row.___return___) {\n                batchLastRow = row;\n              } else {\n                this.emit('row', row);\n              }\n            } else {\n              this.emit('row', row);\n            }\n          } else {\n            recordset.push(row);\n          }\n        });\n\n        if (this._isBatch) {\n          if (Object.keys(this.parameters).length) {\n            for (let name in this.parameters) {\n              let param = this.parameters[name];\n              let value = getTediousType(param.type).validate(param.value);\n\n              if (value instanceof TypeError) {\n                value = new base.RequestError(\"Validation failed for parameter '\".concat(name, \"'. \").concat(value.message), 'EPARAM');\n                this.parent.release(connection);\n                return callback(value);\n              }\n\n              param.value = value;\n            }\n\n            const declarations = [];\n\n            for (let name in this.parameters) {\n              let param = this.parameters[name];\n              declarations.push(\"@\".concat(name, \" \").concat(declare(param.type, param)));\n            }\n\n            const assigns = [];\n\n            for (let name in this.parameters) {\n              let param = this.parameters[name];\n              assigns.push(\"@\".concat(name, \" = \").concat(cast(param.value, param.type, param)));\n            }\n\n            const selects = [];\n\n            for (let name in this.parameters) {\n              let param = this.parameters[name];\n\n              if (param.io === 2) {\n                selects.push(\"@\".concat(name, \" as [\").concat(name, \"]\"));\n              }\n            }\n\n            batchHasOutput = selects.length > 0;\n            req.sqlTextOrProcedure = \"declare \".concat(declarations.join(', '), \";select \").concat(assigns.join(', '), \";\").concat(req.sqlTextOrProcedure, \";\").concat(batchHasOutput ? \"select 1 as [___return___], \".concat(selects.join(', ')) : '');\n          }\n        } else {\n          for (let name in this.parameters) {\n            let param = this.parameters[name];\n\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            }\n          }\n        }\n\n        try {\n          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req);\n        } catch (error) {\n          handleError(true, connection, error);\n        }\n      });\n    });\n  }\n  /*\n  Execute stored procedure with specified parameters.\n  */\n\n\n  _execute(procedure, callback) {\n    super._execute(procedure, err => {\n      if (err) return callback(err);\n      const recordsets = [];\n      const errors = [];\n      const errorHandlers = {};\n      const output = {};\n      const rowsAffected = [];\n      let columns = {};\n      let recordset = [];\n      let returnValue = 0;\n      let isChunkedRecordset = false;\n      let chunksBuffer = null;\n      let hasReturned = false;\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new base.RequestError(err, 'EREQUEST');\n\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (let event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              this.parent.release(connection);\n            }\n\n            hasReturned = true;\n            callback(err);\n          }\n        } // we must collect errors even in stream mode\n\n\n        errors.push(err);\n      };\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        let row;\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new base.RequestError('Canceled.', 'ECANCEL'));\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        }; // attach handler to handle multiple error messages\n\n\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n        debug('request(%d): execute', IDS.get(this), procedure);\n        const req = new tds.Request(procedure, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new base.RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          }\n\n          delete this._cancel;\n          let error;\n\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n\n          if (!hasReturned) {\n            for (let event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n\n            this.parent.release(connection);\n            hasReturned = true;\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error);\n            } else {\n              debug('request(%d): complete', IDS.get(this));\n            }\n\n            if (this.stream) {\n              callback(null, null, output, returnValue, rowsAffected);\n            } else {\n              callback(error, recordsets, output, returnValue, rowsAffected);\n            }\n          }\n        });\n\n        this._setCurrentRequest(req);\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata);\n          isChunkedRecordset = false;\n\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true;\n            chunksBuffer = [];\n          }\n\n          if (this.stream) this.emit('recordset', columns);\n        });\n        req.on('row', columns => {\n          if (!recordset) recordset = [];\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value);\n          }\n\n          row = {};\n\n          for (let col of columns) {\n            col.value = valueCorrection(col.value, col.metadata);\n            let exi = row[col.metadata.colName];\n\n            if (exi != null) {\n              if (exi instanceof Array) {\n                exi.push(col.value);\n              } else {\n                row[col.metadata.colName] = [exi, col.value];\n              }\n            } else {\n              row[col.metadata.colName] = col.value;\n            }\n          }\n\n          if (this.stream) {\n            this.emit('row', row);\n          } else {\n            recordset.push(row);\n          }\n        });\n        req.on('doneInProc', (rowCount, more) => {\n          if (rowCount != null) rowsAffected.push(rowCount); // filter empty recordsets when NOCOUNT is OFF\n\n          if (Object.keys(columns).length === 0) return;\n\n          if (isChunkedRecordset) {\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (chunksBuffer.length === 0) {\n                  row = null;\n                } else {\n                  row = JSON.parse(chunksBuffer.join(''));\n                }\n              } catch (ex) {\n                row = null;\n                const ex2 = new base.RequestError(new Error(\"Failed to parse incoming JSON. \".concat(ex.message)), 'EJSON');\n                if (this.stream) this.emit('error', ex2); // we must collect errors even in stream mode\n\n                errors.push(ex2);\n              }\n            } else {\n              row = {};\n              row[Object.keys(columns)[0]] = chunksBuffer.join('');\n            }\n\n            chunksBuffer = null;\n\n            if (this.stream) {\n              this.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            });\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n\n              value(name) {\n                return Table.fromRecordset(this, name);\n              }\n\n            });\n            recordsets.push(recordset);\n          }\n\n          recordset = [];\n          columns = {};\n        });\n        req.on('doneProc', (rowCount, more, returnStatus) => {\n          returnValue = returnStatus;\n        });\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value;\n        });\n\n        for (let name in this.parameters) {\n          let param = this.parameters[name];\n\n          if (param.io === 1) {\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n              length: param.length,\n              scale: param.scale,\n              precision: param.precision\n            });\n          } else {\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n              length: param.length,\n              scale: param.scale,\n              precision: param.precision\n            });\n          }\n        }\n\n        connection.callProcedure(req);\n      });\n    });\n  }\n\n  _pause() {\n    super._pause();\n\n    if (this._currentRequest) {\n      this._currentRequest.pause();\n    }\n  }\n\n  _resume() {\n    super._resume();\n\n    if (this._currentRequest) {\n      this._currentRequest.resume();\n    }\n  }\n\n}\n\nmodule.exports = Object.assign({\n  ConnectionPool,\n  Transaction,\n  Request,\n  PreparedStatement: base.PreparedStatement\n}, base.exports);\nObject.defineProperty(module.exports, 'Promise', {\n  enumerable: true,\n  get: () => {\n    return base.Promise;\n  },\n  set: value => {\n    base.Promise = value;\n  }\n});\nbase.driver.name = 'tedious';\nbase.driver.ConnectionPool = ConnectionPool;\nbase.driver.Transaction = Transaction;\nbase.driver.Request = Request;","map":null,"metadata":{},"sourceType":"script"}