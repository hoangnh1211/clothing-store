{"ast":null,"code":"'use strict';\n\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(\"Naming collision between attribute '\".concat(association.as, \"'\") + \" and association '\".concat(association.as, \"' on model \").concat(association.source.name) + '. To remedy this, change either foreignKey or as in your association definition');\n  }\n}\n\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behavior\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = Object.keys(source.primaryKeys).map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      if (source._schema) {\n        newAttribute.references = {\n          model: source.sequelize.getQueryInterface().QueryGenerator.addSchema({\n            tableName: source.tableName,\n            _schema: source._schema,\n            _schemaDelimiter: source._schemaDelimiter\n          })\n        };\n      } else {\n        newAttribute.references = {\n          model: source.tableName\n        };\n      }\n\n      newAttribute.references.key = key || primaryKeys[0];\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\n\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n *\n * @param {Object} association instance\n * @param {Object} obj Model prototype\n * @param {Array} methods Method names to inject\n * @param {Object} aliases Mapping between model and association method names\n *\n */\n\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function () {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\n\nexports.mixinMethods = mixinMethods;","map":null,"metadata":{},"sourceType":"script"}