{"ast":null,"code":"'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\n\nconst SequelizeErrors = require('../../errors');\n\nconst Promise = require('../../promise');\n\nconst _require = require('../../utils/logger'),\n      logger = _require.logger;\n\nconst DataTypes = require('../../data-types').mysql;\n\nconst momentTz = require('moment-timezone');\n\nconst debug = logger.debugContext('connection:mysql');\n\nconst parserStore = require('../parserStore')('mysql');\n/**\n * MySQL Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\n *\n * @extends AbstractConnectionManager\n * @returns Class<ConnectionManager>\n * @private\n */\n\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mysql2');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n\n    return next();\n  }\n  /**\n   * Connect with MySQL database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {Object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n\n\n  connect(config) {\n    const connectionConfig = Object.assign({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: '-FOUND_ROWS',\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true\n    }, config.dialectOptions);\n    return new Promise((resolve, reject) => {\n      const connection = this.lib.createConnection(connectionConfig);\n\n      const errorHandler = e => {\n        // clean up connect & error event if there is error\n        connection.removeListener('connect', connectHandler);\n        connection.removeListener('error', connectHandler);\n        reject(e);\n      };\n\n      const connectHandler = () => {\n        // clean up error event if connected\n        connection.removeListener('error', errorHandler);\n        resolve(connection);\n      }; // don't use connection.once for error event handling here\n      // mysql2 emit error two times in case handshake was failed\n      // first error is protocol_lost and second is timeout\n      // if we will use `once.error` node process will crash on 2nd error emit\n\n\n      connection.on('error', errorHandler);\n      connection.once('connect', connectHandler);\n    }).tap(() => {\n      debug('connection acquired');\n    }).then(connection => {\n      connection.on('error', error => {\n        switch (error.code) {\n          case 'ESOCKET':\n          case 'ECONNRESET':\n          case 'EPIPE':\n          case 'PROTOCOL_CONNECTION_LOST':\n            this.pool.destroy(connection);\n        }\n      });\n      return new Promise((resolve, reject) => {\n        if (!this.sequelize.config.keepDefaultTimezone) {\n          // set timezone for this connection\n          // but named timezone are not directly supported in mysql, so get its offset first\n          let tzOffset = this.sequelize.options.timezone;\n          tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n          return connection.query(\"SET time_zone = '\".concat(tzOffset, \"'\"), err => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(connection);\n            }\n          });\n        } // return connection without executing SET time_zone query\n\n\n        resolve(connection);\n      });\n    }).catch(err => {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n\n        case 'ER_ACCESS_DENIED_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n\n        case 'EHOSTUNREACH':\n          throw new SequelizeErrors.HostNotReachableError(err);\n\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    });\n  }\n\n  disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (connection._closing) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return Promise.resolve();\n    }\n\n    return Promise.fromCallback(callback => connection.end(callback));\n  }\n\n  validate(connection) {\n    return connection && !connection._fatalError && !connection._protocolError && !connection._closing && !connection.stream.destroyed;\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":null,"metadata":{},"sourceType":"script"}