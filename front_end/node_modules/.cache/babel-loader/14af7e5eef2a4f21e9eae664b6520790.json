{"ast":null,"code":"module.exports = MultiPoint;\n\nvar util = require('util');\n\nvar Types = require('./types');\n\nvar Geometry = require('./geometry');\n\nvar Point = require('./point');\n\nvar BinaryWriter = require('./binarywriter');\n\nfunction MultiPoint(points, srid) {\n  Geometry.call(this);\n  this.points = points || [];\n  this.srid = srid;\n\n  if (this.points.length > 0) {\n    this.hasZ = this.points[0].hasZ;\n    this.hasM = this.points[0].hasM;\n  }\n}\n\nutil.inherits(MultiPoint, Geometry);\n\nMultiPoint.Z = function (points, srid) {\n  var multiPoint = new MultiPoint(points, srid);\n  multiPoint.hasZ = true;\n  return multiPoint;\n};\n\nMultiPoint.M = function (points, srid) {\n  var multiPoint = new MultiPoint(points, srid);\n  multiPoint.hasM = true;\n  return multiPoint;\n};\n\nMultiPoint.ZM = function (points, srid) {\n  var multiPoint = new MultiPoint(points, srid);\n  multiPoint.hasZ = true;\n  multiPoint.hasM = true;\n  return multiPoint;\n};\n\nMultiPoint._parseWkt = function (value, options) {\n  var multiPoint = new MultiPoint();\n  multiPoint.srid = options.srid;\n  multiPoint.hasZ = options.hasZ;\n  multiPoint.hasM = options.hasM;\n  if (value.isMatch(['EMPTY'])) return multiPoint;\n  value.expectGroupStart();\n  multiPoint.points.push.apply(multiPoint.points, value.matchCoordinates(options));\n  value.expectGroupEnd();\n  return multiPoint;\n};\n\nMultiPoint._parseWkb = function (value, options) {\n  var multiPoint = new MultiPoint();\n  multiPoint.srid = options.srid;\n  multiPoint.hasZ = options.hasZ;\n  multiPoint.hasM = options.hasM;\n  var pointCount = value.readUInt32();\n\n  for (var i = 0; i < pointCount; i++) multiPoint.points.push(Geometry.parse(value, options));\n\n  return multiPoint;\n};\n\nMultiPoint._parseTwkb = function (value, options) {\n  var multiPoint = new MultiPoint();\n  multiPoint.hasZ = options.hasZ;\n  multiPoint.hasM = options.hasM;\n  if (options.isEmpty) return multiPoint;\n  var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);\n  var pointCount = value.readVarInt();\n\n  for (var i = 0; i < pointCount; i++) multiPoint.points.push(Point._readTwkbPoint(value, options, previousPoint));\n\n  return multiPoint;\n};\n\nMultiPoint._parseGeoJSON = function (value) {\n  var multiPoint = new MultiPoint();\n  if (value.coordinates.length > 0) multiPoint.hasZ = value.coordinates[0].length > 2;\n\n  for (var i = 0; i < value.coordinates.length; i++) multiPoint.points.push(Point._parseGeoJSON({\n    coordinates: value.coordinates[i]\n  }));\n\n  return multiPoint;\n};\n\nMultiPoint.prototype.toWkt = function () {\n  if (this.points.length === 0) return this._getWktType(Types.wkt.MultiPoint, true);\n  var wkt = this._getWktType(Types.wkt.MultiPoint, false) + '(';\n\n  for (var i = 0; i < this.points.length; i++) wkt += this._getWktCoordinate(this.points[i]) + ',';\n\n  wkt = wkt.slice(0, -1);\n  wkt += ')';\n  return wkt;\n};\n\nMultiPoint.prototype.toWkb = function () {\n  var wkb = new BinaryWriter(this._getWkbSize());\n  wkb.writeInt8(1);\n\n  this._writeWkbType(wkb, Types.wkb.MultiPoint);\n\n  wkb.writeUInt32LE(this.points.length);\n\n  for (var i = 0; i < this.points.length; i++) wkb.writeBuffer(this.points[i].toWkb({\n    srid: this.srid\n  }));\n\n  return wkb.buffer;\n};\n\nMultiPoint.prototype.toTwkb = function () {\n  var twkb = new BinaryWriter(0, true);\n  var precision = Geometry.getTwkbPrecision(5, 0, 0);\n  var isEmpty = this.points.length === 0;\n\n  this._writeTwkbHeader(twkb, Types.wkb.MultiPoint, precision, isEmpty);\n\n  if (this.points.length > 0) {\n    twkb.writeVarInt(this.points.length);\n    var previousPoint = new Point(0, 0, 0, 0);\n\n    for (var i = 0; i < this.points.length; i++) this.points[i]._writeTwkbPoint(twkb, precision, previousPoint);\n  }\n\n  return twkb.buffer;\n};\n\nMultiPoint.prototype._getWkbSize = function () {\n  var coordinateSize = 16;\n  if (this.hasZ) coordinateSize += 8;\n  if (this.hasM) coordinateSize += 8;\n  coordinateSize += 5;\n  return 1 + 4 + 4 + this.points.length * coordinateSize;\n};\n\nMultiPoint.prototype.toGeoJSON = function (options) {\n  var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);\n  geoJSON.type = Types.geoJSON.MultiPoint;\n  geoJSON.coordinates = [];\n\n  for (var i = 0; i < this.points.length; i++) geoJSON.coordinates.push(this.points[i].toGeoJSON().coordinates);\n\n  return geoJSON;\n};","map":null,"metadata":{},"sourceType":"script"}