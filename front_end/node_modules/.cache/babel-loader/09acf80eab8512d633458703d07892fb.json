{"ast":null,"code":"module.exports = MultiLineString;\n\nvar util = require('util');\n\nvar Types = require('./types');\n\nvar Geometry = require('./geometry');\n\nvar Point = require('./point');\n\nvar LineString = require('./linestring');\n\nvar BinaryWriter = require('./binarywriter');\n\nfunction MultiLineString(lineStrings, srid) {\n  Geometry.call(this);\n  this.lineStrings = lineStrings || [];\n  this.srid = srid;\n\n  if (this.lineStrings.length > 0) {\n    this.hasZ = this.lineStrings[0].hasZ;\n    this.hasM = this.lineStrings[0].hasM;\n  }\n}\n\nutil.inherits(MultiLineString, Geometry);\n\nMultiLineString.Z = function (lineStrings, srid) {\n  var multiLineString = new MultiLineString(lineStrings, srid);\n  multiLineString.hasZ = true;\n  return multiLineString;\n};\n\nMultiLineString.M = function (lineStrings, srid) {\n  var multiLineString = new MultiLineString(lineStrings, srid);\n  multiLineString.hasM = true;\n  return multiLineString;\n};\n\nMultiLineString.ZM = function (lineStrings, srid) {\n  var multiLineString = new MultiLineString(lineStrings, srid);\n  multiLineString.hasZ = true;\n  multiLineString.hasM = true;\n  return multiLineString;\n};\n\nMultiLineString._parseWkt = function (value, options) {\n  var multiLineString = new MultiLineString();\n  multiLineString.srid = options.srid;\n  multiLineString.hasZ = options.hasZ;\n  multiLineString.hasM = options.hasM;\n  if (value.isMatch(['EMPTY'])) return multiLineString;\n  value.expectGroupStart();\n\n  do {\n    value.expectGroupStart();\n    multiLineString.lineStrings.push(new LineString(value.matchCoordinates(options)));\n    value.expectGroupEnd();\n  } while (value.isMatch([',']));\n\n  value.expectGroupEnd();\n  return multiLineString;\n};\n\nMultiLineString._parseWkb = function (value, options) {\n  var multiLineString = new MultiLineString();\n  multiLineString.srid = options.srid;\n  multiLineString.hasZ = options.hasZ;\n  multiLineString.hasM = options.hasM;\n  var lineStringCount = value.readUInt32();\n\n  for (var i = 0; i < lineStringCount; i++) multiLineString.lineStrings.push(Geometry.parse(value, options));\n\n  return multiLineString;\n};\n\nMultiLineString._parseTwkb = function (value, options) {\n  var multiLineString = new MultiLineString();\n  multiLineString.hasZ = options.hasZ;\n  multiLineString.hasM = options.hasM;\n  if (options.isEmpty) return multiLineString;\n  var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);\n  var lineStringCount = value.readVarInt();\n\n  for (var i = 0; i < lineStringCount; i++) {\n    var lineString = new LineString();\n    lineString.hasZ = options.hasZ;\n    lineString.hasM = options.hasM;\n    var pointCount = value.readVarInt();\n\n    for (var j = 0; j < pointCount; j++) lineString.points.push(Point._readTwkbPoint(value, options, previousPoint));\n\n    multiLineString.lineStrings.push(lineString);\n  }\n\n  return multiLineString;\n};\n\nMultiLineString._parseGeoJSON = function (value) {\n  var multiLineString = new MultiLineString();\n  if (value.coordinates.length > 0 && value.coordinates[0].length > 0) multiLineString.hasZ = value.coordinates[0][0].length > 2;\n\n  for (var i = 0; i < value.coordinates.length; i++) multiLineString.lineStrings.push(LineString._parseGeoJSON({\n    coordinates: value.coordinates[i]\n  }));\n\n  return multiLineString;\n};\n\nMultiLineString.prototype.toWkt = function () {\n  if (this.lineStrings.length === 0) return this._getWktType(Types.wkt.MultiLineString, true);\n  var wkt = this._getWktType(Types.wkt.MultiLineString, false) + '(';\n\n  for (var i = 0; i < this.lineStrings.length; i++) wkt += this.lineStrings[i]._toInnerWkt() + ',';\n\n  wkt = wkt.slice(0, -1);\n  wkt += ')';\n  return wkt;\n};\n\nMultiLineString.prototype.toWkb = function () {\n  var wkb = new BinaryWriter(this._getWkbSize());\n  wkb.writeInt8(1);\n\n  this._writeWkbType(wkb, Types.wkb.MultiLineString);\n\n  wkb.writeUInt32LE(this.lineStrings.length);\n\n  for (var i = 0; i < this.lineStrings.length; i++) wkb.writeBuffer(this.lineStrings[i].toWkb({\n    srid: this.srid\n  }));\n\n  return wkb.buffer;\n};\n\nMultiLineString.prototype.toTwkb = function () {\n  var twkb = new BinaryWriter(0, true);\n  var precision = Geometry.getTwkbPrecision(5, 0, 0);\n  var isEmpty = this.lineStrings.length === 0;\n\n  this._writeTwkbHeader(twkb, Types.wkb.MultiLineString, precision, isEmpty);\n\n  if (this.lineStrings.length > 0) {\n    twkb.writeVarInt(this.lineStrings.length);\n    var previousPoint = new Point(0, 0, 0, 0);\n\n    for (var i = 0; i < this.lineStrings.length; i++) {\n      twkb.writeVarInt(this.lineStrings[i].points.length);\n\n      for (var j = 0; j < this.lineStrings[i].points.length; j++) this.lineStrings[i].points[j]._writeTwkbPoint(twkb, precision, previousPoint);\n    }\n  }\n\n  return twkb.buffer;\n};\n\nMultiLineString.prototype._getWkbSize = function () {\n  var size = 1 + 4 + 4;\n\n  for (var i = 0; i < this.lineStrings.length; i++) size += this.lineStrings[i]._getWkbSize();\n\n  return size;\n};\n\nMultiLineString.prototype.toGeoJSON = function (options) {\n  var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);\n  geoJSON.type = Types.geoJSON.MultiLineString;\n  geoJSON.coordinates = [];\n\n  for (var i = 0; i < this.lineStrings.length; i++) geoJSON.coordinates.push(this.lineStrings[i].toGeoJSON().coordinates);\n\n  return geoJSON;\n};","map":null,"metadata":{},"sourceType":"script"}