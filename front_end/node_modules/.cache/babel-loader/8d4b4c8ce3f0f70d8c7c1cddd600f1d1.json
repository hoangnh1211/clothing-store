{"ast":null,"code":"\"use strict\";\n\nconst bigint = require('./bigint');\n\nconst SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nconst SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nconst UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\nconst ZERO_LENGTH_BUFFER = Buffer.alloc(0);\n/*\n  A Buffer-like class that tracks position.\n\n  As values are written, the position advances by the size of the written data.\n  When writing, automatically allocates new buffers if there's not enough space.\n */\n\nmodule.exports = class WritableTrackingBuffer {\n  constructor(initialSize, encoding, doubleSizeGrowth) {\n    this.initialSize = initialSize;\n    this.encoding = encoding || 'ucs2';\n    this.doubleSizeGrowth = doubleSizeGrowth || false;\n    this.buffer = Buffer.alloc(this.initialSize, 0);\n    this.compositeBuffer = ZERO_LENGTH_BUFFER;\n    this.position = 0;\n  } // $FlowFixMe: Flow does not like getter/setters that have side-effects.\n\n\n  get data() {\n    this.newBuffer(0);\n    return this.compositeBuffer;\n  }\n\n  copyFrom(buffer) {\n    const length = buffer.length;\n    this.makeRoomFor(length);\n    buffer.copy(this.buffer, this.position);\n    this.position += length;\n  }\n\n  makeRoomFor(requiredLength) {\n    if (this.buffer.length - this.position < requiredLength) {\n      if (this.doubleSizeGrowth) {\n        let size = Math.max(128, this.buffer.length * 2);\n\n        while (size < requiredLength) {\n          size *= 2;\n        }\n\n        this.newBuffer(size);\n      } else {\n        this.newBuffer(requiredLength);\n      }\n    }\n  }\n\n  newBuffer(size) {\n    const buffer = this.buffer.slice(0, this.position);\n    this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);\n    this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);\n    this.position = 0;\n  }\n\n  writeUInt8(value) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt8(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt16LE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16LE(value, this.position);\n    this.position += length;\n  }\n\n  writeUShort(value) {\n    this.writeUInt16LE(value);\n  }\n\n  writeUInt16BE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16BE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt24LE(value) {\n    const length = 3;\n    this.makeRoomFor(length);\n    this.buffer[this.position + 2] = value >>> 16 & 0xff;\n    this.buffer[this.position + 1] = value >>> 8 & 0xff;\n    this.buffer[this.position] = value & 0xff;\n    this.position += length;\n  }\n\n  writeUInt32LE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt64LE(value) {\n    const buf = bigint.numberToInt64LE(value);\n    this.copyFrom(buf);\n  }\n\n  writeUInt32BE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32BE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt40LE(value) {\n    // inspired by https://github.com/dpw/node-buffer-more-ints\n    this.writeInt32LE(value & -1);\n    this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));\n  }\n\n  writeUInt64LE(value) {\n    this.writeInt32LE(value & -1);\n    this.writeUInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n  }\n\n  writeInt8(value) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeInt8(value, this.position);\n    this.position += length;\n  }\n\n  writeInt16LE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt16BE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16BE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt32LE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt32BE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32BE(value, this.position);\n    this.position += length;\n  }\n\n  writeFloatLE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeFloatLE(value, this.position);\n    this.position += length;\n  }\n\n  writeDoubleLE(value) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeDoubleLE(value, this.position);\n    this.position += length;\n  }\n\n  writeString(value, encoding) {\n    if (encoding == undefined) {\n      encoding = this.encoding;\n    }\n\n    const length = Buffer.byteLength(value, encoding);\n    this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n    this.buffer.write(value, this.position, encoding);\n    this.position += length;\n  }\n\n  writeBVarchar(value, encoding) {\n    this.writeUInt8(value.length);\n    this.writeString(value, encoding);\n  }\n\n  writeUsVarchar(value, encoding) {\n    this.writeUInt16LE(value.length);\n    this.writeString(value, encoding);\n  } // TODO: Figure out what types are passed in other than `Buffer`\n\n\n  writeUsVarbyte(value, encoding) {\n    if (encoding == undefined) {\n      encoding = this.encoding;\n    }\n\n    let length;\n\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    }\n\n    this.writeUInt16LE(length);\n\n    if (value instanceof Buffer) {\n      this.writeBuffer(value);\n    } else {\n      this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n      this.buffer.write(value, this.position, encoding);\n      this.position += length;\n    }\n  }\n\n  writePLPBody(value, encoding) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    let length;\n\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    } // Length of all chunks.\n    // this.writeUInt64LE(length);\n    // unknown seems to work better here - might revisit later.\n\n\n    this.writeBuffer(UNKNOWN_PLP_LEN); // In the UNKNOWN_PLP_LEN case, the data is represented as a series of zero or more chunks.\n\n    if (length > 0) {\n      // One chunk.\n      this.writeUInt32LE(length);\n\n      if (value instanceof Buffer) {\n        this.writeBuffer(value);\n      } else {\n        this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n        this.buffer.write(value, this.position, encoding);\n        this.position += length;\n      }\n    } // PLP_TERMINATOR (no more chunks).\n\n\n    this.writeUInt32LE(0);\n  }\n\n  writeBuffer(value) {\n    const length = value.length;\n    this.makeRoomFor(length);\n    value.copy(this.buffer, this.position);\n    this.position += length;\n  }\n\n  writeMoney(value) {\n    this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n    this.writeInt32LE(value & -1);\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}