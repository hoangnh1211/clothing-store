{"ast":null,"code":"module.exports = Geometry;\n\nvar Types = require('./types');\n\nvar Point = require('./point');\n\nvar LineString = require('./linestring');\n\nvar Polygon = require('./polygon');\n\nvar MultiPoint = require('./multipoint');\n\nvar MultiLineString = require('./multilinestring');\n\nvar MultiPolygon = require('./multipolygon');\n\nvar GeometryCollection = require('./geometrycollection');\n\nvar BinaryReader = require('./binaryreader');\n\nvar BinaryWriter = require('./binarywriter');\n\nvar WktParser = require('./wktparser');\n\nvar ZigZag = require('./zigzag.js');\n\nfunction Geometry() {\n  this.srid = undefined;\n  this.hasZ = false;\n  this.hasM = false;\n}\n\nGeometry.parse = function (value, options) {\n  var valueType = typeof value;\n  if (valueType === 'string' || value instanceof WktParser) return Geometry._parseWkt(value);else if (Buffer.isBuffer(value) || value instanceof BinaryReader) return Geometry._parseWkb(value, options);else throw new Error('first argument must be a string or Buffer');\n};\n\nGeometry._parseWkt = function (value) {\n  var wktParser, srid;\n  if (value instanceof WktParser) wktParser = value;else wktParser = new WktParser(value);\n  var match = wktParser.matchRegex([/^SRID=(\\d+);/]);\n  if (match) srid = parseInt(match[1], 10);\n  var geometryType = wktParser.matchType();\n  var dimension = wktParser.matchDimension();\n  var options = {\n    srid: srid,\n    hasZ: dimension.hasZ,\n    hasM: dimension.hasM\n  };\n\n  switch (geometryType) {\n    case Types.wkt.Point:\n      return Point._parseWkt(wktParser, options);\n\n    case Types.wkt.LineString:\n      return LineString._parseWkt(wktParser, options);\n\n    case Types.wkt.Polygon:\n      return Polygon._parseWkt(wktParser, options);\n\n    case Types.wkt.MultiPoint:\n      return MultiPoint._parseWkt(wktParser, options);\n\n    case Types.wkt.MultiLineString:\n      return MultiLineString._parseWkt(wktParser, options);\n\n    case Types.wkt.MultiPolygon:\n      return MultiPolygon._parseWkt(wktParser, options);\n\n    case Types.wkt.GeometryCollection:\n      return GeometryCollection._parseWkt(wktParser, options);\n  }\n};\n\nGeometry._parseWkb = function (value, parentOptions) {\n  var binaryReader,\n      wkbType,\n      geometryType,\n      options = {};\n  if (value instanceof BinaryReader) binaryReader = value;else binaryReader = new BinaryReader(value);\n  binaryReader.isBigEndian = !binaryReader.readInt8();\n  wkbType = binaryReader.readUInt32();\n  options.hasSrid = (wkbType & 0x20000000) === 0x20000000;\n  options.isEwkb = wkbType & 0x20000000 || wkbType & 0x40000000 || wkbType & 0x80000000;\n  if (options.hasSrid) options.srid = binaryReader.readUInt32();\n  options.hasZ = false;\n  options.hasM = false;\n\n  if (!options.isEwkb && (!parentOptions || !parentOptions.isEwkb)) {\n    if (wkbType >= 1000 && wkbType < 2000) {\n      options.hasZ = true;\n      geometryType = wkbType - 1000;\n    } else if (wkbType >= 2000 && wkbType < 3000) {\n      options.hasM = true;\n      geometryType = wkbType - 2000;\n    } else if (wkbType >= 3000 && wkbType < 4000) {\n      options.hasZ = true;\n      options.hasM = true;\n      geometryType = wkbType - 3000;\n    } else {\n      geometryType = wkbType;\n    }\n  } else {\n    if (wkbType & 0x80000000) options.hasZ = true;\n    if (wkbType & 0x40000000) options.hasM = true;\n    geometryType = wkbType & 0xF;\n  }\n\n  switch (geometryType) {\n    case Types.wkb.Point:\n      return Point._parseWkb(binaryReader, options);\n\n    case Types.wkb.LineString:\n      return LineString._parseWkb(binaryReader, options);\n\n    case Types.wkb.Polygon:\n      return Polygon._parseWkb(binaryReader, options);\n\n    case Types.wkb.MultiPoint:\n      return MultiPoint._parseWkb(binaryReader, options);\n\n    case Types.wkb.MultiLineString:\n      return MultiLineString._parseWkb(binaryReader, options);\n\n    case Types.wkb.MultiPolygon:\n      return MultiPolygon._parseWkb(binaryReader, options);\n\n    case Types.wkb.GeometryCollection:\n      return GeometryCollection._parseWkb(binaryReader, options);\n\n    default:\n      throw new Error('GeometryType ' + geometryType + ' not supported');\n  }\n};\n\nGeometry.parseTwkb = function (value) {\n  var binaryReader,\n      options = {};\n  if (value instanceof BinaryReader) binaryReader = value;else binaryReader = new BinaryReader(value);\n  var type = binaryReader.readUInt8();\n  var metadataHeader = binaryReader.readUInt8();\n  var geometryType = type & 0x0F;\n  options.precision = ZigZag.decode(type >> 4);\n  options.precisionFactor = Math.pow(10, options.precision);\n  options.hasBoundingBox = metadataHeader >> 0 & 1;\n  options.hasSizeAttribute = metadataHeader >> 1 & 1;\n  options.hasIdList = metadataHeader >> 2 & 1;\n  options.hasExtendedPrecision = metadataHeader >> 3 & 1;\n  options.isEmpty = metadataHeader >> 4 & 1;\n\n  if (options.hasExtendedPrecision) {\n    var extendedPrecision = binaryReader.readUInt8();\n    options.hasZ = (extendedPrecision & 0x01) === 0x01;\n    options.hasM = (extendedPrecision & 0x02) === 0x02;\n    options.zPrecision = ZigZag.decode((extendedPrecision & 0x1C) >> 2);\n    options.zPrecisionFactor = Math.pow(10, options.zPrecision);\n    options.mPrecision = ZigZag.decode((extendedPrecision & 0xE0) >> 5);\n    options.mPrecisionFactor = Math.pow(10, options.mPrecision);\n  } else {\n    options.hasZ = false;\n    options.hasM = false;\n  }\n\n  if (options.hasSizeAttribute) binaryReader.readVarInt();\n\n  if (options.hasBoundingBox) {\n    var dimensions = 2;\n    if (options.hasZ) dimensions++;\n    if (options.hasM) dimensions++;\n\n    for (var i = 0; i < dimensions; i++) {\n      binaryReader.readVarInt();\n      binaryReader.readVarInt();\n    }\n  }\n\n  switch (geometryType) {\n    case Types.wkb.Point:\n      return Point._parseTwkb(binaryReader, options);\n\n    case Types.wkb.LineString:\n      return LineString._parseTwkb(binaryReader, options);\n\n    case Types.wkb.Polygon:\n      return Polygon._parseTwkb(binaryReader, options);\n\n    case Types.wkb.MultiPoint:\n      return MultiPoint._parseTwkb(binaryReader, options);\n\n    case Types.wkb.MultiLineString:\n      return MultiLineString._parseTwkb(binaryReader, options);\n\n    case Types.wkb.MultiPolygon:\n      return MultiPolygon._parseTwkb(binaryReader, options);\n\n    case Types.wkb.GeometryCollection:\n      return GeometryCollection._parseTwkb(binaryReader, options);\n\n    default:\n      throw new Error('GeometryType ' + geometryType + ' not supported');\n  }\n};\n\nGeometry.parseGeoJSON = function (value) {\n  return Geometry._parseGeoJSON(value);\n};\n\nGeometry._parseGeoJSON = function (value, isSubGeometry) {\n  var geometry;\n\n  switch (value.type) {\n    case Types.geoJSON.Point:\n      geometry = Point._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.LineString:\n      geometry = LineString._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.Polygon:\n      geometry = Polygon._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.MultiPoint:\n      geometry = MultiPoint._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.MultiLineString:\n      geometry = MultiLineString._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.MultiPolygon:\n      geometry = MultiPolygon._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.GeometryCollection:\n      geometry = GeometryCollection._parseGeoJSON(value);\n      break;\n\n    default:\n      throw new Error('GeometryType ' + value.type + ' not supported');\n  }\n\n  if (value.crs && value.crs.type && value.crs.type === 'name' && value.crs.properties && value.crs.properties.name) {\n    var crs = value.crs.properties.name;\n    if (crs.indexOf('EPSG:') === 0) geometry.srid = parseInt(crs.substring(5));else if (crs.indexOf('urn:ogc:def:crs:EPSG::') === 0) geometry.srid = parseInt(crs.substring(22));else throw new Error('Unsupported crs: ' + crs);\n  } else if (!isSubGeometry) {\n    geometry.srid = 4326;\n  }\n\n  return geometry;\n};\n\nGeometry.prototype.toEwkt = function () {\n  return 'SRID=' + this.srid + ';' + this.toWkt();\n};\n\nGeometry.prototype.toEwkb = function () {\n  var ewkb = new BinaryWriter(this._getWkbSize() + 4);\n  var wkb = this.toWkb();\n  ewkb.writeInt8(1);\n  ewkb.writeUInt32LE((wkb.slice(1, 5).readUInt32LE(0) | 0x20000000) >>> 0, true);\n  ewkb.writeUInt32LE(this.srid);\n  ewkb.writeBuffer(wkb.slice(5));\n  return ewkb.buffer;\n};\n\nGeometry.prototype._getWktType = function (wktType, isEmpty) {\n  var wkt = wktType;\n  if (this.hasZ && this.hasM) wkt += ' ZM ';else if (this.hasZ) wkt += ' Z ';else if (this.hasM) wkt += ' M ';\n  if (isEmpty && !this.hasZ && !this.hasM) wkt += ' ';\n  if (isEmpty) wkt += 'EMPTY';\n  return wkt;\n};\n\nGeometry.prototype._getWktCoordinate = function (point) {\n  var coordinates = point.x + ' ' + point.y;\n  if (this.hasZ) coordinates += ' ' + point.z;\n  if (this.hasM) coordinates += ' ' + point.m;\n  return coordinates;\n};\n\nGeometry.prototype._writeWkbType = function (wkb, geometryType, parentOptions) {\n  var dimensionType = 0;\n\n  if (typeof this.srid === 'undefined' && (!parentOptions || typeof parentOptions.srid === 'undefined')) {\n    if (this.hasZ && this.hasM) dimensionType += 3000;else if (this.hasZ) dimensionType += 1000;else if (this.hasM) dimensionType += 2000;\n  } else {\n    if (this.hasZ) dimensionType |= 0x80000000;\n    if (this.hasM) dimensionType |= 0x40000000;\n  }\n\n  wkb.writeUInt32LE(dimensionType + geometryType >>> 0, true);\n};\n\nGeometry.getTwkbPrecision = function (xyPrecision, zPrecision, mPrecision) {\n  return {\n    xy: xyPrecision,\n    z: zPrecision,\n    m: mPrecision,\n    xyFactor: Math.pow(10, xyPrecision),\n    zFactor: Math.pow(10, zPrecision),\n    mFactor: Math.pow(10, mPrecision)\n  };\n};\n\nGeometry.prototype._writeTwkbHeader = function (twkb, geometryType, precision, isEmpty) {\n  var type = (ZigZag.encode(precision.xy) << 4) + geometryType;\n  var metadataHeader = (this.hasZ || this.hasM) << 3;\n  metadataHeader += isEmpty << 4;\n  twkb.writeUInt8(type);\n  twkb.writeUInt8(metadataHeader);\n\n  if (this.hasZ || this.hasM) {\n    var extendedPrecision = 0;\n    if (this.hasZ) extendedPrecision |= 0x1;\n    if (this.hasM) extendedPrecision |= 0x2;\n    twkb.writeUInt8(extendedPrecision);\n  }\n};\n\nGeometry.prototype.toGeoJSON = function (options) {\n  var geoJSON = {};\n\n  if (this.srid) {\n    if (options) {\n      if (options.shortCrs) {\n        geoJSON.crs = {\n          type: 'name',\n          properties: {\n            name: 'EPSG:' + this.srid\n          }\n        };\n      } else if (options.longCrs) {\n        geoJSON.crs = {\n          type: 'name',\n          properties: {\n            name: 'urn:ogc:def:crs:EPSG::' + this.srid\n          }\n        };\n      }\n    }\n  }\n\n  return geoJSON;\n};","map":null,"metadata":{},"sourceType":"script"}