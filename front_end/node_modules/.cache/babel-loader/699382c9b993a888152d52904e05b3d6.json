{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst util = require('util');\n\nconst Op = require('../../operators');\n\nconst jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst jsonOperatorRegex = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst foreignKeyFields = 'CONSTRAINT_NAME as constraint_name,' + 'CONSTRAINT_NAME as constraintName,' + 'CONSTRAINT_SCHEMA as constraintSchema,' + 'CONSTRAINT_SCHEMA as constraintCatalog,' + 'TABLE_NAME as tableName,' + 'TABLE_SCHEMA as tableSchema,' + 'TABLE_SCHEMA as tableCatalog,' + 'COLUMN_NAME as columnName,' + 'REFERENCED_TABLE_SCHEMA as referencedTableSchema,' + 'REFERENCED_TABLE_SCHEMA as referencedTableCatalog,' + 'REFERENCED_TABLE_NAME as referencedTableName,' + 'REFERENCED_COLUMN_NAME as referencedColumnName';\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = Object.assign({}, this.OperatorMap, {\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    });\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      charset: null,\n      collate: null\n    }, options || {});\n    const database = this.quoteIdentifier(databaseName);\n    const charset = options.charset ? \" DEFAULT CHARACTER SET \".concat(this.escape(options.charset)) : '';\n    const collate = options.collate ? \" DEFAULT COLLATE \".concat(this.escape(options.collate)) : '';\n    return \"\".concat(\"CREATE DATABASE IF NOT EXISTS \".concat(database).concat(charset).concat(collate).trim(), \";\");\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return \"DROP DATABASE IF EXISTS \".concat(this.quoteIdentifier(databaseName).trim(), \";\");\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = Object.assign({\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null\n    }, options || {});\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1].replace('PRIMARY KEY', '')));\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType.replace('PRIMARY KEY', '')));\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1]));\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType));\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const comment = options.comment && typeof options.comment === 'string' ? \" COMMENT \".concat(this.escape(options.comment)) : '';\n    const engine = options.engine;\n    const charset = options.charset ? \" DEFAULT CHARSET=\".concat(options.charset) : '';\n    const collation = options.collate ? \" COLLATE \".concat(options.collate) : '';\n    const rowFormat = options.rowFormat ? \" ROW_FORMAT=\".concat(options.rowFormat) : '';\n    const initialAutoIncrement = options.initialAutoIncrement ? \" AUTO_INCREMENT=\".concat(options.initialAutoIncrement) : '';\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = \"uniq_\".concat(tableName, \"_\").concat(columns.fields.join('_'));\n          }\n\n          attributesClause += \", UNIQUE \".concat(this.quoteIdentifier(indexName), \" (\").concat(columns.fields.map(field => this.quoteIdentifier(field)).join(', '), \")\");\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += \", PRIMARY KEY (\".concat(pkString, \")\");\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += \", FOREIGN KEY (\".concat(this.quoteIdentifier(fkey), \") \").concat(foreignKeys[fkey]);\n      }\n    }\n\n    return \"CREATE TABLE IF NOT EXISTS \".concat(table, \" (\").concat(attributesClause, \") ENGINE=\").concat(engine).concat(comment).concat(charset).concat(collation).concat(initialAutoIncrement).concat(rowFormat, \";\");\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return \"SHOW FULL COLUMNS FROM \".concat(table, \";\");\n  }\n\n  showTablesQuery(database) {\n    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n\n    if (database) {\n      query += \" AND TABLE_SCHEMA = \".concat(this.escape(database));\n    } else {\n      query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')';\n    }\n\n    return \"\".concat(query, \";\");\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const definition = this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key\n    });\n    return \"ALTER TABLE \".concat(this.quoteTable(table), \" ADD \").concat(this.quoteIdentifier(key), \" \").concat(definition, \";\");\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" DROP \").concat(this.quoteIdentifier(attributeName), \";\");\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(\"FOREIGN KEY (\".concat(attrName, \") \").concat(definition));\n      } else {\n        attrString.push(\"`\".concat(attributeName, \"` `\").concat(attributeName, \"` \").concat(definition));\n      }\n    }\n\n    let finalQuery = '';\n\n    if (attrString.length) {\n      finalQuery += \"CHANGE \".concat(attrString.join(', '));\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n\n    if (constraintString.length) {\n      finalQuery += \"ADD \".concat(constraintString.join(', '));\n    }\n\n    return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" \").concat(finalQuery, \";\");\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(\"`\".concat(attrBefore, \"` `\").concat(attrName, \"` \").concat(definition));\n    }\n\n    return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" CHANGE \").concat(attrString.join(', '), \";\");\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => \"\".concat(this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path)), \" = '\").concat(condition.value, \"'\"));\n        return conditions.join(' AND ');\n      }\n\n      if (smth.path) {\n        let str; // Allow specifying conditions using the sqlite json functions\n\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    } // null is stored as a string in mysql\n\n\n    if (value === null) {\n      return 'null';\n    }\n\n    return value;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.onDuplicate = 'UPDATE ';\n    options.onDuplicate += Object.keys(updateValues).map(key => {\n      key = this.quoteIdentifier(key);\n      return \"\".concat(key, \"=VALUES(\").concat(key, \")\");\n    }).join(', ');\n    return this.insertQuery(tableName, insertValues, model.rawAttributes, options);\n  }\n\n  truncateTableQuery(tableName) {\n    return \"TRUNCATE \".concat(this.quoteTable(tableName));\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = \"DELETE FROM \".concat(this.quoteTable(tableName));\n\n    if (options.limit) {\n      limit = \" LIMIT \".concat(this.escape(options.limit));\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += \" WHERE \".concat(where);\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return \"SHOW INDEX FROM \".concat(this.quoteTable(tableName)).concat((options || {}).database ? \" FROM `\".concat(options.database, \"`\") : '');\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    let sql = ['SELECT CONSTRAINT_CATALOG AS constraintCatalog,', 'CONSTRAINT_NAME AS constraintName,', 'CONSTRAINT_SCHEMA AS constraintSchema,', 'CONSTRAINT_TYPE AS constraintType,', 'TABLE_NAME AS tableName,', 'TABLE_SCHEMA AS tableSchema', 'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS', \"WHERE table_name='\".concat(tableName, \"'\")].join(' ');\n\n    if (constraintName) {\n      sql += \" AND constraint_name = '\".concat(constraintName, \"'\");\n    }\n\n    if (schemaName) {\n      sql += \" AND TABLE_SCHEMA = '\".concat(schemaName, \"'\");\n    }\n\n    return \"\".concat(sql, \";\");\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(\"\".concat(tableName, \"_\").concat(indexNameOrAttributes.join('_')));\n    }\n\n    return \"DROP INDEX \".concat(this.quoteIdentifier(indexName), \" ON \").concat(this.quoteTable(tableName));\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({\n      escape: this.escape.bind(this)\n    });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    } // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n\n\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += \" DEFAULT \".concat(this.escape(attribute.defaultValue));\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += \" COMMENT \".concat(this.escape(attribute.comment));\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n\n    if (attribute.after) {\n      template += \" AFTER \".concat(this.quoteIdentifier(attribute.after));\n    }\n\n    if (attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(\"\".concat(options.tableName, \"_\").concat(attrName, \"_foreign_idx\"));\n        template += \", ADD CONSTRAINT \".concat(fkName, \" FOREIGN KEY (\").concat(attrName, \")\");\n      }\n\n      template += \" REFERENCES \".concat(this.quoteTable(attribute.references.model));\n\n      if (attribute.references.key) {\n        template += \" (\".concat(this.quoteIdentifier(attribute.references.key), \")\");\n      } else {\n        template += \" (\".concat(this.quoteIdentifier('id'), \")\");\n      }\n\n      if (attribute.onDelete) {\n        template += \" ON DELETE \".concat(attribute.onDelete.toUpperCase());\n      }\n\n      if (attribute.onUpdate) {\n        template += \" ON UPDATE \".concat(attribute.onUpdate.toUpperCase());\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    } // Check invalid json statement\n\n\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(\"Invalid json statement: \".concat(stmt));\n    } // return true if the statement has valid json function\n\n\n    return hasJsonFunction;\n  }\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return \"SELECT \".concat(foreignKeyFields, \" FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '\").concat(tableName, \"' AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='\").concat(schemaName, \"' AND REFERENCED_TABLE_NAME IS NOT NULL;\");\n  }\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return \"SELECT \".concat(foreignKeyFields, \" FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\") + \" WHERE (REFERENCED_TABLE_NAME = \".concat(quotedTableName).concat(table.schema ? \" AND REFERENCED_TABLE_SCHEMA = \".concat(quotedSchemaName) : '', \" AND REFERENCED_COLUMN_NAME = \").concat(quotedColumnName, \")\") + \" OR (TABLE_NAME = \".concat(quotedTableName).concat(table.schema ? \" AND TABLE_SCHEMA = \".concat(quotedSchemaName) : '', \" AND COLUMN_NAME = \").concat(quotedColumnName, \" AND REFERENCED_TABLE_NAME IS NOT NULL)\");\n  }\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return \"ALTER TABLE \".concat(this.quoteTable(tableName), \"\\n      DROP FOREIGN KEY \").concat(this.quoteIdentifier(foreignKey), \";\");\n  }\n\n} // private methods\n\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;","map":null,"metadata":{},"sourceType":"script"}