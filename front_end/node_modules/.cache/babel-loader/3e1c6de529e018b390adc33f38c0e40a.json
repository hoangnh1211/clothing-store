{"ast":null,"code":"'use strict';\n\nconst _require = require('sequelize-pool'),\n      Pool = _require.Pool,\n      TimeoutError = _require.TimeoutError;\n\nconst _ = require('lodash');\n\nconst semver = require('semver');\n\nconst Promise = require('../../promise');\n\nconst errors = require('../../errors');\n\nconst _require2 = require('../../utils/logger'),\n      logger = _require2.logger;\n\nconst debug = logger.debugContext('pool');\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\n\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(\"Parse function not supported for type \".concat(dataType.key, \" in dialect \").concat(this.dialectName));\n        }\n      }\n    });\n  }\n  /**\n   * Try to load dialect module from various configured options.\n   * Priority goes like dialectModulePath > dialectModule > require(default)\n   *\n   * @param {string} moduleName Name of dialect module to lookup\n   *\n   * @private\n   * @returns {Object}\n   */\n\n\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n\n      return require(moduleName);\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(\"Unable to find dialect at \".concat(this.sequelize.config.dialectModulePath));\n        }\n\n        throw new Error(\"Please install \".concat(moduleName, \" package manually\"));\n      }\n\n      throw err;\n    }\n  }\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @returns {Promise}\n   */\n\n\n  _onProcessExit() {\n    if (!this.pool) {\n      return Promise.resolve();\n    }\n\n    return this.pool.drain().then(() => {\n      debug('connection drain due to process exit');\n      return this.pool.destroyAllNow();\n    });\n  }\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @returns {Promise}\n   */\n\n\n  close() {\n    // Mark close of pool\n    this.getConnection = function getConnection() {\n      return Promise.reject(new Error('ConnectionManager.getConnection was called after the connection manager was closed!'));\n    };\n\n    return this._onProcessExit();\n  }\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n\n\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: 'sequelize',\n        create: () => this._connect(config),\n        destroy: connection => {\n          return this._disconnect(connection).tap(() => {\n            debug('connection destroy');\n          });\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      });\n      debug(\"pool created with max/min: \".concat(config.pool.max, \"/\").concat(config.pool.min, \", no replication\"));\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    } // Map main connection config\n\n\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication')); // Apply defaults to each read config\n\n    config.replication.read = config.replication.read.map(readConfig => _.defaults(readConfig, _.omit(this.config, 'replication'))); // custom pooling for replication (original author @janmeier)\n\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === undefined ? false : useMaster;\n\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire();\n        }\n\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug('connection destroy');\n      },\n      destroyAllNow: () => {\n        return Promise.join(this.pool.read.destroyAllNow(), this.pool.write.destroyAllNow()).tap(() => {\n          debug('all connections destroyed');\n        });\n      },\n      drain: () => {\n        return Promise.join(this.pool.write.drain(), this.pool.read.drain());\n      },\n      read: new Pool({\n        name: 'sequelize:read',\n        create: () => {\n          // round robin config\n          const nextRead = reads++ % config.replication.read.length;\n          return this._connect(config.replication.read[nextRead]).tap(connection => {\n            connection.queryType = 'read';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      }),\n      write: new Pool({\n        name: 'sequelize:write',\n        create: () => {\n          return this._connect(config.replication.write).tap(connection => {\n            connection.queryType = 'write';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      })\n    };\n    debug(\"pool created with max/min: \".concat(config.pool.max, \"/\").concat(config.pool.min, \", with replication\"));\n  }\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {Object}   [options]                 Pool options\n   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @returns {Promise<Connection>}\n   */\n\n\n  getConnection(options) {\n    options = options || {};\n    let promise;\n\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (this.versionPromise) {\n        promise = this.versionPromise;\n      } else {\n        promise = this.versionPromise = this._connect(this.config.replication.write || this.config).then(connection => {\n          const _options = {};\n          _options.transaction = {\n            connection\n          }; // Cheat .query to use our private connection\n\n          _options.logging = () => {};\n\n          _options.logging.__testLoggingFn = true; //connection might have set databaseVersion value at initialization,\n          //avoiding a useless round trip\n\n          if (this.sequelize.options.databaseVersion === 0) {\n            return this.sequelize.databaseVersion(_options).then(version => {\n              const parsedVersion = _.get(semver.coerce(version), 'version') || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : this.defaultVersion;\n              this.versionPromise = null;\n              return this._disconnect(connection);\n            });\n          }\n\n          this.versionPromise = null;\n          return this._disconnect(connection);\n        }).catch(err => {\n          this.versionPromise = null;\n          throw err;\n        });\n      }\n    } else {\n      promise = Promise.resolve();\n    }\n\n    return promise.then(() => {\n      return this.pool.acquire(options.type, options.useMaster).catch(error => {\n        if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n        throw error;\n      });\n    }).tap(() => {\n      debug('connection acquired');\n    });\n  }\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   *\n   * @returns {Promise}\n   */\n\n\n  releaseConnection(connection) {\n    return Promise.try(() => {\n      this.pool.release(connection);\n      debug('connection released');\n    });\n  }\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @returns {Promise<Connection>}\n   */\n\n\n  _connect(config) {\n    return this.sequelize.runHooks('beforeConnect', config).then(() => this.dialect.connectionManager.connect(config)).then(connection => this.sequelize.runHooks('afterConnect', connection, config).return(connection));\n  }\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n\n\n  _disconnect(connection) {\n    return this.sequelize.runHooks('beforeDisconnect', connection).then(() => this.dialect.connectionManager.disconnect(connection)).then(() => this.sequelize.runHooks('afterDisconnect', connection));\n  }\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @returns {boolean}\n   */\n\n\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":null,"metadata":{},"sourceType":"script"}