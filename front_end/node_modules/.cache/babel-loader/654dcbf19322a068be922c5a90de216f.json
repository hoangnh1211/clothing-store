{"ast":null,"code":"\"use strict\";\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst StreamParser = require('./stream-parser');\n/*\n  Buffers are thrown at the parser (by calling addBuffer).\n  Tokens are parsed from the buffer until there are no more tokens in\n  the buffer, or there is just a partial token left.\n  If there is a partial token left over, then it is kept until another\n  buffer is added, which should contain the remainder of the partial\n  token, along with (perhaps) more tokens.\n  The partial token and the new buffer are concatenated, and the token\n  parsing resumes.\n */\n\n\nclass Parser extends EventEmitter {\n  constructor(debug, colMetadata, options) {\n    super();\n    this.debug = debug;\n    this.colMetadata = this.colMetadata;\n    this.options = options;\n    this.parser = new StreamParser(this.debug, this.colMetadata, this.options);\n    this.parser.on('data', token => {\n      if (token.event) {\n        this.emit(token.event, token);\n      }\n    });\n    this.parser.on('drain', () => {\n      this.emit('drain');\n    });\n  } // Returns false to apply backpressure.\n\n\n  addBuffer(buffer) {\n    return this.parser.write(buffer);\n  } // Writes an end-of-message (EOM) marker into the parser transform input\n  // queue. StreamParser will emit a 'data' event with an 'endOfMessage'\n  // pseudo token when the EOM marker has passed through the transform stream.\n  // Returns false to apply backpressure.\n\n\n  addEndOfMessageMarker() {\n    return this.parser.write(this.parser.endOfMessageMarker);\n  }\n\n  isEnd() {\n    return this.parser.buffer.length === this.parser.position;\n  } // Temporarily suspends the token stream parser transform from emitting events.\n\n\n  pause() {\n    this.parser.pause();\n  } // Resumes the token stream parser transform.\n\n\n  resume() {\n    this.parser.resume();\n  }\n\n}\n\nmodule.exports.Parser = Parser;","map":null,"metadata":{},"sourceType":"script"}