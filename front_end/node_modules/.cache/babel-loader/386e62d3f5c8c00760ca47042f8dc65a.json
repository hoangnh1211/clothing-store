{"ast":null,"code":"/****\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Gustavo Henke and Aaron Trent\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n ****/\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(\"Toposort\", [\"exports\", \"module\"], factory);\n  } else if (typeof exports !== \"undefined\" && typeof module !== \"undefined\") {\n    factory(exports, module);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, mod);\n    global.Toposort = mod.exports;\n  }\n})(this, function (exports, module) {\n  \"use strict\";\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var Toposort = function () {\n    function Toposort() {\n      _classCallCheck(this, Toposort);\n\n      this.edges = [];\n      this.Toposort = Toposort;\n    }\n    /**\n     * Adds dependency edges.\n     *\n     * @since   0.1.0\n     * @param   {String} item               An dependent name. Must be an string and not empty\n     * @param   {String[]|String} [deps]    An dependency or array of dependencies\n     * @returns {Toposort}                  The Toposort instance\n     */\n\n\n    Toposort.prototype.add = function add(item, deps) {\n      if (typeof item !== \"string\" || !item) {\n        throw new TypeError(\"Dependent name must be given as a not empty string\");\n      }\n\n      deps = Array.isArray(deps) ? deps : [deps];\n\n      if (deps.length > 0) {\n        for (var _iterator = deps, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) {\n              break;\n            }\n\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n\n            if (_i.done) {\n              break;\n            }\n\n            _ref = _i.value;\n          }\n\n          var dep = _ref;\n\n          if (typeof dep !== \"string\" || !dep) {\n            throw new TypeError(\"Dependency name must be given as a not empty string\");\n          }\n\n          this.edges.push([item, dep]);\n        }\n      } else {\n        this.edges.push([item]);\n      }\n\n      return this;\n    };\n    /**\n     * Runs the toposorting and return an ordered array of strings\n     *\n     * @since   0.1.0\n     * @returns {String[]}  The list of items topologically sorted.\n     */\n\n\n    Toposort.prototype.sort = function sort() {\n      var _this = this;\n\n      var nodes = []; //accumulate unique nodes into a large list\n\n      for (var _iterator2 = this.edges, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) {\n            break;\n          }\n\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n\n          if (_i2.done) {\n            break;\n          }\n\n          _ref2 = _i2.value;\n        }\n\n        var edge = _ref2;\n\n        for (var _iterator3 = edge, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n          var _ref3;\n\n          if (_isArray3) {\n            if (_i3 >= _iterator3.length) {\n              break;\n            }\n\n            _ref3 = _iterator3[_i3++];\n          } else {\n            _i3 = _iterator3.next();\n\n            if (_i3.done) {\n              break;\n            }\n\n            _ref3 = _i3.value;\n          }\n\n          var node = _ref3;\n\n          if (nodes.indexOf(node) === -1) {\n            nodes.push(node);\n          }\n        }\n      } //initialize the placement of nodes into the sorted array at the end\n\n\n      var place = nodes.length; //initialize the sorted array with the same length as the unique nodes array\n\n      var sorted = new Array(nodes.length); //define a visitor function that recursively traverses dependencies.\n\n      var visit = function visit(node, predecessors) {\n        //check if a node is dependent of itself\n        if (predecessors.length !== 0 && predecessors.indexOf(node) !== -1) {\n          throw new Error(\"Cyclic dependency found. \" + node + \" is dependent of itself.\\nDependency chain: \" + predecessors.join(\" -> \") + \" => \" + node);\n        }\n\n        var index = nodes.indexOf(node); //if the node still exists, traverse its dependencies\n\n        if (index !== -1) {\n          var copy = false; //mark the node as false to exclude it from future iterations\n\n          nodes[index] = false; //loop through all edges and follow dependencies of the current node\n\n          for (var _iterator4 = _this.edges, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n            var _ref4;\n\n            if (_isArray4) {\n              if (_i4 >= _iterator4.length) {\n                break;\n              }\n\n              _ref4 = _iterator4[_i4++];\n            } else {\n              _i4 = _iterator4.next();\n\n              if (_i4.done) {\n                break;\n              }\n\n              _ref4 = _i4.value;\n            }\n\n            var edge = _ref4;\n\n            if (edge[0] === node) {\n              //lazily create a copy of predecessors with the current node concatenated onto it\n              copy = copy || predecessors.concat([node]); //recurse to node dependencies\n\n              visit(edge[1], copy);\n            }\n          } //add the node to the next place in the sorted array\n\n\n          sorted[--place] = node;\n        }\n      };\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i]; //ignore nodes that have been excluded\n\n        if (node !== false) {\n          //mark the node as false to exclude it from future iterations\n          nodes[i] = false; //loop through all edges and follow dependencies of the current node\n\n          for (var _iterator5 = this.edges, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n            var _ref5;\n\n            if (_isArray5) {\n              if (_i5 >= _iterator5.length) {\n                break;\n              }\n\n              _ref5 = _iterator5[_i5++];\n            } else {\n              _i5 = _iterator5.next();\n\n              if (_i5.done) {\n                break;\n              }\n\n              _ref5 = _i5.value;\n            }\n\n            var edge = _ref5;\n\n            if (edge[0] === node) {\n              //recurse to node dependencies\n              visit(edge[1], [node]);\n            }\n          } //add the node to the next place in the sorted array\n\n\n          sorted[--place] = node;\n        }\n      }\n\n      return sorted;\n    };\n    /**\n     * Clears edges\n     *\n     * @since   0.4.0\n     * @returns {Toposort}                  The Toposort instance\n     */\n\n\n    Toposort.prototype.clear = function clear() {\n      this.edges = [];\n      return this;\n    };\n\n    return Toposort;\n  }();\n\n  module.exports = Toposort;\n});","map":null,"metadata":{},"sourceType":"script"}