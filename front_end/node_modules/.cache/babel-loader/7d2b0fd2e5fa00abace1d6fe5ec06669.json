{"ast":null,"code":"\"use strict\";\n\nconst WritableTrackingBuffer = require('./tracking-buffer/writable-tracking-buffer');\n\nconst crypto = require('crypto');\n\nconst BigInteger = require('big-number');\n\nconst hex = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\nclass NTLMResponsePayload {\n  constructor(loginData) {\n    this.data = this.createResponse(loginData);\n  }\n\n  toString(indent = '') {\n    return indent + 'NTLM Auth';\n  }\n\n  createResponse(challenge) {\n    const client_nonce = this.createClientNonce();\n    const lmv2len = 24;\n    const ntlmv2len = 16;\n    const domain = challenge.domain;\n    const username = challenge.userName;\n    const password = challenge.password;\n    let ntlmData = challenge.ntlmpacket;\n    const server_data = ntlmData.target;\n    const server_nonce = ntlmData.nonce;\n    const bufferLength = 64 + domain.length * 2 + username.length * 2 + lmv2len + ntlmv2len + 8 + 8 + 8 + 4 + server_data.length + 4;\n    const data = new WritableTrackingBuffer(bufferLength);\n    data.position = 0;\n    data.writeString('NTLMSSP\\u0000', 'utf8');\n    data.writeUInt32LE(0x03);\n    const baseIdx = 64;\n    const dnIdx = baseIdx;\n    const unIdx = dnIdx + domain.length * 2;\n    const l2Idx = unIdx + username.length * 2;\n    const ntIdx = l2Idx + lmv2len;\n    data.writeUInt16LE(lmv2len);\n    data.writeUInt16LE(lmv2len);\n    data.writeUInt32LE(l2Idx);\n    data.writeUInt16LE(ntlmv2len);\n    data.writeUInt16LE(ntlmv2len);\n    data.writeUInt32LE(ntIdx);\n    data.writeUInt16LE(domain.length * 2);\n    data.writeUInt16LE(domain.length * 2);\n    data.writeUInt32LE(dnIdx);\n    data.writeUInt16LE(username.length * 2);\n    data.writeUInt16LE(username.length * 2);\n    data.writeUInt32LE(unIdx);\n    data.writeUInt16LE(0);\n    data.writeUInt16LE(0);\n    data.writeUInt32LE(baseIdx);\n    data.writeUInt16LE(0);\n    data.writeUInt16LE(0);\n    data.writeUInt32LE(baseIdx);\n    data.writeUInt16LE(0x8201);\n    data.writeUInt16LE(0x08);\n    data.writeString(domain, 'ucs2');\n    data.writeString(username, 'ucs2');\n    const lmv2Data = this.lmv2Response(domain, username, password, server_nonce, client_nonce);\n    data.copyFrom(lmv2Data);\n    const genTime = new Date().getTime();\n    ntlmData = this.ntlmv2Response(domain, username, password, server_nonce, server_data, client_nonce, genTime);\n    data.copyFrom(ntlmData);\n    data.writeUInt32LE(0x0101);\n    data.writeUInt32LE(0x0000);\n    const timestamp = this.createTimestamp(genTime);\n    data.copyFrom(timestamp);\n    data.copyFrom(client_nonce);\n    data.writeUInt32LE(0x0000);\n    data.copyFrom(server_data);\n    data.writeUInt32LE(0x0000);\n    return data.data;\n  }\n\n  createClientNonce() {\n    const client_nonce = Buffer.alloc(8, 0);\n    let nidx = 0;\n\n    while (nidx < 8) {\n      client_nonce.writeUInt8(Math.ceil(Math.random() * 255), nidx);\n      nidx++;\n    }\n\n    return client_nonce;\n  }\n\n  ntlmv2Response(domain, user, password, serverNonce, targetInfo, clientNonce, mytime) {\n    const timestamp = this.createTimestamp(mytime);\n    const hash = this.ntv2Hash(domain, user, password);\n    const dataLength = 40 + targetInfo.length;\n    const data = Buffer.alloc(dataLength, 0);\n    serverNonce.copy(data, 0, 0, 8);\n    data.writeUInt32LE(0x101, 8);\n    data.writeUInt32LE(0x0, 12);\n    timestamp.copy(data, 16, 0, 8);\n    clientNonce.copy(data, 24, 0, 8);\n    data.writeUInt32LE(0x0, 32);\n    targetInfo.copy(data, 36, 0, targetInfo.length);\n    data.writeUInt32LE(0x0, 36 + targetInfo.length);\n    return this.hmacMD5(data, hash);\n  }\n\n  createTimestamp(time) {\n    const tenthsOfAMicrosecond = BigInteger(time).plus(11644473600).multiply(10000000);\n    const hexArray = [];\n    let pair = [];\n\n    while (tenthsOfAMicrosecond.val() !== '0') {\n      const idx = tenthsOfAMicrosecond.mod(16);\n      pair.unshift(hex[idx]);\n\n      if (pair.length === 2) {\n        hexArray.push(pair.join(''));\n        pair = [];\n      }\n    }\n\n    if (pair.length > 0) {\n      hexArray.push(pair[0] + '0');\n    }\n\n    return Buffer.from(hexArray.join(''), 'hex');\n  }\n\n  lmv2Response(domain, user, password, serverNonce, clientNonce) {\n    const hash = this.ntv2Hash(domain, user, password);\n    const data = Buffer.alloc(serverNonce.length + clientNonce.length, 0);\n    serverNonce.copy(data);\n    clientNonce.copy(data, serverNonce.length, 0, clientNonce.length);\n    const newhash = this.hmacMD5(data, hash);\n    const response = Buffer.alloc(newhash.length + clientNonce.length, 0);\n    newhash.copy(response);\n    clientNonce.copy(response, newhash.length, 0, clientNonce.length);\n    return response;\n  }\n\n  ntv2Hash(domain, user, password) {\n    const hash = this.ntHash(password);\n    const identity = Buffer.from(user.toUpperCase() + domain.toUpperCase(), 'ucs2');\n    return this.hmacMD5(identity, hash);\n  }\n\n  ntHash(text) {\n    const hash = Buffer.alloc(21, 0);\n    const unicodeString = Buffer.from(text, 'ucs2');\n    const md4 = crypto.createHash('md4').update(unicodeString).digest();\n\n    if (md4.copy) {\n      md4.copy(hash);\n    } else {\n      Buffer.from(md4).copy(hash);\n    }\n\n    return hash;\n  }\n\n  hmacMD5(data, key) {\n    const hmac = crypto.createHmac('MD5', key);\n    hmac.update(data);\n    const result = hmac.digest();\n\n    if (result.copy) {\n      return result;\n    } else {\n      return Buffer.from(result).slice(0, 16);\n    }\n  }\n\n}\n\nmodule.exports = NTLMResponsePayload;","map":null,"metadata":{},"sourceType":"script"}