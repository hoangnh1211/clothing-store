{"ast":null,"code":"'use strict';\n\nconst TYPES = {\n  VarChar(length) {\n    return {\n      type: TYPES.VarChar,\n      length\n    };\n  },\n\n  NVarChar(length) {\n    return {\n      type: TYPES.NVarChar,\n      length\n    };\n  },\n\n  Text() {\n    return {\n      type: TYPES.Text\n    };\n  },\n\n  Int() {\n    return {\n      type: TYPES.Int\n    };\n  },\n\n  BigInt() {\n    return {\n      type: TYPES.BigInt\n    };\n  },\n\n  TinyInt() {\n    return {\n      type: TYPES.TinyInt\n    };\n  },\n\n  SmallInt() {\n    return {\n      type: TYPES.SmallInt\n    };\n  },\n\n  Bit() {\n    return {\n      type: TYPES.Bit\n    };\n  },\n\n  Float() {\n    return {\n      type: TYPES.Float\n    };\n  },\n\n  Numeric(precision, scale) {\n    return {\n      type: TYPES.Numeric,\n      precision,\n      scale\n    };\n  },\n\n  Decimal(precision, scale) {\n    return {\n      type: TYPES.Decimal,\n      precision,\n      scale\n    };\n  },\n\n  Real() {\n    return {\n      type: TYPES.Real\n    };\n  },\n\n  Date() {\n    return {\n      type: TYPES.Date\n    };\n  },\n\n  DateTime() {\n    return {\n      type: TYPES.DateTime\n    };\n  },\n\n  DateTime2(scale) {\n    return {\n      type: TYPES.DateTime2,\n      scale\n    };\n  },\n\n  DateTimeOffset(scale) {\n    return {\n      type: TYPES.DateTimeOffset,\n      scale\n    };\n  },\n\n  SmallDateTime() {\n    return {\n      type: TYPES.SmallDateTime\n    };\n  },\n\n  Time(scale) {\n    return {\n      type: TYPES.Time,\n      scale\n    };\n  },\n\n  UniqueIdentifier() {\n    return {\n      type: TYPES.UniqueIdentifier\n    };\n  },\n\n  SmallMoney() {\n    return {\n      type: TYPES.SmallMoney\n    };\n  },\n\n  Money() {\n    return {\n      type: TYPES.Money\n    };\n  },\n\n  Binary(length) {\n    return {\n      type: TYPES.Binary,\n      length\n    };\n  },\n\n  VarBinary(length) {\n    return {\n      type: TYPES.VarBinary,\n      length\n    };\n  },\n\n  Image() {\n    return {\n      type: TYPES.Image\n    };\n  },\n\n  Xml() {\n    return {\n      type: TYPES.Xml\n    };\n  },\n\n  Char(length) {\n    return {\n      type: TYPES.Char,\n      length\n    };\n  },\n\n  NChar(length) {\n    return {\n      type: TYPES.NChar,\n      length\n    };\n  },\n\n  NText() {\n    return {\n      type: TYPES.NText\n    };\n  },\n\n  TVP(tvpType) {\n    return {\n      type: TYPES.TVP,\n      tvpType\n    };\n  },\n\n  UDT() {\n    return {\n      type: TYPES.UDT\n    };\n  },\n\n  Geography() {\n    return {\n      type: TYPES.Geography\n    };\n  },\n\n  Geometry() {\n    return {\n      type: TYPES.Geometry\n    };\n  },\n\n  Variant() {\n    return {\n      type: TYPES.Variant\n    };\n  }\n\n};\nmodule.exports.TYPES = TYPES;\nmodule.exports.DECLARATIONS = {};\n\nconst zero = function (value, length) {\n  if (length == null) length = 2;\n  value = String(value);\n\n  if (value.length < length) {\n    for (let i = 1; i <= length - value.length; i++) {\n      value = \"0\".concat(value);\n    }\n  }\n\n  return value;\n};\n\nfor (const key in TYPES) {\n  if (Object.prototype.hasOwnProperty.call(TYPES, key)) {\n    const value = TYPES[key];\n    value.declaration = key.toLowerCase();\n    module.exports.DECLARATIONS[value.declaration] = value;\n\n    ((key, value) => {\n      value.inspect = () => \"[sql.\".concat(key, \"]\");\n    })(key, value);\n  }\n}\n\nmodule.exports.declare = (type, options) => {\n  switch (type) {\n    case TYPES.VarChar:\n    case TYPES.VarBinary:\n      return \"\".concat(type.declaration, \" (\").concat(options.length > 8000 ? 'MAX' : options.length == null ? 'MAX' : options.length, \")\");\n\n    case TYPES.NVarChar:\n      return \"\".concat(type.declaration, \" (\").concat(options.length > 4000 ? 'MAX' : options.length == null ? 'MAX' : options.length, \")\");\n\n    case TYPES.Char:\n    case TYPES.NChar:\n    case TYPES.Binary:\n      return \"\".concat(type.declaration, \" (\").concat(options.length == null ? 1 : options.length, \")\");\n\n    case TYPES.Decimal:\n    case TYPES.Numeric:\n      return \"\".concat(type.declaration, \" (\").concat(options.precision == null ? 18 : options.precision, \", \").concat(options.scale == null ? 0 : options.scale, \")\");\n\n    case TYPES.Time:\n    case TYPES.DateTime2:\n    case TYPES.DateTimeOffset:\n      return \"\".concat(type.declaration, \" (\").concat(options.scale == null ? 7 : options.scale, \")\");\n\n    case TYPES.TVP:\n      return \"\".concat(options.tvpType, \" readonly\");\n\n    default:\n      return type.declaration;\n  }\n};\n\nmodule.exports.cast = (value, type, options) => {\n  if (value == null) {\n    return null;\n  }\n\n  switch (typeof value) {\n    case 'string':\n      return \"N'\".concat(value.replace(/'/g, '\\'\\''), \"'\");\n\n    case 'number':\n      return value;\n\n    case 'boolean':\n      return value ? 1 : 0;\n\n    case 'object':\n      if (value instanceof Date) {\n        let ns = value.getUTCMilliseconds() / 1000;\n\n        if (value.nanosecondDelta != null) {\n          ns += value.nanosecondDelta;\n        }\n\n        const scale = options.scale == null ? 7 : options.scale;\n\n        if (scale > 0) {\n          ns = String(ns).substr(1, scale + 1);\n        } else {\n          ns = '';\n        }\n\n        return \"N'\".concat(value.getUTCFullYear(), \"-\").concat(zero(value.getUTCMonth() + 1), \"-\").concat(zero(value.getUTCDate()), \" \").concat(zero(value.getUTCHours()), \":\").concat(zero(value.getUTCMinutes()), \":\").concat(zero(value.getUTCSeconds())).concat(ns, \"'\");\n      } else if (Buffer.isBuffer(value)) {\n        return \"0x\".concat(value.toString('hex'));\n      }\n\n      return null;\n\n    default:\n      return null;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}