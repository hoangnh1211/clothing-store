{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst HasOne = require('./has-one');\n\nconst HasMany = require('./has-many');\n\nconst BelongsToMany = require('./belongs-to-many');\n\nconst BelongsTo = require('./belongs-to');\n\nfunction isModel(model, sequelize) {\n  return model && model.prototype && model.prototype instanceof sequelize.Sequelize.Model;\n}\n\nconst Mixin = {\n  hasMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(\"\".concat(this.name, \".hasMany called with something that's not a subclass of Sequelize.Model\"));\n    }\n\n    const source = this; // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options = Object.assign(options, _.omit(source.options, ['hooks']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', {\n        source,\n        target,\n        type: HasMany\n      }, options);\n    } // the id is in the foreign table or in a connecting table\n\n\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', {\n        source,\n        target,\n        type: HasMany,\n        association\n      }, options);\n    }\n\n    return association;\n  },\n\n  belongsToMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(\"\".concat(this.name, \".belongsToMany called with something that's not a subclass of Sequelize.Model\"));\n    }\n\n    const source = this; // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;\n    options = Object.assign(options, _.omit(source.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', {\n        source,\n        target,\n        type: BelongsToMany\n      }, options);\n    } // the id is in the foreign table or in a connecting table\n\n\n    const association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', {\n        source,\n        target,\n        type: BelongsToMany,\n        association\n      }, options);\n    }\n\n    return association;\n  },\n\n  getAssociations(target) {\n    return _.values(this.associations).filter(association => association.target.name === target.name);\n  },\n\n  getAssociationForAlias(target, alias) {\n    // Two associations cannot have the same alias, so we can use find instead of filter\n    return this.getAssociations(target).find(association => association.verifyAssociationAlias(alias)) || null;\n  }\n\n}; // The logic for hasOne and belongsTo is exactly the same\n\nfunction singleLinked(Type) {\n  return function (target, options = {}) {\n    // eslint-disable-next-line no-invalid-this\n    const source = this;\n\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(\"\".concat(source.name, \".\").concat(_.lowerFirst(Type.name), \" called with something that's not a subclass of Sequelize.Model\"));\n    } // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    if (options.useHooks) {\n      source.runHooks('beforeAssociate', {\n        source,\n        target,\n        type: Type\n      }, options);\n    } // the id is in the foreign table\n\n\n    const association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      source.runHooks('afterAssociate', {\n        source,\n        target,\n        type: Type,\n        association\n      }, options);\n    }\n\n    return association;\n  };\n}\n\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;","map":null,"metadata":{},"sourceType":"script"}