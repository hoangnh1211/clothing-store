{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('./utils');\n\nconst DataTypes = require('./data-types');\n\nconst SQLiteQueryInterface = require('./dialects/sqlite/query-interface');\n\nconst MSSQLQueryInterface = require('./dialects/mssql/query-interface');\n\nconst MySQLQueryInterface = require('./dialects/mysql/query-interface');\n\nconst PostgresQueryInterface = require('./dialects/postgres/query-interface');\n\nconst Transaction = require('./transaction');\n\nconst Promise = require('./promise');\n\nconst QueryTypes = require('./query-types');\n\nconst Op = require('./operators');\n/**\n * The interface that Sequelize uses to talk to all databases\n *\n * @class QueryInterface\n */\n\n\nclass QueryInterface {\n  constructor(sequelize) {\n    this.sequelize = sequelize;\n    this.QueryGenerator = this.sequelize.dialect.QueryGenerator;\n  }\n  /**\n   * Create a database\n   *\n   * @param {string} database  Database name to create\n   * @param {Object} [options] Query options\n   * @param {string} [options.charset] Database default character set, MYSQL only\n   * @param {string} [options.collate] Database default collation\n   * @param {string} [options.encoding] Database default character set, PostgreSQL only\n   * @param {string} [options.ctype] Database character classification, PostgreSQL only\n   * @param {string} [options.template] The name of the template from which to create the new database, PostgreSQL only\n   *\n   * @returns {Promise}\n   */\n\n\n  createDatabase(database, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.createDatabaseQuery(database, options);\n    return this.sequelize.query(sql, options);\n  }\n  /**\n   * Drop a database\n   *\n   * @param {string} database  Database name to drop\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.dropDatabaseQuery(database);\n    return this.sequelize.query(sql, options);\n  }\n  /**\n   * Create a schema\n   *\n   * @param {string} schema    Schema name to create\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  createSchema(schema, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.createSchema(schema);\n    return this.sequelize.query(sql, options);\n  }\n  /**\n   * Drop a schema\n   *\n   * @param {string} schema    Schema name to drop\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.dropSchema(schema);\n    return this.sequelize.query(sql, options);\n  }\n  /**\n   * Drop all schemas\n   *\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  dropAllSchemas(options) {\n    options = options || {};\n\n    if (!this.QueryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n\n    return this.showAllSchemas(options).map(schemaName => this.dropSchema(schemaName, options));\n  }\n  /**\n   * Show all schemas\n   *\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise<Array>}\n   */\n\n\n  showAllSchemas(options) {\n    options = Object.assign({}, options, {\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    });\n    const showSchemasSql = this.QueryGenerator.showSchemasQuery(options);\n    return this.sequelize.query(showSchemasSql, options).then(schemaNames => _.flatten(schemaNames.map(value => value.schema_name ? value.schema_name : value)));\n  }\n  /**\n   * Return database version\n   *\n   * @param {Object}    [options]      Query options\n   * @param {QueryType} [options.type] Query type\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\n  databaseVersion(options) {\n    return this.sequelize.query(this.QueryGenerator.versionQuery(), Object.assign({}, options, {\n      type: QueryTypes.VERSION\n    }));\n  }\n  /**\n   * Create a table with given set of attributes\n   *\n   * ```js\n   * queryInterface.createTable(\n   *   'nameOfTheNewTable',\n   *   {\n   *     id: {\n   *       type: Sequelize.INTEGER,\n   *       primaryKey: true,\n   *       autoIncrement: true\n   *     },\n   *     createdAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     updatedAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     attr1: Sequelize.STRING,\n   *     attr2: Sequelize.INTEGER,\n   *     attr3: {\n   *       type: Sequelize.BOOLEAN,\n   *       defaultValue: false,\n   *       allowNull: false\n   *     },\n   *     //foreign key usage\n   *     attr4: {\n   *       type: Sequelize.INTEGER,\n   *       references: {\n   *         model: 'another_table_name',\n   *         key: 'id'\n   *       },\n   *       onUpdate: 'cascade',\n   *       onDelete: 'cascade'\n   *     }\n   *   },\n   *   {\n   *     engine: 'MYISAM',    // default: 'InnoDB'\n   *     charset: 'latin1',   // default: null\n   *     schema: 'public',    // default: public, PostgreSQL only.\n   *     comment: 'my table', // comment for table\n   *     collate: 'latin1_danish_ci' // collation, MYSQL only\n   *   }\n   * )\n   * ```\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {Object} attributes Object representing a list of table attributes to create\n   * @param {Object} [options] create table and query options\n   * @param {Model}  [model] model class\n   *\n   * @returns {Promise}\n   */\n\n\n  createTable(tableName, attributes, options, model) {\n    let sql = '';\n    let promise;\n    options = _.clone(options) || {};\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === undefined) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = _.mapValues(attributes, attribute => this.sequelize.normalizeAttribute(attribute)); // Postgres requires special SQL commands for ENUM/ENUM[]\n\n    if (this.sequelize.options.dialect === 'postgres') {\n      promise = PostgresQueryInterface.ensureEnums(this, tableName, attributes, options, model);\n    } else {\n      promise = Promise.resolve();\n    }\n\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.QueryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.QueryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: 'createTable'\n    });\n    sql = this.QueryGenerator.createTableQuery(tableName, attributes, options);\n    return promise.then(() => this.sequelize.query(sql, options));\n  }\n  /**\n   * Drop a table from database\n   *\n   * @param {string} tableName Table name to drop\n   * @param {Object} options   Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  dropTable(tableName, options) {\n    // if we're forcing we should be cascading unless explicitly stated otherwise\n    options = _.clone(options) || {};\n    options.cascade = options.cascade || options.force || false;\n    let sql = this.QueryGenerator.dropTableQuery(tableName, options);\n    return this.sequelize.query(sql, options).then(() => {\n      const promises = []; // Since postgres has a special case for enums, we should drop the related\n      // enum type within the table and attribute\n\n      if (this.sequelize.options.dialect === 'postgres') {\n        const instanceTable = this.sequelize.modelManager.getModel(tableName, {\n          attribute: 'tableName'\n        });\n\n        if (instanceTable) {\n          const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : \"\".concat(options.schema, \"_\")) + tableName;\n          const keys = Object.keys(instanceTable.rawAttributes);\n          const keyLen = keys.length;\n\n          for (let i = 0; i < keyLen; i++) {\n            if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n              sql = this.QueryGenerator.pgEnumDrop(getTableName, keys[i]);\n              options.supportsSearchPath = false;\n              promises.push(this.sequelize.query(sql, Object.assign({}, options, {\n                raw: true\n              })));\n            }\n          }\n        }\n      }\n\n      return Promise.all(promises).get(0);\n    });\n  }\n  /**\n   * Drop all tables from database\n   *\n   * @param {Object} [options] query options\n   * @param {Array}  [options.skip] List of table to skip\n   *\n   * @returns {Promise}\n   */\n\n\n  dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n\n    const dropAllTables = tableNames => Promise.each(tableNames, tableName => {\n      // if tableName is not in the Array of tables names then don't drop it\n      if (!skip.includes(tableName.tableName || tableName)) {\n        return this.dropTable(tableName, Object.assign({}, options, {\n          cascade: true\n        }));\n      }\n    });\n\n    return this.showAllTables(options).then(tableNames => {\n      if (this.sequelize.options.dialect === 'sqlite') {\n        return this.sequelize.query('PRAGMA foreign_keys;', options).then(result => {\n          const foreignKeysAreEnabled = result.foreign_keys === 1;\n\n          if (foreignKeysAreEnabled) {\n            return this.sequelize.query('PRAGMA foreign_keys = OFF', options).then(() => dropAllTables(tableNames)).then(() => this.sequelize.query('PRAGMA foreign_keys = ON', options));\n          }\n\n          return dropAllTables(tableNames);\n        });\n      }\n\n      return this.getForeignKeysForTables(tableNames, options).then(foreignKeys => {\n        const queries = [];\n        tableNames.forEach(tableName => {\n          let normalizedTableName = tableName;\n\n          if (_.isObject(tableName)) {\n            normalizedTableName = \"\".concat(tableName.schema, \".\").concat(tableName.tableName);\n          }\n\n          foreignKeys[normalizedTableName].forEach(foreignKey => {\n            queries.push(this.QueryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n          });\n        });\n        return Promise.each(queries, q => this.sequelize.query(q, options)).then(() => dropAllTables(tableNames));\n      });\n    });\n  }\n  /**\n   * Drop specified enum from database (Postgres only)\n   *\n   * @param {string} [enumName]  Enum name to drop\n   * @param {Object} options Query options\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\n  dropEnum(enumName, options) {\n    if (this.sequelize.getDialect() !== 'postgres') {\n      return Promise.resolve();\n    }\n\n    options = options || {};\n    return this.sequelize.query(this.QueryGenerator.pgEnumDrop(null, null, this.QueryGenerator.pgEscapeAndQuote(enumName)), Object.assign({}, options, {\n      raw: true\n    }));\n  }\n  /**\n   * Drop all enums from database (Postgres only)\n   *\n   * @param {Object} options Query options\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\n  dropAllEnums(options) {\n    if (this.sequelize.getDialect() !== 'postgres') {\n      return Promise.resolve();\n    }\n\n    options = options || {};\n    return this.pgListEnums(null, options).map(result => this.sequelize.query(this.QueryGenerator.pgEnumDrop(null, null, this.QueryGenerator.pgEscapeAndQuote(result.enum_name)), Object.assign({}, options, {\n      raw: true\n    })));\n  }\n  /**\n   * List all enums (Postgres only)\n   *\n   * @param {string} [tableName]  Table whose enum to list\n   * @param {Object} [options]    Query options\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\n  pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, Object.assign({}, options, {\n      plain: false,\n      raw: true,\n      type: QueryTypes.SELECT\n    }));\n  }\n  /**\n   * Rename a table\n   *\n   * @param {string} before    Current name of table\n   * @param {string} after     New name from table\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.renameTableQuery(before, after);\n    return this.sequelize.query(sql, options);\n  }\n  /**\n   * Get all tables in current database\n   *\n   * @param {Object}    [options] Query options\n   * @param {boolean}   [options.raw=true] Run query in raw mode\n   * @param {QueryType} [options.type=QueryType.SHOWTABLE] query type\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n\n\n  showAllTables(options) {\n    options = Object.assign({}, options, {\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    });\n    const showTablesSql = this.QueryGenerator.showTablesQuery(this.sequelize.config.database);\n    return this.sequelize.query(showTablesSql, options).then(tableNames => _.flatten(tableNames));\n  }\n  /**\n   * Describe a table structure\n   *\n   * This method returns an array of hashes containing information about all attributes in the table.\n   *\n   * ```js\n   * {\n   *    name: {\n   *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!\n   *      allowNull:    true,\n   *      defaultValue: null\n   *    },\n   *    isBetaMember: {\n   *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!\n   *      allowNull:    false,\n   *      defaultValue: false\n   *    }\n   * }\n   * ```\n   *\n   * @param {string} tableName table name\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise<Object>}\n   */\n\n\n  describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === 'string') {\n      schema = options;\n    } else if (typeof options === 'object' && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === 'object' && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.QueryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = Object.assign({}, options, {\n      type: QueryTypes.DESCRIBE\n    });\n    return this.sequelize.query(sql, options).then(data => {\n      /*\n       * If no data is returned from the query, then the table name may be wrong.\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n       */\n      if (_.isEmpty(data)) {\n        throw new Error(\"No description found for \\\"\".concat(tableName, \"\\\" table. Check the table name and schema; remember, they _are_ case sensitive.\"));\n      }\n\n      return data;\n    }).catch(e => {\n      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n        throw Error(\"No description found for \\\"\".concat(tableName, \"\\\" table. Check the table name and schema; remember, they _are_ case sensitive.\"));\n      }\n\n      throw e;\n    });\n  }\n  /**\n   * Add a new column to a table\n   *\n   * ```js\n   * queryInterface.addColumn('tableA', 'columnC', Sequelize.STRING, {\n   *    after: 'columnB' // after option is only supported by MySQL\n   * });\n   * ```\n   *\n   * @param {string} table     Table to add column to\n   * @param {string} key       Column name\n   * @param {Object} attribute Attribute definition\n   * @param {Object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error('addColumn takes at least 3 arguments (table, attribute name, attribute definition)');\n    }\n\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return this.sequelize.query(this.QueryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n  /**\n   * Remove a column from a table\n   *\n   * @param {string} tableName      Table to remove column from\n   * @param {string} attributeName  Column name to remove\n   * @param {Object} [options]      Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  removeColumn(tableName, attributeName, options) {\n    options = options || {};\n\n    switch (this.sequelize.options.dialect) {\n      case 'sqlite':\n        // sqlite needs some special treatment as it cannot drop a column\n        return SQLiteQueryInterface.removeColumn(this, tableName, attributeName, options);\n\n      case 'mssql':\n        // mssql needs special treatment as it cannot drop a column with a default or foreign key constraint\n        return MSSQLQueryInterface.removeColumn(this, tableName, attributeName, options);\n\n      case 'mysql':\n      case 'mariadb':\n        // mysql/mariadb need special treatment as it cannot drop a column with a foreign key constraint\n        return MySQLQueryInterface.removeColumn(this, tableName, attributeName, options);\n\n      default:\n        return this.sequelize.query(this.QueryGenerator.removeColumnQuery(tableName, attributeName), options);\n    }\n  }\n  /**\n   * Change a column definition\n   *\n   * @param {string} tableName          Table name to change from\n   * @param {string} attributeName      Column name\n   * @param {Object} dataTypeOrOptions  Attribute definition for new column\n   * @param {Object} [options]          Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    const attributes = {};\n    options = options || {};\n\n    if (_.values(DataTypes).includes(dataTypeOrOptions)) {\n      attributes[attributeName] = {\n        type: dataTypeOrOptions,\n        allowNull: true\n      };\n    } else {\n      attributes[attributeName] = dataTypeOrOptions;\n    }\n\n    attributes[attributeName] = this.sequelize.normalizeAttribute(attributes[attributeName]);\n\n    if (this.sequelize.options.dialect === 'sqlite') {\n      // sqlite needs some special treatment as it cannot change a column\n      return SQLiteQueryInterface.changeColumn(this, tableName, attributes, options);\n    }\n\n    const query = this.QueryGenerator.attributesToSQL(attributes, {\n      context: 'changeColumn',\n      table: tableName\n    });\n    const sql = this.QueryGenerator.changeColumnQuery(tableName, query);\n    return this.sequelize.query(sql, options);\n  }\n  /**\n   * Rename a column\n   *\n   * @param {string} tableName        Table name whose column to rename\n   * @param {string} attrNameBefore   Current column name\n   * @param {string} attrNameAfter    New column name\n   * @param {Object} [options]        Query option\n   *\n   * @returns {Promise}\n   */\n\n\n  renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    return this.describeTable(tableName, options).then(data => {\n      if (!data[attrNameBefore]) {\n        throw new Error(\"Table \".concat(tableName, \" doesn't have the column \").concat(attrNameBefore));\n      }\n\n      data = data[attrNameBefore] || {};\n      const _options = {};\n      _options[attrNameAfter] = {\n        attribute: attrNameAfter,\n        type: data.type,\n        allowNull: data.allowNull,\n        defaultValue: data.defaultValue\n      }; // fix: a not-null column cannot have null as default value\n\n      if (data.defaultValue === null && !data.allowNull) {\n        delete _options[attrNameAfter].defaultValue;\n      }\n\n      if (this.sequelize.options.dialect === 'sqlite') {\n        // sqlite needs some special treatment as it cannot rename a column\n        return SQLiteQueryInterface.renameColumn(this, tableName, attrNameBefore, attrNameAfter, options);\n      }\n\n      const sql = this.QueryGenerator.renameColumnQuery(tableName, attrNameBefore, this.QueryGenerator.attributesToSQL(_options));\n      return this.sequelize.query(sql, options);\n    });\n  }\n  /**\n   * Add an index to a column\n   *\n   * @param {string|Object}  tableName Table name to add index on, can be a object with schema\n   * @param {Array}   [attributes]     Use options.fields instead, List of attributes to add index on\n   * @param {Object}  options          indexes options\n   * @param {Array}   options.fields   List of attributes to add index on\n   * @param {boolean} [options.concurrently] Pass CONCURRENT so other operations run while the index is created\n   * @param {boolean} [options.unique] Create a unique index\n   * @param {string}  [options.using]  Useful for GIN indexes\n   * @param {string}  [options.operator] Index operator\n   * @param {string}  [options.type]   Type of index, available options are UNIQUE|FULLTEXT|SPATIAL\n   * @param {string}  [options.name]   Name of the index. Default is <table>_<attr1>_<attr2>\n   * @param {Object}  [options.where]  Where condition on index, for partial indexes\n   * @param {string}  [rawTablename]   table name, this is just for backward compatibiity\n   *\n   * @returns {Promise}\n   */\n\n\n  addIndex(tableName, attributes, options, rawTablename) {\n    // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n\n    if (!rawTablename) {\n      // Map for backwards compat\n      rawTablename = tableName;\n    }\n\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.QueryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return this.sequelize.query(sql, Object.assign({}, options, {\n      supportsSearchPath: false\n    }));\n  }\n  /**\n   * Show indexes on a table\n   *\n   * @param {string} tableName table name\n   * @param {Object} [options]   Query options\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n\n\n  showIndex(tableName, options) {\n    const sql = this.QueryGenerator.showIndexesQuery(tableName, options);\n    return this.sequelize.query(sql, Object.assign({}, options, {\n      type: QueryTypes.SHOWINDEXES\n    }));\n  }\n\n  getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return Promise.resolve({});\n    }\n\n    options = Object.assign({}, options || {}, {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    return Promise.map(tableNames, tableName => this.sequelize.query(this.QueryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)).then(results => {\n      const result = {};\n      tableNames.forEach((tableName, i) => {\n        if (_.isObject(tableName)) {\n          tableName = \"\".concat(tableName.schema, \".\").concat(tableName.tableName);\n        }\n\n        result[tableName] = Array.isArray(results[i]) ? results[i].map(r => r.constraint_name) : [results[i] && results[i].constraint_name];\n        result[tableName] = result[tableName].filter(_.identity);\n      });\n      return result;\n    });\n  }\n  /**\n   * Get foreign key references details for the table\n   *\n   * Those details contains constraintSchema, constraintName, constraintCatalog\n   * tableCatalog, tableSchema, tableName, columnName,\n   * referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName.\n   * Remind: constraint informations won't return if it's sqlite.\n   *\n   * @param {string} tableName table name\n   * @param {Object} [options]  Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = Object.assign({}, options, {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const catalogName = this.sequelize.config.database;\n\n    switch (this.sequelize.options.dialect) {\n      case 'sqlite':\n        // sqlite needs some special treatment.\n        return SQLiteQueryInterface.getForeignKeyReferencesForTable(this, tableName, queryOptions);\n\n      case 'postgres':\n        {\n          // postgres needs some special treatment as those field names returned are all lowercase\n          // in order to keep same result with other dialects.\n          const query = this.QueryGenerator.getForeignKeyReferencesQuery(tableName, catalogName);\n          return this.sequelize.query(query, queryOptions).then(result => result.map(Utils.camelizeObjectKeys));\n        }\n\n      case 'mssql':\n      case 'mysql':\n      case 'mariadb':\n      default:\n        {\n          const query = this.QueryGenerator.getForeignKeysQuery(tableName, catalogName);\n          return this.sequelize.query(query, queryOptions);\n        }\n    }\n  }\n  /**\n   * Remove an already existing index from a table\n   *\n   * @param {string} tableName             Table name to drop index from\n   * @param {string} indexNameOrAttributes Index name\n   * @param {Object} [options]             Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.QueryGenerator.removeIndexQuery(tableName, indexNameOrAttributes);\n    return this.sequelize.query(sql, options);\n  }\n  /**\n   * Add a constraint to a table\n   *\n   * Available constraints:\n   * - UNIQUE\n   * - DEFAULT (MSSQL only)\n   * - CHECK (MySQL - Ignored by the database engine )\n   * - FOREIGN KEY\n   * - PRIMARY KEY\n   *\n   * @example <caption>UNIQUE</caption>\n   * queryInterface.addConstraint('Users', ['email'], {\n   *   type: 'unique',\n   *   name: 'custom_unique_constraint_name'\n   * });\n   *\n   * @example <caption>CHECK</caption>\n   * queryInterface.addConstraint('Users', ['roles'], {\n   *   type: 'check',\n   *   where: {\n   *      roles: ['user', 'admin', 'moderator', 'guest']\n   *   }\n   * });\n   *\n   * @example <caption>Default - MSSQL only</caption>\n   * queryInterface.addConstraint('Users', ['roles'], {\n   *    type: 'default',\n   *    defaultValue: 'guest'\n   * });\n   *\n   * @example <caption>Primary Key</caption>\n   * queryInterface.addConstraint('Users', ['username'], {\n   *    type: 'primary key',\n   *    name: 'custom_primary_constraint_name'\n   * });\n   *\n   * @example <caption>Foreign Key</caption>\n   * queryInterface.addConstraint('Posts', ['username'], {\n   *   type: 'foreign key',\n   *   name: 'custom_fkey_constraint_name',\n   *   references: { //Required field\n   *     table: 'target_table_name',\n   *     field: 'target_column_name'\n   *   },\n   *   onDelete: 'cascade',\n   *   onUpdate: 'cascade'\n   * });\n   *\n   * @param {string} tableName                  Table name where you want to add a constraint\n   * @param {Array}  attributes                 Array of column names to apply the constraint over\n   * @param {Object} options                    An object to define the constraint name, type etc\n   * @param {string} options.type               Type of constraint. One of the values in available constraints(case insensitive)\n   * @param {string} [options.name]             Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table & column names\n   * @param {string} [options.defaultValue]     The value for the default constraint\n   * @param {Object} [options.where]            Where clause/expression for the CHECK constraint\n   * @param {Object} [options.references]       Object specifying target table, column name to create foreign key constraint\n   * @param {string} [options.references.table] Target table name\n   * @param {string} [options.references.field] Target column name\n   * @param {string} [rawTablename]             Table name, for backward compatibility\n   *\n   * @returns {Promise}\n   */\n\n\n  addConstraint(tableName, attributes, options, rawTablename) {\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    if (!rawTablename) {\n      // Map for backwards compat\n      rawTablename = tableName;\n    }\n\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n\n    if (this.sequelize.dialect.name === 'sqlite') {\n      return SQLiteQueryInterface.addConstraint(this, tableName, options, rawTablename);\n    }\n\n    const sql = this.QueryGenerator.addConstraintQuery(tableName, options, rawTablename);\n    return this.sequelize.query(sql, options);\n  }\n\n  showConstraint(tableName, constraintName, options) {\n    const sql = this.QueryGenerator.showConstraintsQuery(tableName, constraintName);\n    return this.sequelize.query(sql, Object.assign({}, options, {\n      type: QueryTypes.SHOWCONSTRAINTS\n    }));\n  }\n  /**\n   * Remove a constraint from a table\n   *\n   * @param {string} tableName       Table name to drop constraint from\n   * @param {string} constraintName  Constraint name\n   * @param {Object} options         Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  removeConstraint(tableName, constraintName, options) {\n    options = options || {};\n\n    switch (this.sequelize.options.dialect) {\n      case 'mysql':\n      case 'mariadb':\n        //does not support DROP CONSTRAINT. Instead DROP PRIMARY, FOREIGN KEY, INDEX should be used\n        return MySQLQueryInterface.removeConstraint(this, tableName, constraintName, options);\n\n      case 'sqlite':\n        return SQLiteQueryInterface.removeConstraint(this, tableName, constraintName, options);\n\n      default:\n        const sql = this.QueryGenerator.removeConstraintQuery(tableName, constraintName);\n        return this.sequelize.query(sql, options);\n    }\n  }\n\n  insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.QueryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n    return this.sequelize.query(sql, options).then(results => {\n      if (instance) results[0].isNewRecord = false;\n      return results;\n    });\n  }\n  /**\n   * Upsert\n   *\n   * @param {string} tableName    table to upsert on\n   * @param {Object} insertValues values to be inserted, mapped to field name\n   * @param {Object} updateValues values to be updated, mapped to field name\n   * @param {Object} where        various conditions\n   * @param {Model}  model        Model to upsert on\n   * @param {Object} options      query options\n   *\n   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>\n   */\n\n\n  upsert(tableName, insertValues, updateValues, where, model, options) {\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n    options = _.clone(options);\n\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    } // Lets combine unique keys and indexes into one\n\n\n    indexes = _.map(model.uniqueKeys, value => {\n      return value.fields;\n    });\n\n    model._indexes.forEach(value => {\n      if (value.unique) {\n        // fields in the index may both the strings or objects with an attribute property - lets sanitize that\n        indexFields = value.fields.map(field => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n\n        wheres.push(where);\n      }\n    }\n\n    where = {\n      [Op.or]: wheres\n    };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.QueryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    return this.sequelize.query(sql, options).then(result => {\n      switch (this.sequelize.options.dialect) {\n        case 'postgres':\n          return [result.created, result.primary_key];\n\n        case 'mssql':\n          return [result.$action === 'INSERT', result[model.primaryKeyField]];\n        // MySQL returns 1 for inserted, 2 for updated\n        // http://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html.\n\n        case 'mysql':\n        case 'mariadb':\n          return [result === 1, undefined];\n\n        default:\n          return [result, undefined];\n      }\n    });\n  }\n  /**\n   * Insert multiple records into a table\n   *\n   * @example\n   * queryInterface.bulkInsert('roles', [{\n   *    label: 'user',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }, {\n   *    label: 'admin',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }]);\n   *\n   * @param {string} tableName   Table name to insert record to\n   * @param {Array}  records     List of records to insert\n   * @param {Object} options     Various options, please see Model.bulkCreate options\n   * @param {Object} attributes  Various attributes mapped by field name\n   *\n   * @returns {Promise}\n   */\n\n\n  bulkInsert(tableName, records, options, attributes) {\n    options = _.clone(options) || {};\n    options.type = QueryTypes.INSERT;\n    return this.sequelize.query(this.QueryGenerator.bulkInsertQuery(tableName, records, options, attributes), options).then(results => results[0]);\n  }\n\n  update(instance, tableName, values, identifier, options) {\n    options = _.clone(options || {});\n    options.hasTrigger = !!(instance && instance._modelOptions && instance._modelOptions.hasTrigger);\n    const sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);\n    options.type = QueryTypes.UPDATE;\n    options.instance = instance;\n    return this.sequelize.query(sql, options);\n  }\n  /**\n   * Update multiple records of a table\n   *\n   * @example\n   * queryInterface.bulkUpdate('roles', {\n   *     label: 'admin',\n   *   }, {\n   *     userType: 3,\n   *   },\n   * );\n   *\n   * @param {string} tableName     Table name to update\n   * @param {Object} values        Values to be inserted, mapped to field name\n   * @param {Object} identifier    A hash with conditions OR an ID as integer OR a string with conditions\n   * @param {Object} [options]     Various options, please see Model.bulkCreate options\n   * @param {Object} [attributes]  Attributes on return objects if supported by SQL dialect\n   *\n   * @returns {Promise}\n   */\n\n\n  bulkUpdate(tableName, values, identifier, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n    const sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, attributes);\n    const table = _.isObject(tableName) ? tableName : {\n      tableName\n    };\n\n    const model = _.find(this.sequelize.modelManager.models, {\n      tableName: table.tableName\n    });\n\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return this.sequelize.query(sql, options);\n  }\n\n  delete(instance, tableName, identifier, options) {\n    const cascades = [];\n    const sql = this.QueryGenerator.deleteQuery(tableName, identifier, {}, instance.constructor);\n    options = _.clone(options) || {}; // Check for a restrict field\n\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n\n        if (association.options && association.options.onDelete && association.options.onDelete.toLowerCase() === 'cascade' && association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n\n    return Promise.each(cascades, cascade => {\n      return instance[cascade](options).then(instances => {\n        // Check for hasOne relationship with non-existing associate (\"has zero\")\n        if (!instances) {\n          return Promise.resolve();\n        }\n\n        if (!Array.isArray(instances)) instances = [instances];\n        return Promise.each(instances, instance => instance.destroy(options));\n      });\n    }).then(() => {\n      options.instance = instance;\n      return this.sequelize.query(sql, options);\n    });\n  }\n  /**\n   * Delete multiple records from a table\n   *\n   * @param {string}  tableName            table name from where to delete records\n   * @param {Object}  where                where conditions to find records to delete\n   * @param {Object}  [options]            options\n   * @param {boolean} [options.truncate]   Use truncate table command   \n   * @param {boolean} [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n   * @param {boolean} [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.\n   * @param {Model}   [model]              Model\n   *\n   * @returns {Promise}\n   */\n\n\n  bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      limit: null\n    });\n\n    if (options.truncate === true) {\n      return this.sequelize.query(this.QueryGenerator.truncateTableQuery(tableName, options), options);\n    }\n\n    if (typeof identifier === 'object') where = Utils.cloneDeep(where);\n    return this.sequelize.query(this.QueryGenerator.deleteQuery(tableName, where, options, model), options);\n  }\n\n  select(model, tableName, optionsArg) {\n    const options = Object.assign({}, optionsArg, {\n      type: QueryTypes.SELECT,\n      model\n    });\n    return this.sequelize.query(this.QueryGenerator.selectQuery(tableName, options, model), options);\n  }\n\n  increment(model, tableName, values, identifier, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.QueryGenerator.arithmeticQuery('+', tableName, values, identifier, options, options.attributes);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return this.sequelize.query(sql, options);\n  }\n\n  decrement(model, tableName, values, identifier, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.QueryGenerator.arithmeticQuery('-', tableName, values, identifier, options, options.attributes);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return this.sequelize.query(sql, options);\n  }\n\n  rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n    const sql = this.QueryGenerator.selectQuery(tableName, options, Model);\n\n    if (attributeSelector === undefined) {\n      throw new Error('Please pass an attribute selector!');\n    }\n\n    return this.sequelize.query(sql, options).then(data => {\n      if (!options.plain) {\n        return data;\n      }\n\n      const result = data ? data[attributeSelector] : null;\n\n      if (!options || !options.dataType) {\n        return result;\n      }\n\n      const dataType = options.dataType;\n\n      if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n        if (result !== null) {\n          return parseFloat(result);\n        }\n      }\n\n      if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n        return parseInt(result, 10);\n      }\n\n      if (dataType instanceof DataTypes.DATE) {\n        if (result !== null && !(result instanceof Date)) {\n          return new Date(result);\n        }\n      }\n\n      return result;\n    });\n  }\n\n  createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n    const sql = this.QueryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n\n    return Promise.resolve();\n  }\n\n  dropTrigger(tableName, triggerName, options) {\n    const sql = this.QueryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n\n    return Promise.resolve();\n  }\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.QueryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Create an SQL function\n   *\n   * @example\n   * queryInterface.createFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'integer', name: 'param', direction: 'IN'}\n   *   ],\n   *   'integer',\n   *   'plpgsql',\n   *   'RETURN param + 1;',\n   *   [\n   *     'IMMUTABLE',\n   *     'LEAKPROOF'\n   *   ],\n   *   {\n   *    variables:\n   *      [\n   *        {type: 'integer', name: 'myVar', default: 100}\n   *      ],\n   *      force: true\n   *   };\n   * );\n   *\n   * @param {string}  functionName  Name of SQL function to create\n   * @param {Array}   params        List of parameters declared for SQL function\n   * @param {string}  returnType    SQL type of function returned value\n   * @param {string}  language      The name of the language that the function is implemented in\n   * @param {string}  body          Source code of function\n   * @param {Array}   optionsArray  Extra-options for creation\n   * @param {Object}  [options]     query options\n   * @param {boolean} options.force If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false\n   * @param {Array<Object>}   options.variables List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well.\n   *\n   * @returns {Promise}\n   */\n\n\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.QueryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Drop an SQL function\n   *\n   * @example\n   * queryInterface.dropFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ]\n   * );\n   *\n   * @param {string} functionName Name of SQL function to drop\n   * @param {Array}  params       List of parameters declared for SQL function\n   * @param {Object} [options]    query options\n   *\n   * @returns {Promise}\n   */\n\n\n  dropFunction(functionName, params, options) {\n    const sql = this.QueryGenerator.dropFunction(functionName, params);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Rename an SQL function\n   *\n   * @example\n   * queryInterface.renameFunction(\n   *   'fooFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ],\n   *   'barFunction'\n   * );\n   *\n   * @param {string} oldFunctionName  Current name of function\n   * @param {Array}  params           List of parameters declared for SQL function\n   * @param {string} newFunctionName  New name of function\n   * @param {Object} [options]        query options\n   *\n   * @returns {Promise}\n   */\n\n\n  renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.QueryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n\n    return Promise.resolve();\n  } // Helper methods useful for querying\n\n  /**\n   * Escape an identifier (e.g. a table or attribute name)\n   *\n   * @param {string} identifier identifier to quote\n   * @param {boolean} [force]   If force is true,the identifier will be quoted even if the `quoteIdentifiers` option is false.\n   *\n   * @private\n   */\n\n\n  quoteIdentifier(identifier, force) {\n    return this.QueryGenerator.quoteIdentifier(identifier, force);\n  }\n\n  quoteTable(identifier) {\n    return this.QueryGenerator.quoteTable(identifier);\n  }\n  /**\n   * Quote array of identifiers at once\n   *\n   * @param {string[]} identifiers array of identifiers to quote\n   * @param {boolean} [force]   If force is true,the identifier will be quoted even if the `quoteIdentifiers` option is false.\n   *\n   * @private\n   */\n\n\n  quoteIdentifiers(identifiers, force) {\n    return this.QueryGenerator.quoteIdentifiers(identifiers, force);\n  }\n  /**\n   * Escape a value (e.g. a string, number or date)\n   *\n   * @param {string} value string to escape\n   *\n   * @private\n   */\n\n\n  escape(value) {\n    return this.QueryGenerator.escape(value);\n  }\n\n  setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to set isolation level for a transaction without transaction object!');\n    }\n\n    if (transaction.parent || !value) {\n      // Not possible to set a separate isolation level for savepoints\n      return Promise.resolve();\n    }\n\n    options = Object.assign({}, options, {\n      transaction: transaction.parent || transaction\n    });\n    const sql = this.QueryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n    if (!sql) return Promise.resolve();\n    return this.sequelize.query(sql, options);\n  }\n\n  startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to start a transaction without transaction object!');\n    }\n\n    options = Object.assign({}, options, {\n      transaction: transaction.parent || transaction\n    });\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.QueryGenerator.startTransactionQuery(transaction);\n    return this.sequelize.query(sql, options);\n  }\n\n  deferConstraints(transaction, options) {\n    options = Object.assign({}, options, {\n      transaction: transaction.parent || transaction\n    });\n    const sql = this.QueryGenerator.deferConstraintsQuery(options);\n\n    if (sql) {\n      return this.sequelize.query(sql, options);\n    }\n\n    return Promise.resolve();\n  }\n\n  commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to commit a transaction without transaction object!');\n    }\n\n    if (transaction.parent) {\n      // Savepoints cannot be committed\n      return Promise.resolve();\n    }\n\n    options = Object.assign({}, options, {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    const sql = this.QueryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = 'commit';\n    return promise;\n  }\n\n  rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to rollback a transaction without transaction object!');\n    }\n\n    options = Object.assign({}, options, {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.QueryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = 'rollback';\n    return promise;\n  }\n\n}\n\nmodule.exports = QueryInterface;\nmodule.exports.QueryInterface = QueryInterface;\nmodule.exports.default = QueryInterface;","map":null,"metadata":{},"sourceType":"script"}