{"ast":null,"code":"'use strict';\n\nconst dataTypes = require('./data-types');\n\nconst _require = require('./utils/logger'),\n      logger = _require.logger;\n\nfunction arrayToList(array, timeZone, dialect, format) {\n  return array.reduce((sql, val, i) => {\n    if (i !== 0) {\n      sql += ', ';\n    }\n\n    if (Array.isArray(val)) {\n      sql += \"(\".concat(arrayToList(val, timeZone, dialect, format), \")\");\n    } else {\n      sql += escape(val, timeZone, dialect, format);\n    }\n\n    return sql;\n  }, '');\n}\n\nexports.arrayToList = arrayToList;\n\nfunction escape(val, timeZone, dialect, format) {\n  let prependN = false;\n\n  if (val === undefined || val === null) {\n    return 'NULL';\n  }\n\n  switch (typeof val) {\n    case 'boolean':\n      // SQLite doesn't have true/false support. MySQL aliases true/false to 1/0\n      // for us. Postgres actually has a boolean type with true/false literals,\n      // but sequelize doesn't use it yet.\n      if (dialect === 'sqlite' || dialect === 'mssql') {\n        return +!!val;\n      }\n\n      return (!!val).toString();\n\n    case 'number':\n      return val.toString();\n\n    case 'string':\n      // In mssql, prepend N to all quoted vals which are originally a string (for\n      // unicode compatibility)\n      prependN = dialect === 'mssql';\n      break;\n  }\n\n  if (val instanceof Date) {\n    val = dataTypes[dialect].DATE.prototype.stringify(val, {\n      timezone: timeZone\n    });\n  }\n\n  if (Buffer.isBuffer(val)) {\n    if (dataTypes[dialect].BLOB) {\n      return dataTypes[dialect].BLOB.prototype.stringify(val);\n    }\n\n    return dataTypes.BLOB.prototype.stringify(val);\n  }\n\n  if (Array.isArray(val)) {\n    const partialEscape = escVal => escape(escVal, timeZone, dialect, format);\n\n    if (dialect === 'postgres' && !format) {\n      return dataTypes.ARRAY.prototype.stringify(val, {\n        escape: partialEscape\n      });\n    }\n\n    return arrayToList(val, timeZone, dialect, format);\n  }\n\n  if (!val.replace) {\n    throw new Error(\"Invalid value \".concat(logger.inspect(val)));\n  }\n\n  if (dialect === 'postgres' || dialect === 'sqlite' || dialect === 'mssql') {\n    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS\n    // http://stackoverflow.com/q/603572/130598\n    val = val.replace(/'/g, \"''\");\n\n    if (dialect === 'postgres') {\n      // null character is not allowed in Postgres\n      val = val.replace(/\\0/g, '\\\\0');\n    }\n  } else {\n    // eslint-disable-next-line no-control-regex\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\'\"\\x1a]/g, s => {\n      switch (s) {\n        case '\\0':\n          return '\\\\0';\n\n        case '\\n':\n          return '\\\\n';\n\n        case '\\r':\n          return '\\\\r';\n\n        case '\\b':\n          return '\\\\b';\n\n        case '\\t':\n          return '\\\\t';\n\n        case '\\x1a':\n          return '\\\\Z';\n\n        default:\n          return \"\\\\\".concat(s);\n      }\n    });\n  }\n\n  return \"\".concat((prependN ? \"N'\" : \"'\") + val, \"'\");\n}\n\nexports.escape = escape;\n\nfunction format(sql, values, timeZone, dialect) {\n  values = [].concat(values);\n\n  if (typeof sql !== 'string') {\n    throw new Error(\"Invalid SQL string provided: \".concat(sql));\n  }\n\n  return sql.replace(/\\?/g, match => {\n    if (!values.length) {\n      return match;\n    }\n\n    return escape(values.shift(), timeZone, dialect, true);\n  });\n}\n\nexports.format = format;\n\nfunction formatNamedParameters(sql, values, timeZone, dialect) {\n  return sql.replace(/:+(?!\\d)(\\w+)/g, (value, key) => {\n    if ('postgres' === dialect && '::' === value.slice(0, 2)) {\n      return value;\n    }\n\n    if (values[key] !== undefined) {\n      return escape(values[key], timeZone, dialect, true);\n    }\n\n    throw new Error(\"Named parameter \\\"\".concat(value, \"\\\" has no value in the given object.\"));\n  });\n}\n\nexports.formatNamedParameters = formatNamedParameters;","map":null,"metadata":{},"sourceType":"script"}