{"ast":null,"code":"\"use strict\";\n\nconst Sender = require('./sender').Sender;\n\nconst SQL_SERVER_BROWSER_PORT = 1434;\nconst TIMEOUT = 2 * 1000;\nconst RETRIES = 3; // There are three bytes at the start of the response, whose purpose is unknown.\n\nconst MYSTERY_HEADER_LENGTH = 3; // Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\n\nclass InstanceLookup {\n  constructor() {} // Wrapper allows for stubbing Sender when unit testing instance-lookup.\n\n\n  createSender(host, port, request) {\n    return new Sender(host, port, request);\n  }\n\n  instanceLookup(options, callback) {\n    const server = options.server;\n\n    if (typeof server !== 'string') {\n      throw new TypeError('Invalid arguments: \"server\" must be a string');\n    }\n\n    const instanceName = options.instanceName;\n\n    if (typeof instanceName !== 'string') {\n      throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n    }\n\n    const timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n\n    if (typeof timeout !== 'number') {\n      throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n    }\n\n    const retries = options.retries === undefined ? RETRIES : options.retries;\n\n    if (typeof retries !== 'number') {\n      throw new TypeError('Invalid arguments: \"retries\" must be a number');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Invalid arguments: \"callback\" must be a function');\n    }\n\n    let sender,\n        timer,\n        retriesLeft = retries;\n\n    const onTimeout = () => {\n      sender.cancel();\n      makeAttempt();\n    };\n\n    const makeAttempt = () => {\n      if (retriesLeft > 0) {\n        retriesLeft--;\n        const request = Buffer.from([0x02]);\n        sender = this.createSender(options.server, SQL_SERVER_BROWSER_PORT, request);\n        sender.execute((err, message) => {\n          clearTimeout(timer);\n\n          if (err) {\n            callback('Failed to lookup instance on ' + server + ' - ' + err.message);\n            return;\n          } else {\n            message = message.toString('ascii', MYSTERY_HEADER_LENGTH);\n            const port = this.parseBrowserResponse(message, instanceName);\n\n            if (port) {\n              callback(undefined, port);\n            } else {\n              callback('Port for ' + instanceName + ' not found in ' + options.server);\n            }\n          }\n        });\n        timer = setTimeout(onTimeout, timeout);\n      } else {\n        callback('Failed to get response from SQL Server Browser on ' + server);\n      }\n    };\n\n    makeAttempt();\n  }\n\n  parseBrowserResponse(response, instanceName) {\n    let getPort;\n    const instances = response.split(';;');\n\n    for (let i = 0, len = instances.length; i < len; i++) {\n      const instance = instances[i];\n      const parts = instance.split(';');\n\n      for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n        const name = parts[p];\n        const value = parts[p + 1];\n\n        if (name === 'tcp' && getPort) {\n          const port = parseInt(value, 10);\n          return port;\n        }\n\n        if (name === 'InstanceName') {\n          if (value.toUpperCase() === instanceName.toUpperCase()) {\n            getPort = true;\n          } else {\n            getPort = false;\n          }\n        }\n      }\n    }\n  }\n\n}\n\nmodule.exports.InstanceLookup = InstanceLookup;","map":null,"metadata":{},"sourceType":"script"}