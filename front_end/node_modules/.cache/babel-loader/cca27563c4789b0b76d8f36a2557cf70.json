{"ast":null,"code":"module.exports = LineString;\n\nvar util = require('util');\n\nvar Geometry = require('./geometry');\n\nvar Types = require('./types');\n\nvar Point = require('./point');\n\nvar BinaryWriter = require('./binarywriter');\n\nfunction LineString(points, srid) {\n  Geometry.call(this);\n  this.points = points || [];\n  this.srid = srid;\n\n  if (this.points.length > 0) {\n    this.hasZ = this.points[0].hasZ;\n    this.hasM = this.points[0].hasM;\n  }\n}\n\nutil.inherits(LineString, Geometry);\n\nLineString.Z = function (points, srid) {\n  var lineString = new LineString(points, srid);\n  lineString.hasZ = true;\n  return lineString;\n};\n\nLineString.M = function (points, srid) {\n  var lineString = new LineString(points, srid);\n  lineString.hasM = true;\n  return lineString;\n};\n\nLineString.ZM = function (points, srid) {\n  var lineString = new LineString(points, srid);\n  lineString.hasZ = true;\n  lineString.hasM = true;\n  return lineString;\n};\n\nLineString._parseWkt = function (value, options) {\n  var lineString = new LineString();\n  lineString.srid = options.srid;\n  lineString.hasZ = options.hasZ;\n  lineString.hasM = options.hasM;\n  if (value.isMatch(['EMPTY'])) return lineString;\n  value.expectGroupStart();\n  lineString.points.push.apply(lineString.points, value.matchCoordinates(options));\n  value.expectGroupEnd();\n  return lineString;\n};\n\nLineString._parseWkb = function (value, options) {\n  var lineString = new LineString();\n  lineString.srid = options.srid;\n  lineString.hasZ = options.hasZ;\n  lineString.hasM = options.hasM;\n  var pointCount = value.readUInt32();\n\n  for (var i = 0; i < pointCount; i++) lineString.points.push(Point._readWkbPoint(value, options));\n\n  return lineString;\n};\n\nLineString._parseTwkb = function (value, options) {\n  var lineString = new LineString();\n  lineString.hasZ = options.hasZ;\n  lineString.hasM = options.hasM;\n  if (options.isEmpty) return lineString;\n  var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);\n  var pointCount = value.readVarInt();\n\n  for (var i = 0; i < pointCount; i++) lineString.points.push(Point._readTwkbPoint(value, options, previousPoint));\n\n  return lineString;\n};\n\nLineString._parseGeoJSON = function (value) {\n  var lineString = new LineString();\n  if (value.coordinates.length > 0) lineString.hasZ = value.coordinates[0].length > 2;\n\n  for (var i = 0; i < value.coordinates.length; i++) lineString.points.push(Point._readGeoJSONPoint(value.coordinates[i]));\n\n  return lineString;\n};\n\nLineString.prototype.toWkt = function () {\n  if (this.points.length === 0) return this._getWktType(Types.wkt.LineString, true);\n  return this._getWktType(Types.wkt.LineString, false) + this._toInnerWkt();\n};\n\nLineString.prototype._toInnerWkt = function () {\n  var innerWkt = '(';\n\n  for (var i = 0; i < this.points.length; i++) innerWkt += this._getWktCoordinate(this.points[i]) + ',';\n\n  innerWkt = innerWkt.slice(0, -1);\n  innerWkt += ')';\n  return innerWkt;\n};\n\nLineString.prototype.toWkb = function (parentOptions) {\n  var wkb = new BinaryWriter(this._getWkbSize());\n  wkb.writeInt8(1);\n\n  this._writeWkbType(wkb, Types.wkb.LineString, parentOptions);\n\n  wkb.writeUInt32LE(this.points.length);\n\n  for (var i = 0; i < this.points.length; i++) this.points[i]._writeWkbPoint(wkb);\n\n  return wkb.buffer;\n};\n\nLineString.prototype.toTwkb = function () {\n  var twkb = new BinaryWriter(0, true);\n  var precision = Geometry.getTwkbPrecision(5, 0, 0);\n  var isEmpty = this.points.length === 0;\n\n  this._writeTwkbHeader(twkb, Types.wkb.LineString, precision, isEmpty);\n\n  if (this.points.length > 0) {\n    twkb.writeVarInt(this.points.length);\n    var previousPoint = new Point(0, 0, 0, 0);\n\n    for (var i = 0; i < this.points.length; i++) this.points[i]._writeTwkbPoint(twkb, precision, previousPoint);\n  }\n\n  return twkb.buffer;\n};\n\nLineString.prototype._getWkbSize = function () {\n  var coordinateSize = 16;\n  if (this.hasZ) coordinateSize += 8;\n  if (this.hasM) coordinateSize += 8;\n  return 1 + 4 + 4 + this.points.length * coordinateSize;\n};\n\nLineString.prototype.toGeoJSON = function (options) {\n  var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);\n  geoJSON.type = Types.geoJSON.LineString;\n  geoJSON.coordinates = [];\n\n  for (var i = 0; i < this.points.length; i++) {\n    if (this.hasZ) geoJSON.coordinates.push([this.points[i].x, this.points[i].y, this.points[i].z]);else geoJSON.coordinates.push([this.points[i].x, this.points[i].y]);\n  }\n\n  return geoJSON;\n};","map":null,"metadata":{},"sourceType":"script"}