{"ast":null,"code":"module.exports = WktParser;\n\nvar Types = require('./types');\n\nvar Point = require('./point');\n\nfunction WktParser(value) {\n  this.value = value;\n  this.position = 0;\n}\n\nWktParser.prototype.match = function (tokens) {\n  this.skipWhitespaces();\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (this.value.substring(this.position).indexOf(tokens[i]) === 0) {\n      this.position += tokens[i].length;\n      return tokens[i];\n    }\n  }\n\n  return null;\n};\n\nWktParser.prototype.matchRegex = function (tokens) {\n  this.skipWhitespaces();\n\n  for (var i = 0; i < tokens.length; i++) {\n    var match = this.value.substring(this.position).match(tokens[i]);\n\n    if (match) {\n      this.position += match[0].length;\n      return match;\n    }\n  }\n\n  return null;\n};\n\nWktParser.prototype.isMatch = function (tokens) {\n  this.skipWhitespaces();\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (this.value.substring(this.position).indexOf(tokens[i]) === 0) {\n      this.position += tokens[i].length;\n      return true;\n    }\n  }\n\n  return false;\n};\n\nWktParser.prototype.matchType = function () {\n  var geometryType = this.match([Types.wkt.Point, Types.wkt.LineString, Types.wkt.Polygon, Types.wkt.MultiPoint, Types.wkt.MultiLineString, Types.wkt.MultiPolygon, Types.wkt.GeometryCollection]);\n  if (!geometryType) throw new Error('Expected geometry type');\n  return geometryType;\n};\n\nWktParser.prototype.matchDimension = function () {\n  var dimension = this.match(['ZM', 'Z', 'M']);\n\n  switch (dimension) {\n    case 'ZM':\n      return {\n        hasZ: true,\n        hasM: true\n      };\n\n    case 'Z':\n      return {\n        hasZ: true,\n        hasM: false\n      };\n\n    case 'M':\n      return {\n        hasZ: false,\n        hasM: true\n      };\n\n    default:\n      return {\n        hasZ: false,\n        hasM: false\n      };\n  }\n};\n\nWktParser.prototype.expectGroupStart = function () {\n  if (!this.isMatch(['('])) throw new Error('Expected group start');\n};\n\nWktParser.prototype.expectGroupEnd = function () {\n  if (!this.isMatch([')'])) throw new Error('Expected group end');\n};\n\nWktParser.prototype.matchCoordinate = function (options) {\n  var match;\n  if (options.hasZ && options.hasM) match = this.matchRegex([/^(\\S*)\\s+(\\S*)\\s+(\\S*)\\s+([^\\s,)]*)/]);else if (options.hasZ || options.hasM) match = this.matchRegex([/^(\\S*)\\s+(\\S*)\\s+([^\\s,)]*)/]);else match = this.matchRegex([/^(\\S*)\\s+([^\\s,)]*)/]);\n  if (!match) throw new Error('Expected coordinates');\n  if (options.hasZ && options.hasM) return new Point(parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]), parseFloat(match[4]));else if (options.hasZ) return new Point(parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]));else if (options.hasM) return new Point(parseFloat(match[1]), parseFloat(match[2]), undefined, parseFloat(match[3]));else return new Point(parseFloat(match[1]), parseFloat(match[2]));\n};\n\nWktParser.prototype.matchCoordinates = function (options) {\n  var coordinates = [];\n\n  do {\n    var startsWithBracket = this.isMatch(['(']);\n    coordinates.push(this.matchCoordinate(options));\n    if (startsWithBracket) this.expectGroupEnd();\n  } while (this.isMatch([',']));\n\n  return coordinates;\n};\n\nWktParser.prototype.skipWhitespaces = function () {\n  while (this.position < this.value.length && this.value[this.position] === ' ') this.position++;\n};","map":null,"metadata":{},"sourceType":"script"}