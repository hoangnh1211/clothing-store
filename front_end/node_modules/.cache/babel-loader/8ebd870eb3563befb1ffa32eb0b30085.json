{"ast":null,"code":"\"use strict\";\n/* globals $Values */\n\nconst tls = require('tls');\n\nconst DuplexPair = require('native-duplexpair');\n\nconst _require = require('events'),\n      EventEmitter = _require.EventEmitter;\n\nconst _require2 = require('./packet'),\n      TYPE = _require2.TYPE;\n\nconst Message = require('./message');\n\nconst IncomingMessageStream = require('./incoming-message-stream');\n\nconst OutgoingMessageStream = require('./outgoing-message-stream');\n\nmodule.exports = class MessageIO extends EventEmitter {\n  constructor(socket, packetSize, debug) {\n    super();\n    this.socket = socket;\n    this.debug = debug;\n    this.tlsNegotiationComplete = false;\n    this.incomingMessageStream = new IncomingMessageStream(this.debug);\n    this.incomingMessageStream.on('data', message => {\n      message.on('data', chunk => {\n        this.emit('data', chunk);\n      });\n      message.on('end', () => {\n        this.emit('message');\n      });\n    });\n    this.outgoingMessageStream = new OutgoingMessageStream(this.debug, {\n      packetSize: packetSize\n    });\n    this.socket.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(this.socket);\n  }\n\n  packetSize(...args) {\n    if (args.length > 0) {\n      const packetSize = args[0];\n      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\n      this.outgoingMessageStream.packetSize = packetSize;\n    }\n\n    return this.outgoingMessageStream.packetSize;\n  }\n\n  startTls(secureContext, hostname, trustServerCertificate) {\n    const duplexpair = new DuplexPair();\n    const securePair = this.securePair = {\n      cleartext: tls.connect({\n        socket: duplexpair.socket1,\n        servername: hostname,\n        secureContext: secureContext,\n        rejectUnauthorized: !trustServerCertificate\n      }),\n      encrypted: duplexpair.socket2\n    }; // If an error happens in the TLS layer, there is nothing we can do about it.\n    // Forward the error to the socket so the connection gets properly cleaned up.\n\n    securePair.cleartext.on('error', err => {\n      // Streams in node.js versions before 8.0.0 don't support `.destroy`\n      if (typeof securePair.encrypted.destroy === 'function') {\n        securePair.encrypted.destroy();\n      }\n\n      this.socket.destroy(err);\n    });\n    securePair.cleartext.on('secureConnect', () => {\n      const cipher = securePair.cleartext.getCipher();\n\n      if (cipher) {\n        this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n      }\n\n      this.emit('secure', securePair.cleartext);\n      this.encryptAllFutureTraffic();\n    });\n    securePair.encrypted.on('data', data => {\n      this.sendMessage(TYPE.PRELOGIN, data, false);\n    });\n  }\n\n  encryptAllFutureTraffic() {\n    this.securePair.encrypted.removeAllListeners('data');\n    this.outgoingMessageStream.unpipe(this.socket);\n    this.socket.unpipe(this.incomingMessageStream);\n    this.socket.pipe(this.securePair.encrypted);\n    this.securePair.encrypted.pipe(this.socket);\n    this.securePair.cleartext.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(this.securePair.cleartext);\n    this.tlsNegotiationComplete = true;\n  }\n\n  tlsHandshakeData(data) {\n    this.securePair.encrypted.write(data);\n  } // TODO listen for 'drain' event when socket.write returns false.\n  // TODO implement incomplete request cancelation (2.2.1.6)\n\n\n  sendMessage(packetType, data, resetConnection) {\n    const message = new Message({\n      type: packetType,\n      resetConnection: resetConnection\n    });\n    message.end(data);\n    this.outgoingMessageStream.write(message);\n  } // Temporarily suspends the flow of incoming packets.\n\n\n  pause() {\n    this.incomingMessageStream.pause();\n  } // Resumes the flow of incoming packets.\n\n\n  resume() {\n    this.incomingMessageStream.resume();\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}