{"ast":null,"code":"'use strict';\n\nconst AbstractQuery = require('../abstract/query');\n\nconst QueryTypes = require('../../query-types');\n\nconst Promise = require('../../promise');\n\nconst sequelizeErrors = require('../../errors');\n\nconst _ = require('lodash');\n\nconst _require = require('../../utils/logger'),\n      logger = _require.logger;\n\nconst debug = logger.debugContext('sql:pg');\n\nclass Query extends AbstractQuery {\n  /**\n   * Rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|Object} values\n   * @param {string} dialect\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    const stringReplaceFunc = value => typeof value === 'string' ? value.replace(/\\0/g, '\\\\0') : value;\n\n    let bindParam;\n\n    if (Array.isArray(values)) {\n      bindParam = values.map(stringReplaceFunc);\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    } else {\n      bindParam = [];\n      let i = 0;\n      const seen = {};\n\n      const replacementFunc = (match, key, values) => {\n        if (seen[key] !== undefined) {\n          return seen[key];\n        }\n\n        if (values[key] !== undefined) {\n          i = i + 1;\n          bindParam.push(stringReplaceFunc(values[key]));\n          seen[key] = \"$\".concat(i);\n          return \"$\".concat(i);\n        }\n\n        return undefined;\n      };\n\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    }\n\n    return [sql, bindParam];\n  }\n\n  run(sql, parameters) {\n    const connection = this.connection;\n\n    if (!_.isEmpty(this.options.searchPath)) {\n      sql = this.sequelize.getQueryInterface().QueryGenerator.setSearchPath(this.options.searchPath) + sql;\n    }\n\n    this.sql = sql;\n    const query = parameters && parameters.length ? new Promise((resolve, reject) => connection.query(sql, parameters, (error, result) => error ? reject(error) : resolve(result))) : new Promise((resolve, reject) => connection.query(sql, (error, result) => error ? reject(error) : resolve(result)));\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return query.catch(err => {\n      // set the client so that it will be reaped if the connection resets while executing\n      if (err.code === 'ECONNRESET') {\n        connection._invalid = true;\n      }\n\n      err.sql = sql;\n      err.parameters = parameters;\n      throw this.formatError(err);\n    }).then(queryResult => {\n      complete();\n      let rows = Array.isArray(queryResult) ? queryResult.reduce((allRows, r) => allRows.concat(r.rows || []), []) : queryResult.rows;\n      const rowCount = Array.isArray(queryResult) ? queryResult.reduce((count, r) => Number.isFinite(r.rowCount) ? count + r.rowCount : count, 0) : queryResult.rowCount;\n\n      if (this.sequelize.options.minifyAliases && this.options.aliasesMapping) {\n        rows = rows.map(row => _.toPairs(row).reduce((acc, [key, value]) => {\n          const mapping = this.options.aliasesMapping.get(key);\n          acc[mapping || key] = value;\n          return acc;\n        }, {}));\n      }\n\n      const isTableNameQuery = sql.startsWith('SELECT table_name FROM information_schema.tables');\n      const isRelNameQuery = sql.startsWith('SELECT relname FROM pg_class WHERE oid IN');\n\n      if (isRelNameQuery) {\n        return rows.map(row => ({\n          name: row.relname,\n          tableName: row.relname.split('_')[0]\n        }));\n      }\n\n      if (isTableNameQuery) {\n        return rows.map(row => _.values(row));\n      }\n\n      if (rows[0] && rows[0].sequelize_caught_exception !== undefined) {\n        if (rows[0].sequelize_caught_exception !== null) {\n          throw this.formatError({\n            code: '23505',\n            detail: rows[0].sequelize_caught_exception\n          });\n        }\n\n        for (const row of rows) {\n          delete row.sequelize_caught_exception;\n        }\n      }\n\n      if (this.isShowIndexesQuery()) {\n        for (const row of rows) {\n          const attributes = /ON .*? (?:USING .*?\\s)?\\(([^]*)\\)/gi.exec(row.definition)[1].split(','); // Map column index in table to column name\n\n          const columns = _.zipObject(row.column_indexes, this.sequelize.getQueryInterface().QueryGenerator.fromArray(row.column_names));\n\n          delete row.column_indexes;\n          delete row.column_names;\n          let field;\n          let attribute; // Indkey is the order of attributes in the index, specified by a string of attribute indexes\n\n          row.fields = row.indkey.split(' ').map((indKey, index) => {\n            field = columns[indKey]; // for functional indices indKey = 0\n\n            if (!field) {\n              return null;\n            }\n\n            attribute = attributes[index];\n            return {\n              attribute: field,\n              collate: attribute.match(/COLLATE \"(.*?)\"/) ? /COLLATE \"(.*?)\"/.exec(attribute)[1] : undefined,\n              order: attribute.includes('DESC') ? 'DESC' : attribute.includes('ASC') ? 'ASC' : undefined,\n              length: undefined\n            };\n          }).filter(n => n !== null);\n          delete row.columns;\n        }\n\n        return rows;\n      }\n\n      if (this.isForeignKeysQuery()) {\n        const result = [];\n\n        for (const row of rows) {\n          let defParts;\n\n          if (row.condef !== undefined && (defParts = row.condef.match(/FOREIGN KEY \\((.+)\\) REFERENCES (.+)\\((.+)\\)( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?/))) {\n            row.id = row.constraint_name;\n            row.table = defParts[2];\n            row.from = defParts[1];\n            row.to = defParts[3];\n            let i;\n\n            for (i = 5; i <= 8; i += 3) {\n              if (/(UPDATE|DELETE)/.test(defParts[i])) {\n                row[\"on_\".concat(defParts[i].toLowerCase())] = defParts[i + 1];\n              }\n            }\n          }\n\n          result.push(row);\n        }\n\n        return result;\n      }\n\n      if (this.isSelectQuery()) {\n        let result = rows; // Postgres will treat tables as case-insensitive, so fix the case\n        // of the returned values to match attributes\n\n        if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {\n          const attrsMap = _.reduce(this.model.rawAttributes, (m, v, k) => {\n            m[k.toLowerCase()] = k;\n            return m;\n          }, {});\n\n          result = rows.map(row => {\n            return _.mapKeys(row, (value, key) => {\n              const targetAttr = attrsMap[key];\n\n              if (typeof targetAttr === 'string' && targetAttr !== key) {\n                return targetAttr;\n              }\n\n              return key;\n            });\n          });\n        }\n\n        return this.handleSelectQuery(result);\n      }\n\n      if (QueryTypes.DESCRIBE === this.options.type) {\n        const result = {};\n\n        for (const row of rows) {\n          result[row.Field] = {\n            type: row.Type.toUpperCase(),\n            allowNull: row.Null === 'YES',\n            defaultValue: row.Default,\n            comment: row.Comment,\n            special: row.special ? this.sequelize.getQueryInterface().QueryGenerator.fromArray(row.special) : [],\n            primaryKey: row.Constraint === 'PRIMARY KEY'\n          };\n\n          if (result[row.Field].type === 'BOOLEAN') {\n            result[row.Field].defaultValue = {\n              'false': false,\n              'true': true\n            }[result[row.Field].defaultValue];\n\n            if (result[row.Field].defaultValue === undefined) {\n              result[row.Field].defaultValue = null;\n            }\n          }\n\n          if (typeof result[row.Field].defaultValue === 'string') {\n            result[row.Field].defaultValue = result[row.Field].defaultValue.replace(/'/g, '');\n\n            if (result[row.Field].defaultValue.includes('::')) {\n              const split = result[row.Field].defaultValue.split('::');\n\n              if (split[1].toLowerCase() !== 'regclass)') {\n                result[row.Field].defaultValue = split[0];\n              }\n            }\n          }\n        }\n\n        return result;\n      }\n\n      if (this.isVersionQuery()) {\n        return rows[0].server_version;\n      }\n\n      if (this.isShowOrDescribeQuery()) {\n        return rows;\n      }\n\n      if (QueryTypes.BULKUPDATE === this.options.type) {\n        if (!this.options.returning) {\n          return parseInt(rowCount, 10);\n        }\n\n        return this.handleSelectQuery(rows);\n      }\n\n      if (QueryTypes.BULKDELETE === this.options.type) {\n        return parseInt(rowCount, 10);\n      }\n\n      if (this.isUpsertQuery()) {\n        return rows[0];\n      }\n\n      if (this.isInsertQuery() || this.isUpdateQuery()) {\n        if (this.instance && this.instance.dataValues) {\n          for (const key in rows[0]) {\n            if (Object.prototype.hasOwnProperty.call(rows[0], key)) {\n              const record = rows[0][key];\n\n              const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);\n\n              this.instance.dataValues[attr && attr.fieldName || key] = record;\n            }\n          }\n        }\n\n        return [this.instance || rows && (this.options.plain && rows[0] || rows) || undefined, rowCount];\n      }\n\n      if (this.isRawQuery()) {\n        return [rows, queryResult];\n      }\n\n      return rows;\n    });\n  }\n\n  formatError(err) {\n    let match;\n    let table;\n    let index;\n    let fields;\n    let errors;\n    let message;\n    const code = err.code || err.sqlState;\n    const errMessage = err.message || err.messagePrimary;\n    const errDetail = err.detail || err.messageDetail;\n\n    switch (code) {\n      case '23503':\n        index = errMessage.match(/violates foreign key constraint \"(.+?)\"/);\n        index = index ? index[1] : undefined;\n        table = errMessage.match(/on table \"(.+?)\"/);\n        table = table ? table[1] : undefined;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          message: errMessage,\n          fields: null,\n          index,\n          table,\n          parent: err\n        });\n\n      case '23505':\n        // there are multiple different formats of error messages for this error code\n        // this regex should check at least two\n        if (errDetail && (match = errDetail.replace(/\"/g, '').match(/Key \\((.*?)\\)=\\((.*?)\\)/))) {\n          fields = _.zipObject(match[1].split(', '), match[2].split(', '));\n          errors = [];\n          message = 'Validation error';\n\n          _.forOwn(fields, (value, field) => {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), 'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field, value, this.instance, 'not_unique'));\n          });\n\n          if (this.model && this.model.uniqueKeys) {\n            _.forOwn(this.model.uniqueKeys, constraint => {\n              if (_.isEqual(constraint.fields, Object.keys(fields)) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n\n          return new sequelizeErrors.UniqueConstraintError({\n            message,\n            errors,\n            parent: err,\n            fields\n          });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({\n          message: errMessage,\n          parent: err\n        });\n\n      case '23P01':\n        match = errDetail.match(/Key \\((.*?)\\)=\\((.*?)\\)/);\n\n        if (match) {\n          fields = _.zipObject(match[1].split(', '), match[2].split(', '));\n        }\n\n        message = 'Exclusion constraint error';\n        return new sequelizeErrors.ExclusionConstraintError({\n          message,\n          constraint: err.constraint,\n          fields,\n          table: err.table,\n          parent: err\n        });\n\n      case '42704':\n        if (err.sql && /(CONSTRAINT|INDEX)/gi.test(err.sql)) {\n          message = 'Unknown constraint error';\n          index = errMessage.match(/(?:constraint|index) \"(.+?)\"/i);\n          index = index ? index[1] : undefined;\n          table = errMessage.match(/relation \"(.+?)\"/i);\n          table = table ? table[1] : undefined;\n          throw new sequelizeErrors.UnknownConstraintError({\n            message,\n            constraint: index,\n            fields,\n            table,\n            parent: err\n          });\n        }\n\n      // falls through\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  isForeignKeysQuery() {\n    return /SELECT conname as constraint_name, pg_catalog\\.pg_get_constraintdef\\(r\\.oid, true\\) as condef FROM pg_catalog\\.pg_constraint r WHERE r\\.conrelid = \\(SELECT oid FROM pg_class WHERE relname = '.*' LIMIT 1\\) AND r\\.contype = 'f' ORDER BY 1;/.test(this.sql);\n  }\n\n  getInsertIdField() {\n    return 'id';\n  }\n\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":null,"metadata":{},"sourceType":"script"}