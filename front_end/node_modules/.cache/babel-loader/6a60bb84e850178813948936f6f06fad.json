{"ast":null,"code":"\"use strict\";\n\nconst Transform = require('readable-stream').Transform;\n\nconst TYPE = require('./token').TYPE;\n\nconst tokenParsers = {};\ntokenParsers[TYPE.COLMETADATA] = require('./colmetadata-token-parser');\ntokenParsers[TYPE.DONE] = require('./done-token-parser').doneParser;\ntokenParsers[TYPE.DONEINPROC] = require('./done-token-parser').doneInProcParser;\ntokenParsers[TYPE.DONEPROC] = require('./done-token-parser').doneProcParser;\ntokenParsers[TYPE.ENVCHANGE] = require('./env-change-token-parser');\ntokenParsers[TYPE.ERROR] = require('./infoerror-token-parser').errorParser;\ntokenParsers[TYPE.FEDAUTHINFO] = require('./fedauth-info-parser');\ntokenParsers[TYPE.FEATUREEXTACK] = require('./feature-ext-ack-parser');\ntokenParsers[TYPE.INFO] = require('./infoerror-token-parser').infoParser;\ntokenParsers[TYPE.LOGINACK] = require('./loginack-token-parser');\ntokenParsers[TYPE.ORDER] = require('./order-token-parser');\ntokenParsers[TYPE.RETURNSTATUS] = require('./returnstatus-token-parser');\ntokenParsers[TYPE.RETURNVALUE] = require('./returnvalue-token-parser');\ntokenParsers[TYPE.ROW] = require('./row-token-parser');\ntokenParsers[TYPE.NBCROW] = require('./nbcrow-token-parser');\ntokenParsers[TYPE.SSPI] = require('./sspi-token-parser');\nmodule.exports = class Parser extends Transform {\n  constructor(debug, colMetadata, options) {\n    super({\n      objectMode: true\n    });\n    this.debug = debug;\n    this.colMetadata = colMetadata;\n    this.options = options;\n    this.endOfMessageMarker = {};\n    this.buffer = Buffer.alloc(0);\n    this.position = 0;\n    this.suspended = false;\n    this.next = undefined;\n  }\n\n  _transform(input, encoding, done) {\n    if (input === this.endOfMessageMarker) {\n      done(null, {\n        // generate endOfMessage pseudo token\n        name: 'EOM',\n        event: 'endOfMessage'\n      });\n      return;\n    }\n\n    if (this.position === this.buffer.length) {\n      this.buffer = input;\n    } else {\n      this.buffer = Buffer.concat([this.buffer.slice(this.position), input]);\n    }\n\n    this.position = 0;\n\n    if (this.suspended) {\n      // Unsuspend and continue from where ever we left off.\n      this.suspended = false;\n      this.next.call(null);\n    } // If we're no longer suspended, parse new tokens\n\n\n    if (!this.suspended) {\n      // Start the parser\n      this.parseTokens();\n    }\n\n    done();\n  }\n\n  parseTokens() {\n    const doneParsing = token => {\n      if (token) {\n        switch (token.name) {\n          case 'COLMETADATA':\n            this.colMetadata = token.columns;\n        }\n\n        this.push(token);\n      }\n    };\n\n    while (!this.suspended && this.position + 1 <= this.buffer.length) {\n      const type = this.buffer.readUInt8(this.position);\n      this.position += 1;\n\n      if (tokenParsers[type]) {\n        tokenParsers[type](this, this.colMetadata, this.options, doneParsing);\n      } else {\n        this.emit('error', new Error('Unknown type: ' + type));\n      }\n    }\n  }\n\n  suspend(next) {\n    this.suspended = true;\n    this.next = next;\n  }\n\n  awaitData(length, callback) {\n    if (this.position + length <= this.buffer.length) {\n      callback();\n    } else {\n      this.suspend(() => {\n        this.awaitData(length, callback);\n      });\n    }\n  }\n\n  readInt8(callback) {\n    this.awaitData(1, () => {\n      const data = this.buffer.readInt8(this.position);\n      this.position += 1;\n      callback(data);\n    });\n  }\n\n  readUInt8(callback) {\n    this.awaitData(1, () => {\n      const data = this.buffer.readUInt8(this.position);\n      this.position += 1;\n      callback(data);\n    });\n  }\n\n  readInt16LE(callback) {\n    this.awaitData(2, () => {\n      const data = this.buffer.readInt16LE(this.position);\n      this.position += 2;\n      callback(data);\n    });\n  }\n\n  readInt16BE(callback) {\n    this.awaitData(2, () => {\n      const data = this.buffer.readInt16BE(this.position);\n      this.position += 2;\n      callback(data);\n    });\n  }\n\n  readUInt16LE(callback) {\n    this.awaitData(2, () => {\n      const data = this.buffer.readUInt16LE(this.position);\n      this.position += 2;\n      callback(data);\n    });\n  }\n\n  readUInt16BE(callback) {\n    this.awaitData(2, () => {\n      const data = this.buffer.readUInt16BE(this.position);\n      this.position += 2;\n      callback(data);\n    });\n  }\n\n  readInt32LE(callback) {\n    this.awaitData(4, () => {\n      const data = this.buffer.readInt32LE(this.position);\n      this.position += 4;\n      callback(data);\n    });\n  }\n\n  readInt32BE(callback) {\n    this.awaitData(4, () => {\n      const data = this.buffer.readInt32BE(this.position);\n      this.position += 4;\n      callback(data);\n    });\n  }\n\n  readUInt32LE(callback) {\n    this.awaitData(4, () => {\n      const data = this.buffer.readUInt32LE(this.position);\n      this.position += 4;\n      callback(data);\n    });\n  }\n\n  readUInt32BE(callback) {\n    this.awaitData(4, () => {\n      const data = this.buffer.readUInt32BE(this.position);\n      this.position += 4;\n      callback(data);\n    });\n  }\n\n  readInt64LE(callback) {\n    this.awaitData(8, () => {\n      const data = Math.pow(2, 32) * this.buffer.readInt32LE(this.position + 4) + (this.buffer[this.position + 4] & 0x80 === 0x80 ? 1 : -1) * this.buffer.readUInt32LE(this.position);\n      this.position += 8;\n      callback(data);\n    });\n  }\n\n  readInt64BE(callback) {\n    this.awaitData(8, () => {\n      const data = Math.pow(2, 32) * this.buffer.readInt32BE(this.position) + (this.buffer[this.position] & 0x80 === 0x80 ? 1 : -1) * this.buffer.readUInt32BE(this.position + 4);\n      this.position += 8;\n      callback(data);\n    });\n  }\n\n  readUInt64LE(callback) {\n    this.awaitData(8, () => {\n      const data = Math.pow(2, 32) * this.buffer.readUInt32LE(this.position + 4) + this.buffer.readUInt32LE(this.position);\n      this.position += 8;\n      callback(data);\n    });\n  }\n\n  readUInt64BE(callback) {\n    this.awaitData(8, () => {\n      const data = Math.pow(2, 32) * this.buffer.readUInt32BE(this.position) + this.buffer.readUInt32BE(this.position + 4);\n      this.position += 8;\n      callback(data);\n    });\n  }\n\n  readFloatLE(callback) {\n    this.awaitData(4, () => {\n      const data = this.buffer.readFloatLE(this.position);\n      this.position += 4;\n      callback(data);\n    });\n  }\n\n  readFloatBE(callback) {\n    this.awaitData(4, () => {\n      const data = this.buffer.readFloatBE(this.position);\n      this.position += 4;\n      callback(data);\n    });\n  }\n\n  readDoubleLE(callback) {\n    this.awaitData(8, () => {\n      const data = this.buffer.readDoubleLE(this.position);\n      this.position += 8;\n      callback(data);\n    });\n  }\n\n  readDoubleBE(callback) {\n    this.awaitData(8, () => {\n      const data = this.buffer.readDoubleBE(this.position);\n      this.position += 8;\n      callback(data);\n    });\n  }\n\n  readUInt24LE(callback) {\n    this.awaitData(3, () => {\n      const low = this.buffer.readUInt16LE(this.position);\n      const high = this.buffer.readUInt8(this.position + 2);\n      this.position += 3;\n      callback(low | high << 16);\n    });\n  }\n\n  readUInt40LE(callback) {\n    this.awaitData(5, () => {\n      const low = this.buffer.readUInt32LE(this.position);\n      const high = this.buffer.readUInt8(this.position + 4);\n      this.position += 5;\n      callback(0x100000000 * high + low);\n    });\n  }\n\n  readUNumeric64LE(callback) {\n    this.awaitData(8, () => {\n      const low = this.buffer.readUInt32LE(this.position);\n      const high = this.buffer.readUInt32LE(this.position + 4);\n      this.position += 8;\n      callback(0x100000000 * high + low);\n    });\n  }\n\n  readUNumeric96LE(callback) {\n    this.awaitData(12, () => {\n      const dword1 = this.buffer.readUInt32LE(this.position);\n      const dword2 = this.buffer.readUInt32LE(this.position + 4);\n      const dword3 = this.buffer.readUInt32LE(this.position + 8);\n      this.position += 12;\n      callback(dword1 + 0x100000000 * dword2 + 0x100000000 * 0x100000000 * dword3);\n    });\n  }\n\n  readUNumeric128LE(callback) {\n    this.awaitData(16, () => {\n      const dword1 = this.buffer.readUInt32LE(this.position);\n      const dword2 = this.buffer.readUInt32LE(this.position + 4);\n      const dword3 = this.buffer.readUInt32LE(this.position + 8);\n      const dword4 = this.buffer.readUInt32LE(this.position + 12);\n      this.position += 16;\n      callback(dword1 + 0x100000000 * dword2 + 0x100000000 * 0x100000000 * dword3 + 0x100000000 * 0x100000000 * 0x100000000 * dword4);\n    });\n  } // Variable length data\n\n\n  readBuffer(length, callback) {\n    this.awaitData(length, () => {\n      const data = this.buffer.slice(this.position, this.position + length);\n      this.position += length;\n      callback(data);\n    });\n  } // Read a Unicode String (BVARCHAR)\n\n\n  readBVarChar(callback) {\n    this.readUInt8(length => {\n      this.readBuffer(length * 2, data => {\n        callback(data.toString('ucs2'));\n      });\n    });\n  } // Read a Unicode String (USVARCHAR)\n\n\n  readUsVarChar(callback) {\n    this.readUInt16LE(length => {\n      this.readBuffer(length * 2, data => {\n        callback(data.toString('ucs2'));\n      });\n    });\n  } // Read binary data (BVARBYTE)\n\n\n  readBVarByte(callback) {\n    this.readUInt8(length => {\n      this.readBuffer(length, callback);\n    });\n  } // Read binary data (USVARBYTE)\n\n\n  readUsVarByte(callback) {\n    this.readUInt16LE(length => {\n      this.readBuffer(length, callback);\n    });\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}