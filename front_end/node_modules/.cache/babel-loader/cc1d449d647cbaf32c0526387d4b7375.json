{"ast":null,"code":"\"use strict\";\n/* globals $PropertyType */\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst Transform = require('readable-stream').Transform;\n\nconst WritableTrackingBuffer = require('./tracking-buffer/writable-tracking-buffer');\n\nconst TOKEN_TYPE = require('./token/token').TYPE;\n\nconst Message = require('./message');\n\nconst PACKET_TYPE = require('./packet').TYPE;\n\nconst FLAGS = {\n  nullable: 1 << 0,\n  caseSen: 1 << 1,\n  updateableReadWrite: 1 << 2,\n  updateableUnknown: 1 << 3,\n  identity: 1 << 4,\n  computed: 1 << 5,\n  // introduced in TDS 7.2\n  fixedLenCLRType: 1 << 8,\n  // introduced in TDS 7.2\n  sparseColumnSet: 1 << 10,\n  // introduced in TDS 7.3.B\n  hidden: 1 << 13,\n  // introduced in TDS 7.2\n  key: 1 << 14,\n  // introduced in TDS 7.2\n  nullableUnknown: 1 << 15 // introduced in TDS 7.2\n\n};\nconst DONE_STATUS = {\n  FINAL: 0x00,\n  MORE: 0x1,\n  ERROR: 0x2,\n  INXACT: 0x4,\n  COUNT: 0x10,\n  ATTN: 0x20,\n  SRVERROR: 0x100\n};\n\nclass BulkLoad extends EventEmitter {\n  constructor(table, connectionOptions, {\n    checkConstraints = false,\n    fireTriggers = false,\n    keepNulls = false,\n    lockTable = false\n  }, callback) {\n    if (typeof checkConstraints !== 'boolean') {\n      throw new TypeError('The \"options.checkConstraints\" property must be of type boolean.');\n    }\n\n    if (typeof fireTriggers !== 'boolean') {\n      throw new TypeError('The \"options.fireTriggers\" property must be of type boolean.');\n    }\n\n    if (typeof keepNulls !== 'boolean') {\n      throw new TypeError('The \"options.keepNulls\" property must be of type boolean.');\n    }\n\n    if (typeof lockTable !== 'boolean') {\n      throw new TypeError('The \"options.lockTable\" property must be of type boolean.');\n    }\n\n    super();\n    this.error = undefined;\n    this.canceled = false;\n    this.executionStarted = false;\n    this.table = table;\n    this.options = connectionOptions;\n    this.callback = callback;\n    this.columns = [];\n    this.columnsByName = {};\n    this.firstRowWritten = false;\n    this.streamingMode = false;\n    this.rowToPacketTransform = new RowTransform(this);\n    this.bulkOptions = {\n      checkConstraints,\n      fireTriggers,\n      keepNulls,\n      lockTable\n    };\n  }\n\n  addColumn(name, type, {\n    output = false,\n    length,\n    precision,\n    scale,\n    objName = name,\n    nullable = true\n  }) {\n    if (this.firstRowWritten) {\n      throw new Error('Columns cannot be added to bulk insert after the first row has been written.');\n    }\n\n    if (this.executionStarted) {\n      throw new Error('Columns cannot be added to bulk insert after execution has started.');\n    }\n\n    const column = {\n      type: type,\n      name: name,\n      value: null,\n      output: output,\n      length: length,\n      precision: precision,\n      scale: scale,\n      objName: objName,\n      nullable: nullable\n    };\n\n    if ((type.id & 0x30) === 0x20) {\n      if (column.length == undefined && type.resolveLength) {\n        column.length = type.resolveLength(column);\n      }\n    }\n\n    if (type.hasPrecision) {\n      if (column.precision == undefined && type.resolvePrecision) {\n        column.precision = type.resolvePrecision(column);\n      }\n    }\n\n    if (type.hasScale) {\n      if (column.scale == undefined && type.resolveScale) {\n        column.scale = type.resolveScale(column);\n      }\n    }\n\n    this.columns.push(column);\n    this.columnsByName[name] = column;\n  }\n\n  addRow(...input) {\n    this.firstRowWritten = true;\n    let row;\n\n    if (input.length > 1 || !input[0] || typeof input[0] !== 'object') {\n      row = input;\n    } else {\n      row = input[0];\n    } // write each column\n\n\n    if (Array.isArray(row)) {\n      this.rowToPacketTransform.write(row);\n    } else {\n      const object = row;\n      this.rowToPacketTransform.write(this.columns.map(column => {\n        return object[column.objName];\n      }));\n    }\n  }\n\n  getOptionsSql() {\n    const addOptions = [];\n\n    if (this.bulkOptions.checkConstraints) {\n      addOptions.push('CHECK_CONSTRAINTS');\n    }\n\n    if (this.bulkOptions.fireTriggers) {\n      addOptions.push('FIRE_TRIGGERS');\n    }\n\n    if (this.bulkOptions.keepNulls) {\n      addOptions.push('KEEP_NULLS');\n    }\n\n    if (this.bulkOptions.lockTable) {\n      addOptions.push('TABLOCK');\n    }\n\n    if (addOptions.length > 0) {\n      return \" WITH (\".concat(addOptions.join(','), \")\");\n    } else {\n      return '';\n    }\n  }\n\n  getBulkInsertSql() {\n    let sql = 'insert bulk ' + this.table + '(';\n\n    for (let i = 0, len = this.columns.length; i < len; i++) {\n      const c = this.columns[i];\n\n      if (i !== 0) {\n        sql += ', ';\n      }\n\n      sql += '[' + c.name + '] ' + c.type.declaration(c);\n    }\n\n    sql += ')';\n    sql += this.getOptionsSql();\n    return sql;\n  }\n\n  getTableCreationSql() {\n    let sql = 'CREATE TABLE ' + this.table + '(\\n';\n\n    for (let i = 0, len = this.columns.length; i < len; i++) {\n      const c = this.columns[i];\n\n      if (i !== 0) {\n        sql += ',\\n';\n      }\n\n      sql += '[' + c.name + '] ' + c.type.declaration(c);\n\n      if (c.nullable !== undefined) {\n        sql += ' ' + (c.nullable ? 'NULL' : 'NOT NULL');\n      }\n    }\n\n    sql += '\\n)';\n    return sql;\n  }\n\n  getColMetaData() {\n    const tBuf = new WritableTrackingBuffer(100, null, true); // TokenType\n\n    tBuf.writeUInt8(TOKEN_TYPE.COLMETADATA); // Count\n\n    tBuf.writeUInt16LE(this.columns.length);\n\n    for (let j = 0, len = this.columns.length; j < len; j++) {\n      const c = this.columns[j]; // UserType\n\n      if (this.options.tdsVersion < '7_2') {\n        tBuf.writeUInt16LE(0);\n      } else {\n        tBuf.writeUInt32LE(0);\n      } // Flags\n\n\n      let flags = FLAGS.updateableReadWrite;\n\n      if (c.nullable) {\n        flags |= FLAGS.nullable;\n      } else if (c.nullable === undefined && this.options.tdsVersion >= '7_2') {\n        flags |= FLAGS.nullableUnknown;\n      }\n\n      tBuf.writeUInt16LE(flags); // TYPE_INFO\n\n      c.type.writeTypeInfo(tBuf, c, this.options); // ColName\n\n      tBuf.writeBVarchar(c.name, 'ucs2');\n    }\n\n    return tBuf.data;\n  }\n\n  setTimeout(timeout) {\n    this.timeout = timeout;\n  }\n\n  createDoneToken() {\n    // It might be nice to make DoneToken a class if anything needs to create them, but for now, just do it here\n    const tBuf = new WritableTrackingBuffer(this.options.tdsVersion < '7_2' ? 9 : 13);\n    tBuf.writeUInt8(TOKEN_TYPE.DONE);\n    const status = DONE_STATUS.FINAL;\n    tBuf.writeUInt16LE(status);\n    tBuf.writeUInt16LE(0); // CurCmd (TDS ignores this)\n\n    tBuf.writeUInt32LE(0); // row count - doesn't really matter\n\n    if (this.options.tdsVersion >= '7_2') {\n      tBuf.writeUInt32LE(0); // row count is 64 bits in >= TDS 7.2\n    }\n\n    return tBuf.data;\n  } // This method switches the BulkLoad object into streaming mode and returns\n  // a stream.Writable for streaming rows to the server.\n\n\n  getRowStream() {\n    if (this.firstRowWritten) {\n      throw new Error('BulkLoad cannot be switched to streaming mode after first row has been written using addRow().');\n    }\n\n    if (this.executionStarted) {\n      throw new Error('BulkLoad cannot be switched to streaming mode after execution has started.');\n    }\n\n    this.streamingMode = true;\n    return this.rowToPacketTransform;\n  }\n\n  getMessageStream() {\n    const message = new Message({\n      type: PACKET_TYPE.BULK_LOAD\n    });\n    this.rowToPacketTransform.pipe(message);\n    return message;\n  }\n\n}\n\nmodule.exports = BulkLoad; // A transform that converts rows to packets.\n\nclass RowTransform extends Transform {\n  constructor(bulkLoad) {\n    super({\n      writableObjectMode: true\n    });\n    this.bulkLoad = bulkLoad;\n    this.mainOptions = bulkLoad.options;\n    this.columns = bulkLoad.columns;\n    this.columnMetadataWritten = false;\n  }\n\n  _transform(row, encoding, callback) {\n    if (!this.columnMetadataWritten) {\n      this.push(this.bulkLoad.getColMetaData());\n      this.columnMetadataWritten = true;\n    }\n\n    const buf = new WritableTrackingBuffer(64, 'ucs2', true);\n    buf.writeUInt8(TOKEN_TYPE.ROW);\n\n    for (let i = 0; i < this.columns.length; i++) {\n      const c = this.columns[i];\n      c.type.writeParameterData(buf, {\n        length: c.length,\n        scale: c.scale,\n        precision: c.precision,\n        value: row[i]\n      }, this.mainOptions);\n    }\n\n    this.push(buf.data);\n    callback();\n  }\n\n  _flush(callback) {\n    this.push(this.bulkLoad.createDoneToken());\n    callback();\n  }\n\n}","map":null,"metadata":{},"sourceType":"script"}