{"ast":null,"code":"\"use strict\";\n\nconst iconv = require('iconv-lite');\n\nconst sprintf = require('sprintf-js').sprintf;\n\nconst TYPE = require('./data-type').TYPE;\n\nconst guidParser = require('./guid-parser');\n\nconst readPrecision = require('./metadata-parser').readPrecision;\n\nconst readScale = require('./metadata-parser').readScale;\n\nconst readCollation = require('./metadata-parser').readCollation;\n\nconst convertLEBytesToString = require('./tracking-buffer/bigint').convertLEBytesToString;\n\nconst NULL = (1 << 16) - 1;\nconst MAX = (1 << 16) - 1;\nconst THREE_AND_A_THIRD = 3 + 1 / 3;\nconst MONEY_DIVISOR = 10000;\nconst PLP_NULL = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);\nconst UNKNOWN_PLP_LEN = Buffer.from([0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);\nconst DEFAULT_ENCODING = 'utf8';\n\nfunction readTextPointerNull(parser, type, callback) {\n  if (type.hasTextPointerAndTimestamp) {\n    parser.readUInt8(textPointerLength => {\n      if (textPointerLength !== 0) {\n        // Appear to be dummy values, so consume and discard them.\n        parser.readBuffer(textPointerLength, () => {\n          parser.readBuffer(8, () => {\n            callback(undefined);\n          });\n        });\n      } else {\n        callback(true);\n      }\n    });\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readDataLength(parser, type, metaData, textPointerNull, callback) {\n  if (textPointerNull) {\n    return callback(0);\n  }\n\n  if (metaData.isVariantValue) {\n    return callback(metaData.dataLength);\n  } // s2.2.4.2.1\n\n\n  switch (type.id & 0x30) {\n    case 0x10:\n      // xx01xxxx - s2.2.4.2.1.1\n      return callback(0);\n\n    case 0x20:\n      // xx10xxxx - s2.2.4.2.1.3\n      // Variable length\n      if (metaData.dataLength !== MAX) {\n        switch (type.dataLengthLength) {\n          case 0:\n            return callback(undefined);\n\n          case 1:\n            return parser.readUInt8(callback);\n\n          case 2:\n            return parser.readUInt16LE(callback);\n\n          case 4:\n            return parser.readUInt32LE(callback);\n\n          default:\n            return parser.emit('error', new Error('Unsupported dataLengthLength ' + type.dataLengthLength + ' for data type ' + type.name));\n        }\n      } else {\n        return callback(undefined);\n      }\n\n    case 0x30:\n      return callback(1 << ((type.id & 0x0C) >> 2));\n  }\n}\n\nmodule.exports = valueParse;\n\nfunction valueParse(parser, metaData, options, callback) {\n  const type = metaData.type;\n  readTextPointerNull(parser, type, textPointerNull => {\n    readDataLength(parser, type, metaData, textPointerNull, dataLength => {\n      switch (type.name) {\n        case 'Null':\n          return callback(null);\n\n        case 'TinyInt':\n          return parser.readUInt8(callback);\n\n        case 'Int':\n          return parser.readInt32LE(callback);\n\n        case 'SmallInt':\n          return parser.readInt16LE(callback);\n\n        case 'BigInt':\n          return parser.readBuffer(8, buffer => {\n            callback(convertLEBytesToString(buffer));\n          });\n\n        case 'IntN':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n\n            case 1:\n              return parser.readUInt8(callback);\n\n            case 2:\n              return parser.readInt16LE(callback);\n\n            case 4:\n              return parser.readInt32LE(callback);\n\n            case 8:\n              return parser.readBuffer(8, buffer => {\n                callback(convertLEBytesToString(buffer));\n              });\n\n            default:\n              return parser.emit('error', new Error('Unsupported dataLength ' + dataLength + ' for IntN'));\n          }\n\n        case 'Real':\n          return parser.readFloatLE(callback);\n\n        case 'Float':\n          return parser.readDoubleLE(callback);\n\n        case 'FloatN':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n\n            case 4:\n              return parser.readFloatLE(callback);\n\n            case 8:\n              return parser.readDoubleLE(callback);\n\n            default:\n              return parser.emit('error', new Error('Unsupported dataLength ' + dataLength + ' for FloatN'));\n          }\n\n        case 'Money':\n        case 'SmallMoney':\n        case 'MoneyN':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n\n            case 4:\n              return parser.readInt32LE(value => {\n                callback(value / MONEY_DIVISOR);\n              });\n\n            case 8:\n              return parser.readInt32LE(high => {\n                parser.readUInt32LE(low => {\n                  callback((low + 0x100000000 * high) / MONEY_DIVISOR);\n                });\n              });\n\n            default:\n              return parser.emit('error', new Error('Unsupported dataLength ' + dataLength + ' for MoneyN'));\n          }\n\n        case 'Bit':\n          return parser.readUInt8(value => {\n            callback(!!value);\n          });\n\n        case 'BitN':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n\n            case 1:\n              return parser.readUInt8(value => {\n                callback(!!value);\n              });\n          }\n\n        case 'VarChar':\n        case 'Char':\n          const codepage = metaData.collation.codepage;\n\n          if (metaData.dataLength === MAX) {\n            return readMaxChars(parser, codepage, callback);\n          } else {\n            return readChars(parser, dataLength, codepage, NULL, callback);\n          }\n\n        case 'NVarChar':\n        case 'NChar':\n          if (metaData.dataLength === MAX) {\n            return readMaxNChars(parser, callback);\n          } else {\n            return readNChars(parser, dataLength, NULL, callback);\n          }\n\n        case 'VarBinary':\n        case 'Binary':\n          if (metaData.dataLength === MAX) {\n            return readMaxBinary(parser, callback);\n          } else {\n            return readBinary(parser, dataLength, NULL, callback);\n          }\n\n        case 'Text':\n          if (textPointerNull) {\n            return callback(null);\n          } else {\n            return readChars(parser, dataLength, metaData.collation.codepage, PLP_NULL, callback);\n          }\n\n        case 'NText':\n          if (textPointerNull) {\n            return callback(null);\n          } else {\n            return readNChars(parser, dataLength, PLP_NULL, callback);\n          }\n\n        case 'Image':\n          if (textPointerNull) {\n            return callback(null);\n          } else {\n            return readBinary(parser, dataLength, PLP_NULL, callback);\n          }\n\n        case 'Xml':\n          return readMaxNChars(parser, callback);\n\n        case 'SmallDateTime':\n          return readSmallDateTime(parser, options.useUTC, callback);\n\n        case 'DateTime':\n          return readDateTime(parser, options.useUTC, callback);\n\n        case 'DateTimeN':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n\n            case 4:\n              return readSmallDateTime(parser, options.useUTC, callback);\n\n            case 8:\n              return readDateTime(parser, options.useUTC, callback);\n          }\n\n        case 'Time':\n          if (dataLength === 0) {\n            return callback(null);\n          } else {\n            return readTime(parser, dataLength, metaData.scale, options.useUTC, callback);\n          }\n\n        case 'Date':\n          if (dataLength === 0) {\n            return callback(null);\n          } else {\n            return readDate(parser, options.useUTC, callback);\n          }\n\n        case 'DateTime2':\n          if (dataLength === 0) {\n            return callback(null);\n          } else {\n            return readDateTime2(parser, dataLength, metaData.scale, options.useUTC, callback);\n          }\n\n        case 'DateTimeOffset':\n          if (dataLength === 0) {\n            return callback(null);\n          } else {\n            return readDateTimeOffset(parser, dataLength, metaData.scale, callback);\n          }\n\n        case 'NumericN':\n        case 'DecimalN':\n          if (dataLength === 0) {\n            return callback(null);\n          } else {\n            return parser.readUInt8(sign => {\n              sign = sign === 1 ? 1 : -1;\n              let readValue;\n\n              switch (dataLength - 1) {\n                case 4:\n                  readValue = parser.readUInt32LE;\n                  break;\n\n                case 8:\n                  readValue = parser.readUNumeric64LE;\n                  break;\n\n                case 12:\n                  readValue = parser.readUNumeric96LE;\n                  break;\n\n                case 16:\n                  readValue = parser.readUNumeric128LE;\n                  break;\n\n                default:\n                  return parser.emit('error', new Error(sprintf('Unsupported numeric size %d', dataLength - 1)));\n              }\n\n              readValue.call(parser, value => {\n                callback(value * sign / Math.pow(10, metaData.scale));\n              });\n            });\n          }\n\n        case 'UniqueIdentifier':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n\n            case 0x10:\n              return parser.readBuffer(0x10, data => {\n                callback(guidParser.arrayToGuid(data));\n              });\n\n            default:\n              return parser.emit('error', new Error(sprintf('Unsupported guid size %d', dataLength - 1)));\n          }\n\n        case 'UDT':\n          return readMaxBinary(parser, callback);\n\n        case 'Variant':\n          if (dataLength === 0) {\n            return callback(null);\n          }\n\n          const valueMetaData = metaData.valueMetaData = {};\n          Object.defineProperty(valueMetaData, 'isVariantValue', {\n            value: true\n          });\n          return parser.readUInt8(baseType => {\n            return parser.readUInt8(propBytes => {\n              valueMetaData.dataLength = dataLength - propBytes - 2;\n              valueMetaData.type = TYPE[baseType];\n              return readPrecision(parser, valueMetaData.type, precision => {\n                valueMetaData.precision = precision;\n                return readScale(parser, valueMetaData.type, scale => {\n                  valueMetaData.scale = scale;\n                  return readCollation(parser, valueMetaData.type, collation => {\n                    valueMetaData.collation = collation;\n\n                    if (baseType === 0xA5 || baseType === 0xAD || baseType === 0xA7 || baseType === 0xAF || baseType === 0xE7 || baseType === 0xEF) {\n                      return readDataLength(parser, valueMetaData.type, {}, null, maxDataLength => {\n                        // skip the 2-byte max length sent for BIGVARCHRTYPE, BIGCHARTYPE, NVARCHARTYPE, NCHARTYPE, BIGVARBINTYPE and BIGBINARYTYPE types\n                        // and parse based on the length of actual data\n                        return valueParse(parser, valueMetaData, options, callback);\n                      });\n                    } else {\n                      return valueParse(parser, valueMetaData, options, callback);\n                    }\n                  });\n                });\n              });\n            });\n          });\n\n        default:\n          return parser.emit('error', new Error(sprintf('Unrecognised type %s', type.name)));\n      }\n    });\n  });\n}\n\nfunction readBinary(parser, dataLength, nullValue, callback) {\n  if (dataLength === nullValue) {\n    return callback(null);\n  } else {\n    return parser.readBuffer(dataLength, callback);\n  }\n}\n\nfunction readChars(parser, dataLength, codepage, nullValue, callback) {\n  if (codepage == null) {\n    codepage = DEFAULT_ENCODING;\n  }\n\n  if (dataLength === nullValue) {\n    return callback(null);\n  } else {\n    return parser.readBuffer(dataLength, data => {\n      callback(iconv.decode(data, codepage));\n    });\n  }\n}\n\nfunction readNChars(parser, dataLength, nullValue, callback) {\n  if (dataLength === nullValue) {\n    return callback(null);\n  } else {\n    return parser.readBuffer(dataLength, data => {\n      callback(data.toString('ucs2'));\n    });\n  }\n}\n\nfunction readMaxBinary(parser, callback) {\n  return readMax(parser, callback);\n}\n\nfunction readMaxChars(parser, codepage, callback) {\n  if (codepage == null) {\n    codepage = DEFAULT_ENCODING;\n  }\n\n  readMax(parser, data => {\n    if (data) {\n      callback(iconv.decode(data, codepage));\n    } else {\n      callback(null);\n    }\n  });\n}\n\nfunction readMaxNChars(parser, callback) {\n  readMax(parser, data => {\n    if (data) {\n      callback(data.toString('ucs2'));\n    } else {\n      callback(null);\n    }\n  });\n}\n\nfunction readMax(parser, callback) {\n  parser.readBuffer(8, type => {\n    if (type.equals(PLP_NULL)) {\n      return callback(null);\n    } else if (type.equals(UNKNOWN_PLP_LEN)) {\n      return readMaxUnknownLength(parser, callback);\n    } else {\n      const low = type.readUInt32LE(0);\n      const high = type.readUInt32LE(4);\n\n      if (high >= 2 << 53 - 32) {\n        console.warn('Read UInt64LE > 53 bits : high=' + high + ', low=' + low);\n      }\n\n      const expectedLength = low + 0x100000000 * high;\n      return readMaxKnownLength(parser, expectedLength, callback);\n    }\n  });\n}\n\nfunction readMaxKnownLength(parser, totalLength, callback) {\n  const data = Buffer.alloc(totalLength, 0);\n  let offset = 0;\n\n  function next(done) {\n    parser.readUInt32LE(chunkLength => {\n      if (!chunkLength) {\n        return done();\n      }\n\n      parser.readBuffer(chunkLength, chunk => {\n        chunk.copy(data, offset);\n        offset += chunkLength;\n        next(done);\n      });\n    });\n  }\n\n  next(() => {\n    if (offset !== totalLength) {\n      parser.emit('error', new Error('Partially Length-prefixed Bytes unmatched lengths : expected ' + totalLength + ', but got ' + offset + ' bytes'));\n    }\n\n    callback(data);\n  });\n}\n\nfunction readMaxUnknownLength(parser, callback) {\n  const chunks = [];\n  let length = 0;\n\n  function next(done) {\n    parser.readUInt32LE(chunkLength => {\n      if (!chunkLength) {\n        return done();\n      }\n\n      parser.readBuffer(chunkLength, chunk => {\n        chunks.push(chunk);\n        length += chunkLength;\n        next(done);\n      });\n    });\n  }\n\n  next(() => {\n    callback(Buffer.concat(chunks, length));\n  });\n}\n\nfunction readSmallDateTime(parser, useUTC, callback) {\n  parser.readUInt16LE(days => {\n    parser.readUInt16LE(minutes => {\n      let value;\n\n      if (useUTC) {\n        value = new Date(Date.UTC(1900, 0, 1 + days, 0, minutes));\n      } else {\n        value = new Date(1900, 0, 1 + days, 0, minutes);\n      }\n\n      callback(value);\n    });\n  });\n}\n\nfunction readDateTime(parser, useUTC, callback) {\n  parser.readInt32LE(days => {\n    parser.readUInt32LE(threeHundredthsOfSecond => {\n      const milliseconds = Math.round(threeHundredthsOfSecond * THREE_AND_A_THIRD);\n      let value;\n\n      if (useUTC) {\n        value = new Date(Date.UTC(1900, 0, 1 + days, 0, 0, 0, milliseconds));\n      } else {\n        value = new Date(1900, 0, 1 + days, 0, 0, 0, milliseconds);\n      }\n\n      callback(value);\n    });\n  });\n}\n\nfunction readTime(parser, dataLength, scale, useUTC, callback) {\n  let readValue;\n\n  switch (dataLength) {\n    case 3:\n      readValue = parser.readUInt24LE;\n      break;\n\n    case 4:\n      readValue = parser.readUInt32LE;\n      break;\n\n    case 5:\n      readValue = parser.readUInt40LE;\n  }\n\n  readValue.call(parser, value => {\n    if (scale < 7) {\n      for (let i = scale; i < 7; i++) {\n        value *= 10;\n      }\n    }\n\n    let date;\n\n    if (useUTC) {\n      date = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, value / 10000));\n    } else {\n      date = new Date(1970, 0, 1, 0, 0, 0, value / 10000);\n    }\n\n    Object.defineProperty(date, 'nanosecondsDelta', {\n      enumerable: false,\n      value: value % 10000 / Math.pow(10, 7)\n    });\n    callback(date);\n  });\n}\n\nfunction readDate(parser, useUTC, callback) {\n  parser.readUInt24LE(days => {\n    if (useUTC) {\n      callback(new Date(Date.UTC(2000, 0, days - 730118)));\n    } else {\n      callback(new Date(2000, 0, days - 730118));\n    }\n  });\n}\n\nfunction readDateTime2(parser, dataLength, scale, useUTC, callback) {\n  readTime(parser, dataLength - 3, scale, useUTC, time => {\n    parser.readUInt24LE(days => {\n      let date;\n\n      if (useUTC) {\n        date = new Date(Date.UTC(2000, 0, days - 730118, 0, 0, 0, +time));\n      } else {\n        date = new Date(2000, 0, days - 730118, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());\n      }\n\n      Object.defineProperty(date, 'nanosecondsDelta', {\n        enumerable: false,\n        value: time.nanosecondsDelta\n      });\n      callback(date);\n    });\n  });\n}\n\nfunction readDateTimeOffset(parser, dataLength, scale, callback) {\n  readTime(parser, dataLength - 5, scale, true, time => {\n    parser.readUInt24LE(days => {\n      // offset\n      parser.readInt16LE(() => {\n        const date = new Date(Date.UTC(2000, 0, days - 730118, 0, 0, 0, +time));\n        Object.defineProperty(date, 'nanosecondsDelta', {\n          enumerable: false,\n          value: time.nanosecondsDelta\n        });\n        callback(date);\n      });\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"script"}