{"ast":null,"code":"module.exports = Polygon;\n\nvar util = require('util');\n\nvar Geometry = require('./geometry');\n\nvar Types = require('./types');\n\nvar Point = require('./point');\n\nvar BinaryWriter = require('./binarywriter');\n\nfunction Polygon(exteriorRing, interiorRings, srid) {\n  Geometry.call(this);\n  this.exteriorRing = exteriorRing || [];\n  this.interiorRings = interiorRings || [];\n  this.srid = srid;\n\n  if (this.exteriorRing.length > 0) {\n    this.hasZ = this.exteriorRing[0].hasZ;\n    this.hasM = this.exteriorRing[0].hasM;\n  }\n}\n\nutil.inherits(Polygon, Geometry);\n\nPolygon.Z = function (exteriorRing, interiorRings, srid) {\n  var polygon = new Polygon(exteriorRing, interiorRings, srid);\n  polygon.hasZ = true;\n  return polygon;\n};\n\nPolygon.M = function (exteriorRing, interiorRings, srid) {\n  var polygon = new Polygon(exteriorRing, interiorRings, srid);\n  polygon.hasM = true;\n  return polygon;\n};\n\nPolygon.ZM = function (exteriorRing, interiorRings, srid) {\n  var polygon = new Polygon(exteriorRing, interiorRings, srid);\n  polygon.hasZ = true;\n  polygon.hasM = true;\n  return polygon;\n};\n\nPolygon._parseWkt = function (value, options) {\n  var polygon = new Polygon();\n  polygon.srid = options.srid;\n  polygon.hasZ = options.hasZ;\n  polygon.hasM = options.hasM;\n  if (value.isMatch(['EMPTY'])) return polygon;\n  value.expectGroupStart();\n  value.expectGroupStart();\n  polygon.exteriorRing.push.apply(polygon.exteriorRing, value.matchCoordinates(options));\n  value.expectGroupEnd();\n\n  while (value.isMatch([','])) {\n    value.expectGroupStart();\n    polygon.interiorRings.push(value.matchCoordinates(options));\n    value.expectGroupEnd();\n  }\n\n  value.expectGroupEnd();\n  return polygon;\n};\n\nPolygon._parseWkb = function (value, options) {\n  var polygon = new Polygon();\n  polygon.srid = options.srid;\n  polygon.hasZ = options.hasZ;\n  polygon.hasM = options.hasM;\n  var ringCount = value.readUInt32();\n\n  if (ringCount > 0) {\n    var exteriorRingCount = value.readUInt32();\n\n    for (var i = 0; i < exteriorRingCount; i++) polygon.exteriorRing.push(Point._readWkbPoint(value, options));\n\n    for (i = 1; i < ringCount; i++) {\n      var interiorRing = [];\n      var interiorRingCount = value.readUInt32();\n\n      for (var j = 0; j < interiorRingCount; j++) interiorRing.push(Point._readWkbPoint(value, options));\n\n      polygon.interiorRings.push(interiorRing);\n    }\n  }\n\n  return polygon;\n};\n\nPolygon._parseTwkb = function (value, options) {\n  var polygon = new Polygon();\n  polygon.hasZ = options.hasZ;\n  polygon.hasM = options.hasM;\n  if (options.isEmpty) return polygon;\n  var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);\n  var ringCount = value.readVarInt();\n  var exteriorRingCount = value.readVarInt();\n\n  for (var i = 0; i < exteriorRingCount; i++) polygon.exteriorRing.push(Point._readTwkbPoint(value, options, previousPoint));\n\n  for (i = 1; i < ringCount; i++) {\n    var interiorRing = [];\n    var interiorRingCount = value.readVarInt();\n\n    for (var j = 0; j < interiorRingCount; j++) interiorRing.push(Point._readTwkbPoint(value, options, previousPoint));\n\n    polygon.interiorRings.push(interiorRing);\n  }\n\n  return polygon;\n};\n\nPolygon._parseGeoJSON = function (value) {\n  var polygon = new Polygon();\n  if (value.coordinates.length > 0 && value.coordinates[0].length > 0) polygon.hasZ = value.coordinates[0][0].length > 2;\n\n  for (var i = 0; i < value.coordinates.length; i++) {\n    if (i > 0) polygon.interiorRings.push([]);\n\n    for (var j = 0; j < value.coordinates[i].length; j++) {\n      if (i === 0) polygon.exteriorRing.push(Point._readGeoJSONPoint(value.coordinates[i][j]));else polygon.interiorRings[i - 1].push(Point._readGeoJSONPoint(value.coordinates[i][j]));\n    }\n  }\n\n  return polygon;\n};\n\nPolygon.prototype.toWkt = function () {\n  if (this.exteriorRing.length === 0) return this._getWktType(Types.wkt.Polygon, true);\n  return this._getWktType(Types.wkt.Polygon, false) + this._toInnerWkt();\n};\n\nPolygon.prototype._toInnerWkt = function () {\n  var innerWkt = '((';\n\n  for (var i = 0; i < this.exteriorRing.length; i++) innerWkt += this._getWktCoordinate(this.exteriorRing[i]) + ',';\n\n  innerWkt = innerWkt.slice(0, -1);\n  innerWkt += ')';\n\n  for (i = 0; i < this.interiorRings.length; i++) {\n    innerWkt += ',(';\n\n    for (var j = 0; j < this.interiorRings[i].length; j++) {\n      innerWkt += this._getWktCoordinate(this.interiorRings[i][j]) + ',';\n    }\n\n    innerWkt = innerWkt.slice(0, -1);\n    innerWkt += ')';\n  }\n\n  innerWkt += ')';\n  return innerWkt;\n};\n\nPolygon.prototype.toWkb = function (parentOptions) {\n  var wkb = new BinaryWriter(this._getWkbSize());\n  wkb.writeInt8(1);\n\n  this._writeWkbType(wkb, Types.wkb.Polygon, parentOptions);\n\n  if (this.exteriorRing.length > 0) {\n    wkb.writeUInt32LE(1 + this.interiorRings.length);\n    wkb.writeUInt32LE(this.exteriorRing.length);\n  } else {\n    wkb.writeUInt32LE(0);\n  }\n\n  for (var i = 0; i < this.exteriorRing.length; i++) this.exteriorRing[i]._writeWkbPoint(wkb);\n\n  for (i = 0; i < this.interiorRings.length; i++) {\n    wkb.writeUInt32LE(this.interiorRings[i].length);\n\n    for (var j = 0; j < this.interiorRings[i].length; j++) this.interiorRings[i][j]._writeWkbPoint(wkb);\n  }\n\n  return wkb.buffer;\n};\n\nPolygon.prototype.toTwkb = function () {\n  var twkb = new BinaryWriter(0, true);\n  var precision = Geometry.getTwkbPrecision(5, 0, 0);\n  var isEmpty = this.exteriorRing.length === 0;\n\n  this._writeTwkbHeader(twkb, Types.wkb.Polygon, precision, isEmpty);\n\n  if (this.exteriorRing.length > 0) {\n    twkb.writeVarInt(1 + this.interiorRings.length);\n    twkb.writeVarInt(this.exteriorRing.length);\n    var previousPoint = new Point(0, 0, 0, 0);\n\n    for (var i = 0; i < this.exteriorRing.length; i++) this.exteriorRing[i]._writeTwkbPoint(twkb, precision, previousPoint);\n\n    for (i = 0; i < this.interiorRings.length; i++) {\n      twkb.writeVarInt(this.interiorRings[i].length);\n\n      for (var j = 0; j < this.interiorRings[i].length; j++) this.interiorRings[i][j]._writeTwkbPoint(twkb, precision, previousPoint);\n    }\n  }\n\n  return twkb.buffer;\n};\n\nPolygon.prototype._getWkbSize = function () {\n  var coordinateSize = 16;\n  if (this.hasZ) coordinateSize += 8;\n  if (this.hasM) coordinateSize += 8;\n  var size = 1 + 4 + 4;\n  if (this.exteriorRing.length > 0) size += 4 + this.exteriorRing.length * coordinateSize;\n\n  for (var i = 0; i < this.interiorRings.length; i++) size += 4 + this.interiorRings[i].length * coordinateSize;\n\n  return size;\n};\n\nPolygon.prototype.toGeoJSON = function (options) {\n  var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);\n  geoJSON.type = Types.geoJSON.Polygon;\n  geoJSON.coordinates = [];\n\n  if (this.exteriorRing.length > 0) {\n    var exteriorRing = [];\n\n    for (var i = 0; i < this.exteriorRing.length; i++) {\n      if (this.hasZ) exteriorRing.push([this.exteriorRing[i].x, this.exteriorRing[i].y, this.exteriorRing[i].z]);else exteriorRing.push([this.exteriorRing[i].x, this.exteriorRing[i].y]);\n    }\n\n    geoJSON.coordinates.push(exteriorRing);\n  }\n\n  for (var j = 0; j < this.interiorRings.length; j++) {\n    var interiorRing = [];\n\n    for (var k = 0; k < this.interiorRings[j].length; k++) {\n      if (this.hasZ) interiorRing.push([this.interiorRings[j][k].x, this.interiorRings[j][k].y, this.interiorRings[j][k].z]);else interiorRing.push([this.interiorRings[j][k].x, this.interiorRings[j][k].y]);\n    }\n\n    geoJSON.coordinates.push(interiorRing);\n  }\n\n  return geoJSON;\n};","map":null,"metadata":{},"sourceType":"script"}