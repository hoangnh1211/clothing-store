{"ast":null,"code":"module.exports = Point;\n\nvar util = require('util');\n\nvar Geometry = require('./geometry');\n\nvar Types = require('./types');\n\nvar BinaryWriter = require('./binarywriter');\n\nvar ZigZag = require('./zigzag.js');\n\nfunction Point(x, y, z, m, srid) {\n  Geometry.call(this);\n  this.x = x;\n  this.y = y;\n  this.z = z;\n  this.m = m;\n  this.srid = srid;\n  this.hasZ = typeof this.z !== 'undefined';\n  this.hasM = typeof this.m !== 'undefined';\n}\n\nutil.inherits(Point, Geometry);\n\nPoint.Z = function (x, y, z, srid) {\n  var point = new Point(x, y, z, undefined, srid);\n  point.hasZ = true;\n  return point;\n};\n\nPoint.M = function (x, y, m, srid) {\n  var point = new Point(x, y, undefined, m, srid);\n  point.hasM = true;\n  return point;\n};\n\nPoint.ZM = function (x, y, z, m, srid) {\n  var point = new Point(x, y, z, m, srid);\n  point.hasZ = true;\n  point.hasM = true;\n  return point;\n};\n\nPoint._parseWkt = function (value, options) {\n  var point = new Point();\n  point.srid = options.srid;\n  point.hasZ = options.hasZ;\n  point.hasM = options.hasM;\n  if (value.isMatch(['EMPTY'])) return point;\n  value.expectGroupStart();\n  var coordinate = value.matchCoordinate(options);\n  point.x = coordinate.x;\n  point.y = coordinate.y;\n  point.z = coordinate.z;\n  point.m = coordinate.m;\n  value.expectGroupEnd();\n  return point;\n};\n\nPoint._parseWkb = function (value, options) {\n  var point = Point._readWkbPoint(value, options);\n\n  point.srid = options.srid;\n  return point;\n};\n\nPoint._readWkbPoint = function (value, options) {\n  return new Point(value.readDouble(), value.readDouble(), options.hasZ ? value.readDouble() : undefined, options.hasM ? value.readDouble() : undefined);\n};\n\nPoint._parseTwkb = function (value, options) {\n  var point = new Point();\n  point.hasZ = options.hasZ;\n  point.hasM = options.hasM;\n  if (options.isEmpty) return point;\n  point.x = ZigZag.decode(value.readVarInt()) / options.precisionFactor;\n  point.y = ZigZag.decode(value.readVarInt()) / options.precisionFactor;\n  point.z = options.hasZ ? ZigZag.decode(value.readVarInt()) / options.zPrecisionFactor : undefined;\n  point.m = options.hasM ? ZigZag.decode(value.readVarInt()) / options.mPrecisionFactor : undefined;\n  return point;\n};\n\nPoint._readTwkbPoint = function (value, options, previousPoint) {\n  previousPoint.x += ZigZag.decode(value.readVarInt()) / options.precisionFactor;\n  previousPoint.y += ZigZag.decode(value.readVarInt()) / options.precisionFactor;\n  if (options.hasZ) previousPoint.z += ZigZag.decode(value.readVarInt()) / options.zPrecisionFactor;\n  if (options.hasM) previousPoint.m += ZigZag.decode(value.readVarInt()) / options.mPrecisionFactor;\n  return new Point(previousPoint.x, previousPoint.y, previousPoint.z, previousPoint.m);\n};\n\nPoint._parseGeoJSON = function (value) {\n  return Point._readGeoJSONPoint(value.coordinates);\n};\n\nPoint._readGeoJSONPoint = function (coordinates) {\n  if (coordinates.length === 0) return new Point();\n  if (coordinates.length > 2) return new Point(coordinates[0], coordinates[1], coordinates[2]);\n  return new Point(coordinates[0], coordinates[1]);\n};\n\nPoint.prototype.toWkt = function () {\n  if (typeof this.x === 'undefined' && typeof this.y === 'undefined' && typeof this.z === 'undefined' && typeof this.m === 'undefined') return this._getWktType(Types.wkt.Point, true);\n  return this._getWktType(Types.wkt.Point, false) + '(' + this._getWktCoordinate(this) + ')';\n};\n\nPoint.prototype.toWkb = function (parentOptions) {\n  var wkb = new BinaryWriter(this._getWkbSize());\n  wkb.writeInt8(1);\n\n  this._writeWkbType(wkb, Types.wkb.Point, parentOptions);\n\n  if (typeof this.x === 'undefined' && typeof this.y === 'undefined') {\n    wkb.writeDoubleLE(NaN);\n    wkb.writeDoubleLE(NaN);\n    if (this.hasZ) wkb.writeDoubleLE(NaN);\n    if (this.hasM) wkb.writeDoubleLE(NaN);\n  } else {\n    this._writeWkbPoint(wkb);\n  }\n\n  return wkb.buffer;\n};\n\nPoint.prototype._writeWkbPoint = function (wkb) {\n  wkb.writeDoubleLE(this.x);\n  wkb.writeDoubleLE(this.y);\n  if (this.hasZ) wkb.writeDoubleLE(this.z);\n  if (this.hasM) wkb.writeDoubleLE(this.m);\n};\n\nPoint.prototype.toTwkb = function () {\n  var twkb = new BinaryWriter(0, true);\n  var precision = Geometry.getTwkbPrecision(5, 0, 0);\n  var isEmpty = typeof this.x === 'undefined' && typeof this.y === 'undefined';\n\n  this._writeTwkbHeader(twkb, Types.wkb.Point, precision, isEmpty);\n\n  if (!isEmpty) this._writeTwkbPoint(twkb, precision, new Point(0, 0, 0, 0));\n  return twkb.buffer;\n};\n\nPoint.prototype._writeTwkbPoint = function (twkb, precision, previousPoint) {\n  var x = this.x * precision.xyFactor;\n  var y = this.y * precision.xyFactor;\n  var z = this.z * precision.zFactor;\n  var m = this.m * precision.mFactor;\n  twkb.writeVarInt(ZigZag.encode(x - previousPoint.x));\n  twkb.writeVarInt(ZigZag.encode(y - previousPoint.y));\n  if (this.hasZ) twkb.writeVarInt(ZigZag.encode(z - previousPoint.z));\n  if (this.hasM) twkb.writeVarInt(ZigZag.encode(m - previousPoint.m));\n  previousPoint.x = x;\n  previousPoint.y = y;\n  previousPoint.z = z;\n  previousPoint.m = m;\n};\n\nPoint.prototype._getWkbSize = function () {\n  var size = 1 + 4 + 8 + 8;\n  if (this.hasZ) size += 8;\n  if (this.hasM) size += 8;\n  return size;\n};\n\nPoint.prototype.toGeoJSON = function (options) {\n  var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);\n  geoJSON.type = Types.geoJSON.Point;\n  if (typeof this.x === 'undefined' && typeof this.y === 'undefined') geoJSON.coordinates = [];else if (typeof this.z !== 'undefined') geoJSON.coordinates = [this.x, this.y, this.z];else geoJSON.coordinates = [this.x, this.y];\n  return geoJSON;\n};","map":null,"metadata":{},"sourceType":"script"}