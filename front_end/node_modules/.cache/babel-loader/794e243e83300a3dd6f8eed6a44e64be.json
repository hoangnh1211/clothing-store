{"ast":null,"code":"\"use strict\";\n/**\n * Creates an interator for a DoublyLinkedList starting at the given node\n * It's internal cursor will remains relative to the last \"iterated\" node as that\n * node moves through the list until it either iterates to the end of the list,\n * or the the node it's tracking is removed from the list. Until the first 'next'\n * call it tracks the head/tail of the linked list. This means that one can create\n * an iterator on an empty list, then add nodes, and then the iterator will follow\n * those nodes. Because the DoublyLinkedList nodes don't track their owning \"list\" and\n * it's highly inefficient to walk the list for every iteration, the iterator won't know\n * if the node has been detached from one List and added to another list, or if the iterator\n *\n * The created object is an es6 compatible iterator\n */\n\nclass DoublyLinkedListIterator {\n  /**\n   * @param  {Object} doublyLinkedList     a node that is part of a doublyLinkedList\n   * @param  {Boolean} [reverse=false]     is this a reverse iterator? default: false\n   */\n  constructor(doublyLinkedList, reverse) {\n    this._list = doublyLinkedList; // NOTE: these key names are tied to the DoublyLinkedListIterator\n\n    this._direction = reverse === true ? \"prev\" : \"next\";\n    this._startPosition = reverse === true ? \"tail\" : \"head\";\n    this._started = false;\n    this._cursor = null;\n    this._done = false;\n  }\n\n  _start() {\n    this._cursor = this._list[this._startPosition];\n    this._started = true;\n  }\n\n  _advanceCursor() {\n    if (this._started === false) {\n      this._started = true;\n      this._cursor = this._list[this._startPosition];\n      return;\n    }\n\n    this._cursor = this._cursor[this._direction];\n  }\n\n  reset() {\n    this._done = false;\n    this._started = false;\n    this._cursor = null;\n  }\n\n  remove() {\n    if (this._started === false || this._done === true || this._isCursorDetached()) {\n      return false;\n    }\n\n    this._list.remove(this._cursor);\n  }\n\n  next() {\n    if (this._done === true) {\n      return {\n        done: true\n      };\n    }\n\n    this._advanceCursor(); // if there is no node at the cursor or the node at the cursor is no longer part of\n    // a doubly linked list then we are done/finished/kaput\n\n\n    if (this._cursor === null || this._isCursorDetached()) {\n      this._done = true;\n      return {\n        done: true\n      };\n    }\n\n    return {\n      value: this._cursor,\n      done: false\n    };\n  }\n  /**\n   * Is the node detached from a list?\n   * NOTE: you can trick/bypass/confuse this check by removing a node from one DoublyLinkedList\n   * and adding it to another.\n   * TODO: We can make this smarter by checking the direction of travel and only checking\n   * the required next/prev/head/tail rather than all of them\n   * @return {Boolean}      [description]\n   */\n\n\n  _isCursorDetached() {\n    return this._cursor.prev === null && this._cursor.next === null && this._list.tail !== this._cursor && this._list.head !== this._cursor;\n  }\n\n}\n\nmodule.exports = DoublyLinkedListIterator;","map":null,"metadata":{},"sourceType":"script"}