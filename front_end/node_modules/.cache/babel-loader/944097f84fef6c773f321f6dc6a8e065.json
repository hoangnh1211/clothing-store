{"ast":null,"code":"module.exports = MultiPolygon;\n\nvar util = require('util');\n\nvar Types = require('./types');\n\nvar Geometry = require('./geometry');\n\nvar Point = require('./point');\n\nvar Polygon = require('./polygon');\n\nvar BinaryWriter = require('./binarywriter');\n\nfunction MultiPolygon(polygons, srid) {\n  Geometry.call(this);\n  this.polygons = polygons || [];\n  this.srid = srid;\n\n  if (this.polygons.length > 0) {\n    this.hasZ = this.polygons[0].hasZ;\n    this.hasM = this.polygons[0].hasM;\n  }\n}\n\nutil.inherits(MultiPolygon, Geometry);\n\nMultiPolygon.Z = function (polygons, srid) {\n  var multiPolygon = new MultiPolygon(polygons, srid);\n  multiPolygon.hasZ = true;\n  return multiPolygon;\n};\n\nMultiPolygon.M = function (polygons, srid) {\n  var multiPolygon = new MultiPolygon(polygons, srid);\n  multiPolygon.hasM = true;\n  return multiPolygon;\n};\n\nMultiPolygon.ZM = function (polygons, srid) {\n  var multiPolygon = new MultiPolygon(polygons, srid);\n  multiPolygon.hasZ = true;\n  multiPolygon.hasM = true;\n  return multiPolygon;\n};\n\nMultiPolygon._parseWkt = function (value, options) {\n  var multiPolygon = new MultiPolygon();\n  multiPolygon.srid = options.srid;\n  multiPolygon.hasZ = options.hasZ;\n  multiPolygon.hasM = options.hasM;\n  if (value.isMatch(['EMPTY'])) return multiPolygon;\n  value.expectGroupStart();\n\n  do {\n    value.expectGroupStart();\n    var exteriorRing = [];\n    var interiorRings = [];\n    value.expectGroupStart();\n    exteriorRing.push.apply(exteriorRing, value.matchCoordinates(options));\n    value.expectGroupEnd();\n\n    while (value.isMatch([','])) {\n      value.expectGroupStart();\n      interiorRings.push(value.matchCoordinates(options));\n      value.expectGroupEnd();\n    }\n\n    multiPolygon.polygons.push(new Polygon(exteriorRing, interiorRings));\n    value.expectGroupEnd();\n  } while (value.isMatch([',']));\n\n  value.expectGroupEnd();\n  return multiPolygon;\n};\n\nMultiPolygon._parseWkb = function (value, options) {\n  var multiPolygon = new MultiPolygon();\n  multiPolygon.srid = options.srid;\n  multiPolygon.hasZ = options.hasZ;\n  multiPolygon.hasM = options.hasM;\n  var polygonCount = value.readUInt32();\n\n  for (var i = 0; i < polygonCount; i++) multiPolygon.polygons.push(Geometry.parse(value, options));\n\n  return multiPolygon;\n};\n\nMultiPolygon._parseTwkb = function (value, options) {\n  var multiPolygon = new MultiPolygon();\n  multiPolygon.hasZ = options.hasZ;\n  multiPolygon.hasM = options.hasM;\n  if (options.isEmpty) return multiPolygon;\n  var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);\n  var polygonCount = value.readVarInt();\n\n  for (var i = 0; i < polygonCount; i++) {\n    var polygon = new Polygon();\n    polygon.hasZ = options.hasZ;\n    polygon.hasM = options.hasM;\n    var ringCount = value.readVarInt();\n    var exteriorRingCount = value.readVarInt();\n\n    for (var j = 0; j < exteriorRingCount; j++) polygon.exteriorRing.push(Point._readTwkbPoint(value, options, previousPoint));\n\n    for (j = 1; j < ringCount; j++) {\n      var interiorRing = [];\n      var interiorRingCount = value.readVarInt();\n\n      for (var k = 0; k < interiorRingCount; k++) interiorRing.push(Point._readTwkbPoint(value, options, previousPoint));\n\n      polygon.interiorRings.push(interiorRing);\n    }\n\n    multiPolygon.polygons.push(polygon);\n  }\n\n  return multiPolygon;\n};\n\nMultiPolygon._parseGeoJSON = function (value) {\n  var multiPolygon = new MultiPolygon();\n  if (value.coordinates.length > 0 && value.coordinates[0].length > 0 && value.coordinates[0][0].length > 0) multiPolygon.hasZ = value.coordinates[0][0][0].length > 2;\n\n  for (var i = 0; i < value.coordinates.length; i++) multiPolygon.polygons.push(Polygon._parseGeoJSON({\n    coordinates: value.coordinates[i]\n  }));\n\n  return multiPolygon;\n};\n\nMultiPolygon.prototype.toWkt = function () {\n  if (this.polygons.length === 0) return this._getWktType(Types.wkt.MultiPolygon, true);\n  var wkt = this._getWktType(Types.wkt.MultiPolygon, false) + '(';\n\n  for (var i = 0; i < this.polygons.length; i++) wkt += this.polygons[i]._toInnerWkt() + ',';\n\n  wkt = wkt.slice(0, -1);\n  wkt += ')';\n  return wkt;\n};\n\nMultiPolygon.prototype.toWkb = function () {\n  var wkb = new BinaryWriter(this._getWkbSize());\n  wkb.writeInt8(1);\n\n  this._writeWkbType(wkb, Types.wkb.MultiPolygon);\n\n  wkb.writeUInt32LE(this.polygons.length);\n\n  for (var i = 0; i < this.polygons.length; i++) wkb.writeBuffer(this.polygons[i].toWkb({\n    srid: this.srid\n  }));\n\n  return wkb.buffer;\n};\n\nMultiPolygon.prototype.toTwkb = function () {\n  var twkb = new BinaryWriter(0, true);\n  var precision = Geometry.getTwkbPrecision(5, 0, 0);\n  var isEmpty = this.polygons.length === 0;\n\n  this._writeTwkbHeader(twkb, Types.wkb.MultiPolygon, precision, isEmpty);\n\n  if (this.polygons.length > 0) {\n    twkb.writeVarInt(this.polygons.length);\n    var previousPoint = new Point(0, 0, 0, 0);\n\n    for (var i = 0; i < this.polygons.length; i++) {\n      twkb.writeVarInt(1 + this.polygons[i].interiorRings.length);\n      twkb.writeVarInt(this.polygons[i].exteriorRing.length);\n\n      for (var j = 0; j < this.polygons[i].exteriorRing.length; j++) this.polygons[i].exteriorRing[j]._writeTwkbPoint(twkb, precision, previousPoint);\n\n      for (j = 0; j < this.polygons[i].interiorRings.length; j++) {\n        twkb.writeVarInt(this.polygons[i].interiorRings[j].length);\n\n        for (var k = 0; k < this.polygons[i].interiorRings[j].length; k++) this.polygons[i].interiorRings[j][k]._writeTwkbPoint(twkb, precision, previousPoint);\n      }\n    }\n  }\n\n  return twkb.buffer;\n};\n\nMultiPolygon.prototype._getWkbSize = function () {\n  var size = 1 + 4 + 4;\n\n  for (var i = 0; i < this.polygons.length; i++) size += this.polygons[i]._getWkbSize();\n\n  return size;\n};\n\nMultiPolygon.prototype.toGeoJSON = function (options) {\n  var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);\n  geoJSON.type = Types.geoJSON.MultiPolygon;\n  geoJSON.coordinates = [];\n\n  for (var i = 0; i < this.polygons.length; i++) geoJSON.coordinates.push(this.polygons[i].toGeoJSON().coordinates);\n\n  return geoJSON;\n};","map":null,"metadata":{},"sourceType":"script"}