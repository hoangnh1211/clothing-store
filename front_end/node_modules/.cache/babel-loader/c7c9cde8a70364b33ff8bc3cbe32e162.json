{"ast":null,"code":"'use strict';\n\nconst Promise = require('../../promise');\n\nconst AbstractQuery = require('../abstract/query');\n\nconst sequelizeErrors = require('../../errors');\n\nconst parserStore = require('../parserStore')('mssql');\n\nconst _ = require('lodash');\n\nconst _require = require('../../utils/logger'),\n      logger = _require.logger;\n\nconst debug = logger.debugContext('sql:mssql');\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'id';\n  }\n\n  getSQLTypeFromJsType(value, TYPES) {\n    const paramType = {\n      type: TYPES.VarChar,\n      typeOptions: {}\n    };\n    paramType.type = TYPES.NVarChar;\n\n    if (typeof value === 'number') {\n      if (Number.isInteger(value)) {\n        if (value >= -2147483648 && value <= 2147483647) {\n          paramType.type = TYPES.Int;\n        } else {\n          paramType.type = TYPES.BigInt;\n        }\n      } else {\n        paramType.type = TYPES.Numeric; //Default to a reasonable numeric precision/scale pending more sophisticated logic\n\n        paramType.typeOptions = {\n          precision: 30,\n          scale: 15\n        };\n      }\n    }\n\n    if (Buffer.isBuffer(value)) {\n      paramType.type = TYPES.VarBinary;\n    }\n\n    return paramType;\n  }\n\n  _run(connection, sql, parameters) {\n    this.sql = sql;\n    const options = this.options;\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => {\n      const handleTransaction = err => {\n        if (err) {\n          reject(this.formatError(err));\n          return;\n        }\n\n        resolve(this.formatResults());\n      }; // TRANSACTION SUPPORT\n\n\n      if (sql.startsWith('BEGIN TRANSACTION')) {\n        return connection.beginTransaction(handleTransaction, options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);\n      }\n\n      if (sql.startsWith('COMMIT TRANSACTION')) {\n        return connection.commitTransaction(handleTransaction);\n      }\n\n      if (sql.startsWith('ROLLBACK TRANSACTION')) {\n        return connection.rollbackTransaction(handleTransaction, options.transaction.name);\n      }\n\n      if (sql.startsWith('SAVE TRANSACTION')) {\n        return connection.saveTransaction(handleTransaction, options.transaction.name);\n      }\n\n      const results = [];\n      const request = new connection.lib.Request(sql, (err, rowCount) => {\n        complete();\n\n        if (err) {\n          err.sql = sql;\n          err.parameters = parameters;\n          reject(this.formatError(err));\n        } else {\n          resolve(this.formatResults(results, rowCount));\n        }\n      });\n\n      if (parameters) {\n        _.forOwn(parameters, (value, key) => {\n          const paramType = this.getSQLTypeFromJsType(value, connection.lib.TYPES);\n          request.addParameter(key, paramType.type, value, paramType.typeOptions);\n        });\n      }\n\n      request.on('row', columns => {\n        const row = {};\n\n        for (const column of columns) {\n          const typeid = column.metadata.type.id;\n          const parse = parserStore.get(typeid);\n          let value = column.value;\n\n          if (value !== null & !!parse) {\n            value = parse(value);\n          }\n\n          row[column.metadata.colName] = value;\n        }\n\n        results.push(row);\n      });\n      connection.execSql(request);\n    });\n  }\n\n  run(sql, parameters) {\n    return Promise.using(this.connection.lock(), connection => this._run(connection, sql, parameters));\n  }\n\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = {};\n\n    const replacementFunc = (match, key, values) => {\n      if (values[key] !== undefined) {\n        bindParam[key] = values[key];\n        return \"@\".concat(key);\n      }\n\n      return undefined;\n    };\n\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam];\n  }\n  /**\n   * High level function that handles the results of a query execution.\n   *\n   * @param {Array} data - The result of the query execution.\n   * @param {number} rowCount\n   * @private\n   * @example\n   * Example:\n   *  query.formatResults([\n   *    {\n   *      id: 1,              // this is from the main table\n   *      attr2: 'snafu',     // this is from the main table\n   *      Tasks.id: 1,        // this is from the associated table\n   *      Tasks.title: 'task' // this is from the associated table\n   *    }\n   *  ])\n   */\n\n\n  formatResults(data, rowCount) {\n    let result = this.instance;\n\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n\n      if (!this.instance) {\n        if (this.options.plain) {\n          // NOTE: super contrived. This just passes the newly added query-interface\n          //       test returning only the PK. There isn't a way in MSSQL to identify\n          //       that a given return value is the PK, and we have no schema information\n          //       because there was no calling Model.\n          const record = data[0];\n          result = record[Object.keys(record)[0]];\n        } else {\n          result = data;\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n\n    if (this.isDescribeQuery()) {\n      result = {};\n\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", '').replace(\"')\", '').replace(/'/g, '');\n        }\n\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === 'YES' ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.Constraint === 'PRIMARY KEY',\n          autoIncrement: _result.IsIdentity === 1,\n          comment: _result.Comment\n        };\n\n        if (result[_result.Name].type.includes('CHAR') && _result.Length) {\n          if (_result.Length === -1) {\n            result[_result.Name].type += '(MAX)';\n          } else {\n            result[_result.Name].type += \"(\".concat(_result.Length, \")\");\n          }\n        }\n      }\n    }\n\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n\n    if (this.isUpsertQuery()) {\n      return data[0];\n    }\n\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n\n    if (this.isBulkUpdateQuery()) {\n      return data.length;\n    }\n\n    if (this.isBulkDeleteQuery()) {\n      return data[0] && data[0].AFFECTEDROWS;\n    }\n\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, rowCount];\n    }\n\n    if (this.isShowConstraintsQuery()) {\n      return this.handleShowConstraintsQuery(data);\n    }\n\n    if (this.isRawQuery()) {\n      // MSSQL returns row data and metadata (affected rows etc) in a single object - let's standarize it, sorta\n      return [data, data];\n    }\n\n    return result;\n  }\n\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n\n  handleShowConstraintsQuery(data) {\n    //Convert snake_case keys to camelCase as it's generated by stored procedure\n    return data.slice(1).map(result => {\n      const constraint = {};\n\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key];\n      }\n\n      return constraint;\n    });\n  }\n\n  formatError(err) {\n    let match;\n    match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '((.|\\s)*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \\((.*)\\).)?/);\n    match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);\n\n    if (match && match.length > 1) {\n      let fields = {};\n      const uniqueKey = this.model && this.model.uniqueKeys[match[1]];\n      let message = 'Validation error';\n\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n\n      if (match[4]) {\n        const values = match[4].split(',').map(part => part.trim());\n\n        if (uniqueKey) {\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[match[1]] = match[4];\n        }\n      }\n\n      const errors = [];\n\n      _.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), 'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n        field, value, this.instance, 'not_unique'));\n      });\n\n      return new sequelizeErrors.UniqueConstraintError({\n        message,\n        errors,\n        parent: err,\n        fields\n      });\n    }\n\n    match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) || err.message.match(/The DELETE statement conflicted with the REFERENCE constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./) || err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./);\n\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n\n    match = err.message.match(/Could not drop constraint. See previous errors./);\n\n    if (match && match.length > 0) {\n      let constraint = err.sql.match(/(?:constraint|index) \\[(.+?)\\]/i);\n      constraint = constraint ? constraint[1] : undefined;\n      let table = err.sql.match(/table \\[(.+?)\\]/i);\n      table = table ? table[1] : undefined;\n      return new sequelizeErrors.UnknownConstraintError({\n        message: match[1],\n        constraint,\n        table,\n        parent: err\n      });\n    }\n\n    return new sequelizeErrors.DatabaseError(err);\n  }\n\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n    result = result || this.sql.toLowerCase().startsWith('select tablename = t.name, name = ind.name,');\n    result = result || this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');\n    return result;\n  }\n\n  isShowIndexesQuery() {\n    return this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');\n  }\n\n  handleShowIndexesQuery(data) {\n    // Group by index name, and collect all fields\n    data = data.reduce((acc, item) => {\n      if (!(item.index_name in acc)) {\n        acc[item.index_name] = item;\n        item.fields = [];\n      }\n\n      item.index_keys.split(',').forEach(column => {\n        let columnName = column.trim();\n\n        if (columnName.includes('(-)')) {\n          columnName = columnName.replace('(-)', '');\n        }\n\n        acc[item.index_name].fields.push({\n          attribute: columnName,\n          length: undefined,\n          order: column.includes('(-)') ? 'DESC' : 'ASC',\n          collate: undefined\n        });\n      });\n      delete item.index_keys;\n      return acc;\n    }, {});\n    return _.map(data, item => ({\n      primary: item.index_name.toLowerCase().startsWith('pk'),\n      fields: item.fields,\n      name: item.index_name,\n      tableName: undefined,\n      unique: item.index_description.toLowerCase().includes('unique'),\n      type: undefined\n    }));\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      // add the inserted row id to the instance\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== undefined) autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":null,"metadata":{},"sourceType":"script"}