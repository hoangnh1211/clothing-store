{"ast":null,"code":"\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst factoryValidator = require(\"./factoryValidator\");\n\nconst PoolOptions = require(\"./PoolOptions\");\n\nconst ResourceRequest = require(\"./ResourceRequest\");\n\nconst ResourceLoan = require(\"./ResourceLoan\");\n\nconst PooledResource = require(\"./PooledResource\");\n\nconst DefaultEvictor = require(\"./DefaultEvictor\");\n\nconst Deque = require(\"./Deque\");\n\nconst Deferred = require(\"./Deferred\");\n\nconst PriorityQueue = require(\"./PriorityQueue\");\n\nconst DequeIterator = require(\"./DequeIterator\");\n\nconst reflector = require(\"./utils\").reflector;\n/**\n * TODO: move me\n */\n\n\nconst FACTORY_CREATE_ERROR = \"factoryCreateError\";\nconst FACTORY_DESTROY_ERROR = \"factoryDestroyError\";\n\nclass Pool extends EventEmitter {\n  /**\n   * Generate an Object pool with a specified `factory` and `config`.\n   *\n   * @param {typeof DefaultEvictor} Evictor\n   * @param {typeof Deque} Deque\n   * @param {typeof PriorityQueue} PriorityQueue\n   * @param {Object} factory\n   *   Factory to be used for generating and destroying the items.\n   * @param {Function} factory.create\n   *   Should create the item to be acquired,\n   *   and call it's first callback argument with the generated item as it's argument.\n   * @param {Function} factory.destroy\n   *   Should gently close any resources that the item is using.\n   *   Called before the items is destroyed.\n   * @param {Function} factory.validate\n   *   Test if a resource is still valid .Should return a promise that resolves to a boolean, true if resource is still valid and false\n   *   If it should be removed from pool.\n   * @param {Object} options\n   */\n  constructor(Evictor, Deque, PriorityQueue, factory, options) {\n    super();\n    factoryValidator(factory);\n    this._config = new PoolOptions(options); // TODO: fix up this ugly glue-ing\n\n    this._Promise = this._config.Promise;\n    this._factory = factory;\n    this._draining = false;\n    this._started = false;\n    /**\n     * Holds waiting clients\n     * @type {PriorityQueue}\n     */\n\n    this._waitingClientsQueue = new PriorityQueue(this._config.priorityRange);\n    /**\n     * Collection of promises for resource creation calls made by the pool to factory.create\n     * @type {Set}\n     */\n\n    this._factoryCreateOperations = new Set();\n    /**\n     * Collection of promises for resource destruction calls made by the pool to factory.destroy\n     * @type {Set}\n     */\n\n    this._factoryDestroyOperations = new Set();\n    /**\n     * A queue/stack of pooledResources awaiting acquisition\n     * TODO: replace with LinkedList backed array\n     * @type {Deque}\n     */\n\n    this._availableObjects = new Deque();\n    /**\n     * Collection of references for any resource that are undergoing validation before being acquired\n     * @type {Set}\n     */\n\n    this._testOnBorrowResources = new Set();\n    /**\n     * Collection of references for any resource that are undergoing validation before being returned\n     * @type {Set}\n     */\n\n    this._testOnReturnResources = new Set();\n    /**\n     * Collection of promises for any validations currently in process\n     * @type {Set}\n     */\n\n    this._validationOperations = new Set();\n    /**\n     * All objects associated with this pool in any state (except destroyed)\n     * @type {Set}\n     */\n\n    this._allObjects = new Set();\n    /**\n     * Loans keyed by the borrowed resource\n     * @type {Map}\n     */\n\n    this._resourceLoans = new Map();\n    /**\n     * Infinitely looping iterator over available object\n     * @type {DequeIterator}\n     */\n\n    this._evictionIterator = this._availableObjects.iterator();\n    this._evictor = new Evictor();\n    /**\n     * handle for setTimeout for next eviction run\n     * @type {(number|null)}\n     */\n\n    this._scheduledEviction = null; // create initial resources (if factory.min > 0)\n\n    if (this._config.autostart === true) {\n      this.start();\n    }\n  }\n\n  _destroy(pooledResource) {\n    // FIXME: do we need another state for \"in destruction\"?\n    pooledResource.invalidate();\n\n    this._allObjects.delete(pooledResource); // NOTE: this maybe very bad promise usage?\n\n\n    const destroyPromise = this._factory.destroy(pooledResource.obj);\n\n    const wrappedDestroyPromise = this._Promise.resolve(destroyPromise);\n\n    this._trackOperation(wrappedDestroyPromise, this._factoryDestroyOperations).catch(reason => {\n      this.emit(FACTORY_DESTROY_ERROR, reason);\n    }); // TODO: maybe ensuring minimum pool size should live outside here\n\n\n    this._ensureMinimum();\n  }\n  /**\n   * Attempt to move an available resource into test and then onto a waiting client\n   * @return {Boolean} could we move an available resource into test\n   */\n\n\n  _testOnBorrow() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift(); // Mark the resource as in test\n\n\n    pooledResource.test();\n\n    this._testOnBorrowResources.add(pooledResource);\n\n    const validationPromise = this._factory.validate(pooledResource.obj);\n\n    const wrappedValidationPromise = this._Promise.resolve(validationPromise);\n\n    this._trackOperation(wrappedValidationPromise, this._validationOperations).then(isValid => {\n      this._testOnBorrowResources.delete(pooledResource);\n\n      if (isValid === false) {\n        pooledResource.invalidate();\n\n        this._destroy(pooledResource);\n\n        this._dispense();\n\n        return;\n      }\n\n      this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    });\n\n    return true;\n  }\n  /**\n   * Attempt to move an available resource to a waiting client\n   * @return {Boolean} [description]\n   */\n\n\n  _dispatchResource() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n\n    this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n\n    return false;\n  }\n  /**\n   * Attempt to resolve an outstanding resource request using an available resource from\n   * the pool, or creating new ones\n   *\n   * @private\n   */\n\n\n  _dispense() {\n    /**\n     * Local variables for ease of reading/writing\n     * these don't (shouldn't) change across the execution of this fn\n     */\n    const numWaitingClients = this._waitingClientsQueue.length; // If there aren't any waiting requests then there is nothing to do\n    // so lets short-circuit\n\n    if (numWaitingClients < 1) {\n      return;\n    }\n\n    const resourceShortfall = numWaitingClients - this._potentiallyAllocableResourceCount;\n    const actualNumberOfResourcesToCreate = Math.min(this.spareResourceCapacity, resourceShortfall);\n\n    for (let i = 0; actualNumberOfResourcesToCreate > i; i++) {\n      this._createResource();\n    } // If we are doing test-on-borrow see how many more resources need to be moved into test\n    // to help satisfy waitingClients\n\n\n    if (this._config.testOnBorrow === true) {\n      // how many available resources do we need to shift into test\n      const desiredNumberOfResourcesToMoveIntoTest = numWaitingClients - this._testOnBorrowResources.size;\n      const actualNumberOfResourcesToMoveIntoTest = Math.min(this._availableObjects.length, desiredNumberOfResourcesToMoveIntoTest);\n\n      for (let i = 0; actualNumberOfResourcesToMoveIntoTest > i; i++) {\n        this._testOnBorrow();\n      }\n    } // if we aren't testing-on-borrow then lets try to allocate what we can\n\n\n    if (this._config.testOnBorrow === false) {\n      const actualNumberOfResourcesToDispatch = Math.min(this._availableObjects.length, numWaitingClients);\n\n      for (let i = 0; actualNumberOfResourcesToDispatch > i; i++) {\n        this._dispatchResource();\n      }\n    }\n  }\n  /**\n   * Dispatches a pooledResource to the next waiting client (if any) else\n   * puts the PooledResource back on the available list\n   * @param  {PooledResource} pooledResource [description]\n   * @return {Boolean}                [description]\n   */\n\n\n  _dispatchPooledResourceToNextWaitingClient(pooledResource) {\n    const clientResourceRequest = this._waitingClientsQueue.dequeue();\n\n    if (clientResourceRequest === undefined || clientResourceRequest.state !== Deferred.PENDING) {\n      // While we were away either all the waiting clients timed out\n      // or were somehow fulfilled. put our pooledResource back.\n      this._addPooledResourceToAvailableObjects(pooledResource); // TODO: do need to trigger anything before we leave?\n\n\n      return false;\n    }\n\n    const loan = new ResourceLoan(pooledResource, this._Promise);\n\n    this._resourceLoans.set(pooledResource.obj, loan);\n\n    pooledResource.allocate();\n    clientResourceRequest.resolve(pooledResource.obj);\n    return true;\n  }\n  /**\n   * tracks on operation using given set\n   * handles adding/removing from the set and resolve/rejects the value/reason\n   * @param  {Promise} operation\n   * @param  {Set} set       Set holding operations\n   * @return {Promise}       Promise that resolves once operation has been removed from set\n   */\n\n\n  _trackOperation(operation, set) {\n    set.add(operation);\n    return operation.then(v => {\n      set.delete(operation);\n      return this._Promise.resolve(v);\n    }, e => {\n      set.delete(operation);\n      return this._Promise.reject(e);\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _createResource() {\n    // An attempt to create a resource\n    const factoryPromise = this._factory.create();\n\n    const wrappedFactoryPromise = this._Promise.resolve(factoryPromise).then(resource => {\n      const pooledResource = new PooledResource(resource);\n\n      this._allObjects.add(pooledResource);\n\n      this._addPooledResourceToAvailableObjects(pooledResource);\n    });\n\n    this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations).then(() => {\n      this._dispense(); // Stop bluebird complaining about this side-effect only handler\n      // - a promise was created in a handler but was not returned from it\n      // https://goo.gl/rRqMUw\n\n\n      return null;\n    }).catch(reason => {\n      this.emit(FACTORY_CREATE_ERROR, reason);\n\n      this._dispense();\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _ensureMinimum() {\n    if (this._draining === true) {\n      return;\n    }\n\n    const minShortfall = this._config.min - this._count;\n\n    for (let i = 0; i < minShortfall; i++) {\n      this._createResource();\n    }\n  }\n\n  _evict() {\n    const testsToRun = Math.min(this._config.numTestsPerEvictionRun, this._availableObjects.length);\n    const evictionConfig = {\n      softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,\n      idleTimeoutMillis: this._config.idleTimeoutMillis,\n      min: this._config.min\n    };\n\n    for (let testsHaveRun = 0; testsHaveRun < testsToRun;) {\n      const iterationResult = this._evictionIterator.next(); // Safety check incase we could get stuck in infinite loop because we\n      // somehow emptied the array after chekcing it's length\n\n\n      if (iterationResult.done === true && this._availableObjects.length < 1) {\n        this._evictionIterator.reset();\n\n        return;\n      } // if this happens it should just mean we reached the end of the\n      // list and can reset the cursor.\n\n\n      if (iterationResult.done === true && this._availableObjects.length > 0) {\n        this._evictionIterator.reset();\n\n        continue;\n      }\n\n      const resource = iterationResult.value;\n\n      const shouldEvict = this._evictor.evict(evictionConfig, resource, this._availableObjects.length);\n\n      testsHaveRun++;\n\n      if (shouldEvict === true) {\n        // take it out of the _availableObjects list\n        this._evictionIterator.remove();\n\n        this._destroy(resource);\n      }\n    }\n  }\n\n  _scheduleEvictorRun() {\n    // Start eviction if set\n    if (this._config.evictionRunIntervalMillis > 0) {\n      // @ts-ignore\n      this._scheduledEviction = setTimeout(() => {\n        this._evict();\n\n        this._scheduleEvictorRun();\n      }, this._config.evictionRunIntervalMillis);\n    }\n  }\n\n  _descheduleEvictorRun() {\n    if (this._scheduledEviction) {\n      clearTimeout(this._scheduledEviction);\n    }\n\n    this._scheduledEviction = null;\n  }\n\n  start() {\n    if (this._draining === true) {\n      return;\n    }\n\n    if (this._started === true) {\n      return;\n    }\n\n    this._started = true;\n\n    this._scheduleEvictorRun();\n\n    this._ensureMinimum();\n  }\n  /**\n   * Request a new resource. The callback will be called,\n   * when a new resource is available, passing the resource to the callback.\n   * TODO: should we add a seperate \"acquireWithPriority\" function\n   *\n   * @param {Number} [priority=0]\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Promise}\n   */\n\n\n  acquire(priority) {\n    if (this._started === false && this._config.autostart === false) {\n      this.start();\n    }\n\n    if (this._draining) {\n      return this._Promise.reject(new Error(\"pool is draining and cannot accept work\"));\n    } // TODO: should we defer this check till after this event loop incase \"the situation\" changes in the meantime\n\n\n    if (this.spareResourceCapacity < 1 && this._availableObjects.length < 1 && this._config.maxWaitingClients !== undefined && this._waitingClientsQueue.length >= this._config.maxWaitingClients) {\n      return this._Promise.reject(new Error(\"max waitingClients count exceeded\"));\n    }\n\n    const resourceRequest = new ResourceRequest(this._config.acquireTimeoutMillis, this._Promise);\n\n    this._waitingClientsQueue.enqueue(resourceRequest, priority);\n\n    this._dispense();\n\n    return resourceRequest.promise;\n  }\n  /**\n   * [use method, aquires a resource, passes the resource to a user supplied function and releases it]\n   * @param  {Function} fn [a function that accepts a resource and returns a promise that resolves/rejects once it has finished using the resource]\n   * @return {Promise}      [resolves once the resource is released to the pool]\n   */\n\n\n  use(fn) {\n    return this.acquire().then(resource => {\n      return fn(resource).then(result => {\n        this.release(resource);\n        return result;\n      }, err => {\n        this.destroy(resource);\n        throw err;\n      });\n    });\n  }\n  /**\n   * Check if resource is currently on loan from the pool\n   *\n   * @param {Function} resource\n   *    Resource for checking.\n   *\n   * @returns {Boolean}\n   *  True if resource belongs to this pool and false otherwise\n   */\n\n\n  isBorrowedResource(resource) {\n    return this._resourceLoans.has(resource);\n  }\n  /**\n   * Return the resource to the pool when it is no longer required.\n   *\n   * @param {Object} resource\n   *   The acquired object to be put back to the pool.\n   */\n\n\n  release(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n    }\n\n    this._resourceLoans.delete(resource);\n\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n    pooledResource.deallocate();\n\n    this._addPooledResourceToAvailableObjects(pooledResource);\n\n    this._dispense();\n\n    return this._Promise.resolve();\n  }\n  /**\n   * Request the resource to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource\n   *   The acquired resource to be destoyed.\n   */\n\n\n  destroy(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n    }\n\n    this._resourceLoans.delete(resource);\n\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n    pooledResource.deallocate();\n\n    this._destroy(pooledResource);\n\n    this._dispense();\n\n    return this._Promise.resolve();\n  }\n\n  _addPooledResourceToAvailableObjects(pooledResource) {\n    pooledResource.idle();\n\n    if (this._config.fifo === true) {\n      this._availableObjects.push(pooledResource);\n    } else {\n      this._availableObjects.unshift(pooledResource);\n    }\n  }\n  /**\n   * Disallow any new acquire calls and let the request backlog dissapate.\n   * The Pool will no longer attempt to maintain a \"min\" number of resources\n   * and will only make new resources on demand.\n   * Resolves once all resource requests are fulfilled and all resources are returned to pool and available...\n   * Should probably be called \"drain work\"\n   * @returns {Promise}\n   */\n\n\n  drain() {\n    this._draining = true;\n    return this.__allResourceRequestsSettled().then(() => {\n      return this.__allResourcesReturned();\n    }).then(() => {\n      this._descheduleEvictorRun();\n    });\n  }\n\n  __allResourceRequestsSettled() {\n    if (this._waitingClientsQueue.length > 0) {\n      // wait for last waiting client to be settled\n      // FIXME: what if they can \"resolve\" out of order....?\n      return reflector(this._waitingClientsQueue.tail.promise);\n    }\n\n    return this._Promise.resolve();\n  } // FIXME: this is a horrific mess\n\n\n  __allResourcesReturned() {\n    const ps = Array.from(this._resourceLoans.values()).map(loan => loan.promise).map(reflector);\n    return this._Promise.all(ps);\n  }\n  /**\n   * Forcibly destroys all available resources regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * resources as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0 and the pool isn't \"draining\", the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling clear()\n   *\n   */\n\n\n  clear() {\n    const reflectedCreatePromises = Array.from(this._factoryCreateOperations).map(reflector); // wait for outstanding factory.create to complete\n\n    return this._Promise.all(reflectedCreatePromises).then(() => {\n      // Destroy existing resources\n      // @ts-ignore\n      for (const resource of this._availableObjects) {\n        this._destroy(resource);\n      }\n\n      const reflectedDestroyPromises = Array.from(this._factoryDestroyOperations).map(reflector);\n      return reflector(this._Promise.all(reflectedDestroyPromises));\n    });\n  }\n  /**\n   * How many resources are available to allocated\n   * (includes resources that have not been tested and may faul validation)\n   * NOTE: internal for now as the name is awful and might not be useful to anyone\n   * @return {Number} number of resources the pool has to allocate\n   */\n\n\n  get _potentiallyAllocableResourceCount() {\n    return this._availableObjects.length + this._testOnBorrowResources.size + this._testOnReturnResources.size + this._factoryCreateOperations.size;\n  }\n  /**\n   * The combined count of the currently created objects and those in the\n   * process of being created\n   * Does NOT include resources in the process of being destroyed\n   * sort of legacy...\n   * @return {Number}\n   */\n\n\n  get _count() {\n    return this._allObjects.size + this._factoryCreateOperations.size;\n  }\n  /**\n   * How many more resources does the pool have room for\n   * @return {Number} number of resources the pool could create before hitting any limits\n   */\n\n\n  get spareResourceCapacity() {\n    return this._config.max - (this._allObjects.size + this._factoryCreateOperations.size);\n  }\n  /**\n   * see _count above\n   * @return {Number} [description]\n   */\n\n\n  get size() {\n    return this._count;\n  }\n  /**\n   * number of available resources\n   * @return {Number} [description]\n   */\n\n\n  get available() {\n    return this._availableObjects.length;\n  }\n  /**\n   * number of resources that are currently acquired\n   * @return {Number} [description]\n   */\n\n\n  get borrowed() {\n    return this._resourceLoans.size;\n  }\n  /**\n   * number of waiting acquire calls\n   * @return {Number} [description]\n   */\n\n\n  get pending() {\n    return this._waitingClientsQueue.length;\n  }\n  /**\n   * maximum size of the pool\n   * @return {Number} [description]\n   */\n\n\n  get max() {\n    return this._config.max;\n  }\n  /**\n   * minimum size of the pool\n   * @return {Number} [description]\n   */\n\n\n  get min() {\n    return this._config.min;\n  }\n\n}\n\nmodule.exports = Pool;","map":null,"metadata":{},"sourceType":"script"}